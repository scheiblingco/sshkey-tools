<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sshkey_tools.cert API documentation</title>
<meta name="description" content="Contains classes for OpenSSH Certificates, generation, parsing and signing
Raises:
_EX.SSHCertificateException: General error in certificate
â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sshkey_tools.cert</code></h1>
</header>
<section id="section-intro">
<p>Contains classes for OpenSSH Certificates, generation, parsing and signing</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>_EX.SSHCertificateException</code></dt>
<dd>General error in certificate</dd>
<dt><code>_EX.InvalidCertificateFormatException</code></dt>
<dd>An error with the format of the certificate</dd>
<dt><code>_EX.InvalidCertificateFieldException</code></dt>
<dd>An invalid field has been added to the certificate</dd>
<dt><code>_EX.NoPrivateKeyException</code></dt>
<dd>The certificate contains no private key</dd>
<dt><code>_EX.NotSignedException</code></dt>
<dd>The certificate is not signed and cannot be exported</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Contains classes for OpenSSH Certificates, generation, parsing and signing
    Raises:
        _EX.SSHCertificateException: General error in certificate
        _EX.InvalidCertificateFormatException: An error with the format of the certificate
        _EX.InvalidCertificateFieldException: An invalid field has been added to the certificate
        _EX.NoPrivateKeyException: The certificate contains no private key
        _EX.NotSignedException: The certificate is not signed and cannot be exported

&#34;&#34;&#34;
from base64 import b64encode, b64decode
from typing import Union
from .keys import (
    PublicKey,
    PrivateKey,
    RSAPublicKey,
    DSAPublicKey,
    ECDSAPublicKey,
    ED25519PublicKey,
)
from . import fields as _FIELD
from . import exceptions as _EX
from .keys import RsaAlgs
from .utils import join_dicts

CERTIFICATE_FIELDS = {
    &#34;serial&#34;: _FIELD.SerialField,
    &#34;cert_type&#34;: _FIELD.CertificateTypeField,
    &#34;key_id&#34;: _FIELD.KeyIDField,
    &#34;principals&#34;: _FIELD.PrincipalsField,
    &#34;valid_after&#34;: _FIELD.ValidityStartField,
    &#34;valid_before&#34;: _FIELD.ValidityEndField,
    &#34;critical_options&#34;: _FIELD.CriticalOptionsField,
    &#34;extensions&#34;: _FIELD.ExtensionsField,
}

CERT_TYPES = {
    &#34;ssh-rsa-cert-v01@openssh.com&#34;: (&#34;RSACertificate&#34;, &#34;_FIELD.RSAPubkeyField&#34;),
    &#34;rsa-sha2-256-cert-v01@openssh.com&#34;: (&#34;RSACertificate&#34;, &#34;_FIELD.RSAPubkeyField&#34;),
    &#34;rsa-sha2-512-cert-v01@openssh.com&#34;: (&#34;RSACertificate&#34;, &#34;_FIELD.RSAPubkeyField&#34;),
    &#34;ssh-dss-cert-v01@openssh.com&#34;: (&#34;DSACertificate&#34;, &#34;_FIELD.DSAPubkeyField&#34;),
    &#34;ecdsa-sha2-nistp256-cert-v01@openssh.com&#34;: (
        &#34;ECDSACertificate&#34;,
        &#34;_FIELD.ECDSAPubkeyField&#34;,
    ),
    &#34;ecdsa-sha2-nistp384-cert-v01@openssh.com&#34;: (
        &#34;ECDSACertificate&#34;,
        &#34;_FIELD.ECDSAPubkeyField&#34;,
    ),
    &#34;ecdsa-sha2-nistp521-cert-v01@openssh.com&#34;: (
        &#34;ECDSACertificate&#34;,
        &#34;_FIELD.ECDSAPubkeyField&#34;,
    ),
    &#34;ssh-ed25519-cert-v01@openssh.com&#34;: (
        &#34;ED25519Certificate&#34;,
        &#34;_FIELD.ED25519PubkeyField&#34;,
    ),
}


class SSHCertificate:
    &#34;&#34;&#34;
    General class for SSH Certificates, used for loading and parsing.
    To create new certificates, use the respective keytype classes
    or the from_public_key classmethod
    &#34;&#34;&#34;

    def __init__(
        self,
        subject_pubkey: PublicKey = None,
        ca_privkey: PrivateKey = None,
        decoded: dict = None,
        **kwargs,
    ) -&gt; None:
        if self.__class__.__name__ == &#34;SSHCertificate&#34;:
            raise _EX.InvalidClassCallException(
                &#34;You cannot instantiate SSHCertificate directly. Use \n&#34;
                + &#34;one of the child classes, or call via decode, \n&#34;
                + &#34;or one of the from_-classmethods&#34;
            )

        if decoded is not None:
            self.signature = decoded.pop(&#34;signature&#34;)
            self.signature_pubkey = decoded.pop(&#34;ca_pubkey&#34;)

            self.header = {
                &#34;pubkey_type&#34;: decoded.pop(&#34;pubkey_type&#34;),
                &#34;nonce&#34;: decoded.pop(&#34;nonce&#34;),
                &#34;public_key&#34;: decoded.pop(&#34;public_key&#34;),
            }

            self.fields = decoded

            return

        if subject_pubkey is None:
            raise _EX.SSHCertificateException(&#34;The subject public key is required&#34;)

        self.header = {
            &#34;pubkey_type&#34;: _FIELD.PubkeyTypeField,
            &#34;nonce&#34;: _FIELD.NonceField(),
            &#34;public_key&#34;: _FIELD.PublicKeyField.from_object(subject_pubkey),
        }

        if ca_privkey is not None:
            self.signature = _FIELD.SignatureField.from_object(ca_privkey)
            self.signature_pubkey = _FIELD.CAPublicKeyField.from_object(
                ca_privkey.public_key
            )

        self.fields = dict(CERTIFICATE_FIELDS)
        self.set_opts(**kwargs)

    def __str__(self):
        principals = (
            &#34;\n&#34;
            + &#34;\n&#34;.join(
                &#34;&#34;.join([&#34; &#34;] * 32) + (x.decode(&#34;utf-8&#34;) if isinstance(x, bytes) else x)
                for x in self.fields[&#34;principals&#34;].value
            )
            if len(self.fields[&#34;principals&#34;].value) &gt; 0
            else &#34;none&#34;
        )

        critical = (
            &#34;\n&#34;
            + &#34;\n&#34;.join(
                &#34;&#34;.join([&#34; &#34;] * 32) + (x.decode(&#34;utf-8&#34;) if isinstance(x, bytes) else x)
                for x in self.fields[&#34;critical_options&#34;].value
            )
            if len(self.fields[&#34;critical_options&#34;].value) &gt; 0
            else &#34;none&#34;
        )

        extensions = (
            &#34;\n&#34;
            + &#34;\n&#34;.join(
                &#34;&#34;.join([&#34; &#34;] * 32) + (x.decode(&#34;utf-8&#34;) if isinstance(x, bytes) else x)
                for x in self.fields[&#34;extensions&#34;].value
            )
            if len(self.fields[&#34;extensions&#34;].value) &gt; 0
            else &#34;none&#34;
        )

        signature_val = (
            b64encode(self.signature.value).decode(&#34;utf-8&#34;)
            if isinstance(self.signature.value, bytes)
            else &#34;Not signed&#34;
        )

        return f&#34;&#34;&#34;
        Certificate:
            Pubkey Type:        {self.header[&#39;pubkey_type&#39;].value}
            Public Key:         {str(self.header[&#39;public_key&#39;])}
            CA Public Key:      {str(self.signature_pubkey)}
            Nonce:              {self.header[&#39;nonce&#39;].value}
            Certificate Type:   {&#39;User&#39; if self.fields[&#39;cert_type&#39;].value == 1 else &#39;Host&#39;}
            Valid After:        {self.fields[&#39;valid_after&#39;].value.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)}
            Valid Until:        {self.fields[&#39;valid_before&#39;].value.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)}
            Principals:         {principals}
            Critical options:   {critical}
            Extensions:         {extensions}
            Signature:          {signature_val}
        &#34;&#34;&#34;

    @staticmethod
    def decode(
        cert_bytes: bytes, pubkey_class: _FIELD.PublicKeyField = None
    ) -&gt; &#34;SSHCertificate&#34;:
        &#34;&#34;&#34;
        Decode an existing certificate and import it into a new object

        Args:
            cert_bytes (bytes): The certificate bytes, base64 decoded middle part of the certificate
            pubkey_field (_FIELD.PublicKeyField): Instance of the PublicKeyField class, only needs
                to be set if it can&#39;t be detected automatically

        Raises:
            _EX.InvalidCertificateFormatException: Invalid or unknown certificate format

        Returns:
            SSHCertificate: SSHCertificate child class
        &#34;&#34;&#34;
        if pubkey_class is None:
            cert_type = _FIELD.StringField.decode(cert_bytes)[0].encode(&#34;utf-8&#34;)
            pubkey_class = CERT_TYPES.get(cert_type, False)

        if pubkey_class is False:
            raise _EX.InvalidCertificateFormatException(
                &#34;Could not determine certificate type, please use one &#34;
                + &#34;of the specific classes or specify the pubkey_class&#34;
            )

        decode_fields = join_dicts(
            {
                &#34;pubkey_type&#34;: _FIELD.PubkeyTypeField,
                &#34;nonce&#34;: _FIELD.NonceField,
                &#34;public_key&#34;: pubkey_class,
            },
            CERTIFICATE_FIELDS,
            {
                &#34;reserved&#34;: _FIELD.ReservedField,
                &#34;ca_pubkey&#34;: _FIELD.CAPublicKeyField,
                &#34;signature&#34;: _FIELD.SignatureField,
            },
        )

        cert = {}

        for item in decode_fields.keys():
            cert[item], cert_bytes = decode_fields[item].from_decode(cert_bytes)

        if cert_bytes != b&#34;&#34;:
            raise _EX.InvalidCertificateFormatException(
                &#34;The certificate has additional data after everything has been extracted&#34;
            )

        pubkey_type = cert[&#34;pubkey_type&#34;].value
        if isinstance(pubkey_type, bytes):
            pubkey_type = pubkey_type.decode(&#34;utf-8&#34;)

        cert_type = CERT_TYPES[pubkey_type]
        cert.pop(&#34;reserved&#34;)
        return globals()[cert_type[0]](
            subject_pubkey=cert[&#34;public_key&#34;].value, decoded=cert
        )

    @classmethod
    def from_public_class(
        cls, public_key: PublicKey, ca_privkey: PrivateKey = None, **kwargs
    ) -&gt; &#34;SSHCertificate&#34;:
        &#34;&#34;&#34;
        Creates a new certificate from a supplied public key

        Args:
            public_key (PublicKey): The public key for which to create a certificate

        Returns:
            SSHCertificate: SSHCertificate child class
        &#34;&#34;&#34;
        return globals()[
            public_key.__class__.__name__.replace(&#34;PublicKey&#34;, &#34;Certificate&#34;)
        ](public_key, ca_privkey, **kwargs)

    @classmethod
    def from_bytes(cls, cert_bytes: bytes):
        &#34;&#34;&#34;
        Loads an existing certificate from the byte value.

        Args:
            cert_bytes (bytes): Certificate bytes, base64 decoded middle part of the certificate

        Returns:
            SSHCertificate: SSHCertificate child class
        &#34;&#34;&#34;
        cert_type, _ = _FIELD.StringField.decode(cert_bytes)
        target_class = CERT_TYPES[cert_type]
        return globals()[target_class[0]].decode(cert_bytes)

    @classmethod
    def from_string(cls, cert_str: Union[str, bytes], encoding: str = &#34;utf-8&#34;):
        &#34;&#34;&#34;
        Loads an existing certificate from a string in the format
        [certificate-type] [base64-encoded-certificate] [optional-comment]

        Args:
            cert_str (str): The string containing the certificate
            encoding (str, optional): The encoding of the string. Defaults to &#39;utf-8&#39;.

        Returns:
            SSHCertificate: SSHCertificate child class
        &#34;&#34;&#34;
        if isinstance(cert_str, str):
            cert_str = cert_str.encode(encoding)

        certificate = b64decode(cert_str.split(b&#34; &#34;)[1])
        return cls.from_bytes(cert_bytes=certificate)

    @classmethod
    def from_file(cls, path: str, encoding: str = &#34;utf-8&#34;):
        &#34;&#34;&#34;
        Loads an existing certificate from a file

        Args:
            path (str): The path to the certificate file
            encoding (str, optional): Encoding of the file. Defaults to &#39;utf-8&#39;.

        Returns:
            SSHCertificate: SSHCertificate child class
        &#34;&#34;&#34;
        return cls.from_string(open(path, &#34;r&#34;, encoding=encoding).read())

    def set_ca(self, ca_privkey: PrivateKey):
        &#34;&#34;&#34;
        Set the CA Private Key for signing the certificate

        Args:
            ca_privkey (PrivateKey): The CA private key
        &#34;&#34;&#34;
        self.signature = _FIELD.SignatureField.from_object(ca_privkey)
        self.signature_pubkey = _FIELD.CAPublicKeyField.from_object(
            ca_privkey.public_key
        )

    def set_type(self, pubkey_type: str):
        &#34;&#34;&#34;
        Set the type of the public key if not already set automatically
        The child classes will set this automatically

        Args:
            pubkey_type (str): Public key type, e.g. ssh-rsa-cert-v01@openssh.com
        &#34;&#34;&#34;
        if not getattr(self.header[&#34;pubkey_type&#34;], &#34;value&#34;, False):
            self.header[&#34;pubkey_type&#34;] = self.header[&#34;pubkey_type&#34;](pubkey_type)

    def set_opt(self, key: str, value):
        &#34;&#34;&#34;
        Add information to a field in the certificate

        Args:
            key (str): The key to set
            value (mixed): The new value for the field

        Raises:
            _EX.InvalidCertificateFieldException: Invalid field
        &#34;&#34;&#34;
        if key not in self.fields:
            raise _EX.InvalidCertificateFieldException(
                f&#34;{key} is not a valid certificate field&#34;
            )

        try:
            if self.fields[key].value not in [None, False, &#34;&#34;, [], ()]:
                self.fields[key].value = value
        except AttributeError:
            self.fields[key] = self.fields[key](value)

    def set_opts(self, **kwargs):
        &#34;&#34;&#34;
        Set multiple options at once
        &#34;&#34;&#34;
        for key, value in kwargs.items():
            self.set_opt(key, value)

    # pylint: disable=used-before-assignment
    def can_sign(self) -&gt; bool:
        &#34;&#34;&#34;
        Determine if the certificate is ready to be signed

        Raises:
            ...: Exception from the respective field with error
            _EX.NoPrivateKeyException: Private key is missing from class

        Returns:
            bool: True/False if the certificate can be signed
        &#34;&#34;&#34;
        exceptions = []
        for field in self.fields.values():
            try:
                valid = field.validate()
            except TypeError:
                valid = _EX.SignatureNotPossibleException(
                    f&#34;The field {field} is missing a value&#34;
                )
            finally:
                if isinstance(valid, Exception):
                    exceptions.append(valid)

        if (
            getattr(self, &#34;signature&#34;, False) is False
            or getattr(self, &#34;signature_pubkey&#34;, False) is False
        ):
            exceptions.append(
                _EX.SignatureNotPossibleException(&#34;No CA private key is set&#34;)
            )

        if len(exceptions) &gt; 0:
            raise _EX.SignatureNotPossibleException(exceptions)

        if self.signature.can_sign() is True:
            return True

        raise _EX.SignatureNotPossibleException(
            &#34;The certificate cannot be signed, the CA private key is not loaded&#34;
        )

    def get_signable_data(self) -&gt; bytes:
        &#34;&#34;&#34;
        Gets the signable byte string from the certificate fields

        Returns:
            bytes: The data in the certificate which is signed
        &#34;&#34;&#34;
        return (
            b&#34;&#34;.join(
                [
                    bytes(x)
                    for x in tuple(self.header.values()) + tuple(self.fields.values())
                ]
            )
            + bytes(_FIELD.ReservedField())
            + bytes(self.signature_pubkey)
        )

    def sign(self):
        &#34;&#34;&#34;
        Sign the certificate

        Returns:
            SSHCertificate: The signed certificate class
        &#34;&#34;&#34;
        if self.can_sign():
            self.signature.sign(data=self.get_signable_data())

        return self

    def verify(self, ca_pubkey: PublicKey = None) -&gt; bool:
        &#34;&#34;&#34;
        Verifies a signature against a given public key.

        If no public key is provided, the signature is checked against
        the public/private key provided to the class on creation
        or decoding.

        Not providing the public key for the CA with an imported
        certificate means the verification will succeed even if an
        attacker has replaced the signature and public key for signing.

        If the certificate wasn&#39;t created and signed on the same occasion
        as the validity check, you should always provide a public key for
        verificiation.

        Returns:
            bool: If the certificate signature is valid
        &#34;&#34;&#34;

        if ca_pubkey is None:
            ca_pubkey = self.signature_pubkey.value

        cert_data = self.get_signable_data()
        signature = self.signature.value

        return ca_pubkey.verify(
            cert_data,
            signature
        )

    def to_bytes(self) -&gt; bytes:
        &#34;&#34;&#34;
        Export the signed certificate in byte-format

        Raises:
            _EX.NotSignedException: The certificate has not been signed yet

        Returns:
            bytes: The certificate bytes
        &#34;&#34;&#34;
        if self.signature.is_signed is True:
            return self.get_signable_data() + bytes(self.signature)

        raise _EX.NotSignedException(&#34;The certificate has not been signed&#34;)

    def to_string(
        self, comment: Union[str, bytes] = None, encoding: str = &#34;utf-8&#34;
    ) -&gt; str:
        &#34;&#34;&#34;
        Export the signed certificate to a string, ready to be written to file

        Args:
            comment (Union[str, bytes], optional): Comment to add to the string. Defaults to None.
            encoding (str, optional): Encoding to use for the string. Defaults to &#39;utf-8&#39;.

        Returns:
            str: Certificate string
        &#34;&#34;&#34;
        return (
            self.header[&#34;pubkey_type&#34;].value.encode(encoding)
            + b&#34; &#34;
            + b64encode(
                self.to_bytes(),
            )
            + b&#34; &#34;
            + (comment if comment else b&#34;&#34;)
        ).decode(&#34;utf-8&#34;)

    def to_file(
        self, path: str, comment: Union[str, bytes] = None, encoding: str = &#34;utf-8&#34;
    ):
        &#34;&#34;&#34;
        Saves the certificate to a file

        Args:
            path (str): The path of the file to save to
            comment (Union[str, bytes], optional): Comment to add to the certificate end.
                                                   Defaults to None.
            encoding (str, optional): Encoding for the file. Defaults to &#39;utf-8&#39;.
        &#34;&#34;&#34;
        with open(path, &#34;w&#34;, encoding=encoding) as file:
            file.write(self.to_string(comment, encoding))


class RSACertificate(SSHCertificate):
    &#34;&#34;&#34;
    Specific class for RSA Certificates. Inherits from SSHCertificate
    &#34;&#34;&#34;

    def __init__(
        self,
        subject_pubkey: RSAPublicKey,
        ca_privkey: PrivateKey = None,
        rsa_alg: RsaAlgs = RsaAlgs.SHA512,
        **kwargs,
    ):

        super().__init__(subject_pubkey, ca_privkey, **kwargs)
        self.rsa_alg = rsa_alg
        self.set_type(f&#34;{rsa_alg.value[0]}-cert-v01@openssh.com&#34;)

    @classmethod
    # pylint: disable=arguments-differ
    def decode(cls, cert_bytes: bytes) -&gt; &#34;SSHCertificate&#34;:
        &#34;&#34;&#34;
        Decode an existing RSA Certificate

        Args:
            cert_bytes (bytes): The base64-decoded bytes for the certificate

        Returns:
            RSACertificate: The decoded certificate
        &#34;&#34;&#34;
        return super().decode(cert_bytes, _FIELD.RSAPubkeyField)

    def sign(self, hash_alg: RsaAlgs = RsaAlgs.SHA512):
        &#34;&#34;&#34;
        Sign the certificate

        Args:
            hash_alg (RsaAlgs): The hashing algorithm to use for creating
                                the hash of the certificate before signing

        Returns:
            SSHCertificate: The signed certificate class
        &#34;&#34;&#34;
        if self.can_sign():
            self.signature.sign(
                data=self.get_signable_data(), 
                hash_alg=hash_alg
            )

        return self


class DSACertificate(SSHCertificate):
    &#34;&#34;&#34;
    Specific class for DSA/DSS Certificates. Inherits from SSHCertificate
    &#34;&#34;&#34;

    def __init__(
        self, subject_pubkey: DSAPublicKey, ca_privkey: PrivateKey = None, **kwargs
    ):
        super().__init__(subject_pubkey, ca_privkey, **kwargs)
        self.set_type(&#34;ssh-dss-cert-v01@openssh.com&#34;)

    @classmethod
    # pylint: disable=arguments-differ
    def decode(cls, cert_bytes: bytes) -&gt; &#34;DSACertificate&#34;:
        &#34;&#34;&#34;
        Decode an existing DSA Certificate

        Args:
            cert_bytes (bytes): The base64-decoded bytes for the certificate

        Returns:
            DSACertificate: The decoded certificate
        &#34;&#34;&#34;
        return super().decode(cert_bytes, _FIELD.DSAPubkeyField)


class ECDSACertificate(SSHCertificate):
    &#34;&#34;&#34;
    Specific class for ECDSA Certificates. Inherits from SSHCertificate
    &#34;&#34;&#34;

    def __init__(
        self, subject_pubkey: ECDSAPublicKey, ca_privkey: PrivateKey = None, **kwargs
    ):
        super().__init__(subject_pubkey, ca_privkey, **kwargs)
        self.set_type(
            f&#34;ecdsa-sha2-nistp{subject_pubkey.key.curve.key_size}-cert-v01@openssh.com&#34;
        )

    @classmethod
    # pylint: disable=arguments-differ
    def decode(cls, cert_bytes: bytes) -&gt; &#34;ECDSACertificate&#34;:
        &#34;&#34;&#34;
        Decode an existing ECDSA Certificate

        Args:
            cert_bytes (bytes): The base64-decoded bytes for the certificate

        Returns:
            ECDSACertificate: The decoded certificate
        &#34;&#34;&#34;
        return super().decode(cert_bytes, _FIELD.ECDSAPubkeyField)


class ED25519Certificate(SSHCertificate):
    &#34;&#34;&#34;
    Specific class for ED25519 Certificates. Inherits from SSHCertificate
    &#34;&#34;&#34;

    def __init__(
        self, subject_pubkey: ED25519PublicKey, ca_privkey: PrivateKey = None, **kwargs
    ):
        super().__init__(subject_pubkey, ca_privkey, **kwargs)
        self.set_type(&#34;ssh-ed25519-cert-v01@openssh.com&#34;)

    @classmethod
    # pylint: disable=arguments-differ
    def decode(cls, cert_bytes: bytes) -&gt; &#34;ED25519Certificate&#34;:
        &#34;&#34;&#34;
        Decode an existing ED25519 Certificate

        Args:
            cert_bytes (bytes): The base64-decoded bytes for the certificate

        Returns:
            ED25519Certificate: The decoded certificate
        &#34;&#34;&#34;
        return super().decode(cert_bytes, _FIELD.ED25519PubkeyField)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sshkey_tools.cert.DSACertificate"><code class="flex name class">
<span>class <span class="ident">DSACertificate</span></span>
<span>(</span><span>subject_pubkey:Â <a title="sshkey_tools.keys.DSAPublicKey" href="keys.html#sshkey_tools.keys.DSAPublicKey">DSAPublicKey</a>, ca_privkey:Â <a title="sshkey_tools.keys.PrivateKey" href="keys.html#sshkey_tools.keys.PrivateKey">PrivateKey</a>Â =Â None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Specific class for DSA/DSS Certificates. Inherits from SSHCertificate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DSACertificate(SSHCertificate):
    &#34;&#34;&#34;
    Specific class for DSA/DSS Certificates. Inherits from SSHCertificate
    &#34;&#34;&#34;

    def __init__(
        self, subject_pubkey: DSAPublicKey, ca_privkey: PrivateKey = None, **kwargs
    ):
        super().__init__(subject_pubkey, ca_privkey, **kwargs)
        self.set_type(&#34;ssh-dss-cert-v01@openssh.com&#34;)

    @classmethod
    # pylint: disable=arguments-differ
    def decode(cls, cert_bytes: bytes) -&gt; &#34;DSACertificate&#34;:
        &#34;&#34;&#34;
        Decode an existing DSA Certificate

        Args:
            cert_bytes (bytes): The base64-decoded bytes for the certificate

        Returns:
            DSACertificate: The decoded certificate
        &#34;&#34;&#34;
        return super().decode(cert_bytes, _FIELD.DSAPubkeyField)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.cert.SSHCertificate" href="#sshkey_tools.cert.SSHCertificate">SSHCertificate</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.cert.DSACertificate.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>cert_bytes:Â bytes) â€‘>Â <a title="sshkey_tools.cert.DSACertificate" href="#sshkey_tools.cert.DSACertificate">DSACertificate</a></span>
</code></dt>
<dd>
<div class="desc"><p>Decode an existing DSA Certificate</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cert_bytes</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The base64-decoded bytes for the certificate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sshkey_tools.cert.DSACertificate" href="#sshkey_tools.cert.DSACertificate">DSACertificate</a></code></dt>
<dd>The decoded certificate</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
# pylint: disable=arguments-differ
def decode(cls, cert_bytes: bytes) -&gt; &#34;DSACertificate&#34;:
    &#34;&#34;&#34;
    Decode an existing DSA Certificate

    Args:
        cert_bytes (bytes): The base64-decoded bytes for the certificate

    Returns:
        DSACertificate: The decoded certificate
    &#34;&#34;&#34;
    return super().decode(cert_bytes, _FIELD.DSAPubkeyField)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.cert.SSHCertificate" href="#sshkey_tools.cert.SSHCertificate">SSHCertificate</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.cert.SSHCertificate.can_sign" href="#sshkey_tools.cert.SSHCertificate.can_sign">can_sign</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.from_bytes" href="#sshkey_tools.cert.SSHCertificate.from_bytes">from_bytes</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.from_file" href="#sshkey_tools.cert.SSHCertificate.from_file">from_file</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.from_public_class" href="#sshkey_tools.cert.SSHCertificate.from_public_class">from_public_class</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.from_string" href="#sshkey_tools.cert.SSHCertificate.from_string">from_string</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.get_signable_data" href="#sshkey_tools.cert.SSHCertificate.get_signable_data">get_signable_data</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.set_ca" href="#sshkey_tools.cert.SSHCertificate.set_ca">set_ca</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.set_opt" href="#sshkey_tools.cert.SSHCertificate.set_opt">set_opt</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.set_opts" href="#sshkey_tools.cert.SSHCertificate.set_opts">set_opts</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.set_type" href="#sshkey_tools.cert.SSHCertificate.set_type">set_type</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.sign" href="#sshkey_tools.cert.SSHCertificate.sign">sign</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.to_bytes" href="#sshkey_tools.cert.SSHCertificate.to_bytes">to_bytes</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.to_file" href="#sshkey_tools.cert.SSHCertificate.to_file">to_file</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.to_string" href="#sshkey_tools.cert.SSHCertificate.to_string">to_string</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.verify" href="#sshkey_tools.cert.SSHCertificate.verify">verify</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.cert.ECDSACertificate"><code class="flex name class">
<span>class <span class="ident">ECDSACertificate</span></span>
<span>(</span><span>subject_pubkey:Â <a title="sshkey_tools.keys.ECDSAPublicKey" href="keys.html#sshkey_tools.keys.ECDSAPublicKey">ECDSAPublicKey</a>, ca_privkey:Â <a title="sshkey_tools.keys.PrivateKey" href="keys.html#sshkey_tools.keys.PrivateKey">PrivateKey</a>Â =Â None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Specific class for ECDSA Certificates. Inherits from SSHCertificate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ECDSACertificate(SSHCertificate):
    &#34;&#34;&#34;
    Specific class for ECDSA Certificates. Inherits from SSHCertificate
    &#34;&#34;&#34;

    def __init__(
        self, subject_pubkey: ECDSAPublicKey, ca_privkey: PrivateKey = None, **kwargs
    ):
        super().__init__(subject_pubkey, ca_privkey, **kwargs)
        self.set_type(
            f&#34;ecdsa-sha2-nistp{subject_pubkey.key.curve.key_size}-cert-v01@openssh.com&#34;
        )

    @classmethod
    # pylint: disable=arguments-differ
    def decode(cls, cert_bytes: bytes) -&gt; &#34;ECDSACertificate&#34;:
        &#34;&#34;&#34;
        Decode an existing ECDSA Certificate

        Args:
            cert_bytes (bytes): The base64-decoded bytes for the certificate

        Returns:
            ECDSACertificate: The decoded certificate
        &#34;&#34;&#34;
        return super().decode(cert_bytes, _FIELD.ECDSAPubkeyField)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.cert.SSHCertificate" href="#sshkey_tools.cert.SSHCertificate">SSHCertificate</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.cert.ECDSACertificate.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>cert_bytes:Â bytes) â€‘>Â <a title="sshkey_tools.cert.ECDSACertificate" href="#sshkey_tools.cert.ECDSACertificate">ECDSACertificate</a></span>
</code></dt>
<dd>
<div class="desc"><p>Decode an existing ECDSA Certificate</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cert_bytes</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The base64-decoded bytes for the certificate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sshkey_tools.cert.ECDSACertificate" href="#sshkey_tools.cert.ECDSACertificate">ECDSACertificate</a></code></dt>
<dd>The decoded certificate</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
# pylint: disable=arguments-differ
def decode(cls, cert_bytes: bytes) -&gt; &#34;ECDSACertificate&#34;:
    &#34;&#34;&#34;
    Decode an existing ECDSA Certificate

    Args:
        cert_bytes (bytes): The base64-decoded bytes for the certificate

    Returns:
        ECDSACertificate: The decoded certificate
    &#34;&#34;&#34;
    return super().decode(cert_bytes, _FIELD.ECDSAPubkeyField)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.cert.SSHCertificate" href="#sshkey_tools.cert.SSHCertificate">SSHCertificate</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.cert.SSHCertificate.can_sign" href="#sshkey_tools.cert.SSHCertificate.can_sign">can_sign</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.from_bytes" href="#sshkey_tools.cert.SSHCertificate.from_bytes">from_bytes</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.from_file" href="#sshkey_tools.cert.SSHCertificate.from_file">from_file</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.from_public_class" href="#sshkey_tools.cert.SSHCertificate.from_public_class">from_public_class</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.from_string" href="#sshkey_tools.cert.SSHCertificate.from_string">from_string</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.get_signable_data" href="#sshkey_tools.cert.SSHCertificate.get_signable_data">get_signable_data</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.set_ca" href="#sshkey_tools.cert.SSHCertificate.set_ca">set_ca</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.set_opt" href="#sshkey_tools.cert.SSHCertificate.set_opt">set_opt</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.set_opts" href="#sshkey_tools.cert.SSHCertificate.set_opts">set_opts</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.set_type" href="#sshkey_tools.cert.SSHCertificate.set_type">set_type</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.sign" href="#sshkey_tools.cert.SSHCertificate.sign">sign</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.to_bytes" href="#sshkey_tools.cert.SSHCertificate.to_bytes">to_bytes</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.to_file" href="#sshkey_tools.cert.SSHCertificate.to_file">to_file</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.to_string" href="#sshkey_tools.cert.SSHCertificate.to_string">to_string</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.verify" href="#sshkey_tools.cert.SSHCertificate.verify">verify</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.cert.ED25519Certificate"><code class="flex name class">
<span>class <span class="ident">ED25519Certificate</span></span>
<span>(</span><span>subject_pubkey:Â <a title="sshkey_tools.keys.ED25519PublicKey" href="keys.html#sshkey_tools.keys.ED25519PublicKey">ED25519PublicKey</a>, ca_privkey:Â <a title="sshkey_tools.keys.PrivateKey" href="keys.html#sshkey_tools.keys.PrivateKey">PrivateKey</a>Â =Â None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Specific class for ED25519 Certificates. Inherits from SSHCertificate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ED25519Certificate(SSHCertificate):
    &#34;&#34;&#34;
    Specific class for ED25519 Certificates. Inherits from SSHCertificate
    &#34;&#34;&#34;

    def __init__(
        self, subject_pubkey: ED25519PublicKey, ca_privkey: PrivateKey = None, **kwargs
    ):
        super().__init__(subject_pubkey, ca_privkey, **kwargs)
        self.set_type(&#34;ssh-ed25519-cert-v01@openssh.com&#34;)

    @classmethod
    # pylint: disable=arguments-differ
    def decode(cls, cert_bytes: bytes) -&gt; &#34;ED25519Certificate&#34;:
        &#34;&#34;&#34;
        Decode an existing ED25519 Certificate

        Args:
            cert_bytes (bytes): The base64-decoded bytes for the certificate

        Returns:
            ED25519Certificate: The decoded certificate
        &#34;&#34;&#34;
        return super().decode(cert_bytes, _FIELD.ED25519PubkeyField)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.cert.SSHCertificate" href="#sshkey_tools.cert.SSHCertificate">SSHCertificate</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.cert.ED25519Certificate.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>cert_bytes:Â bytes) â€‘>Â <a title="sshkey_tools.cert.ED25519Certificate" href="#sshkey_tools.cert.ED25519Certificate">ED25519Certificate</a></span>
</code></dt>
<dd>
<div class="desc"><p>Decode an existing ED25519 Certificate</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cert_bytes</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The base64-decoded bytes for the certificate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sshkey_tools.cert.ED25519Certificate" href="#sshkey_tools.cert.ED25519Certificate">ED25519Certificate</a></code></dt>
<dd>The decoded certificate</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
# pylint: disable=arguments-differ
def decode(cls, cert_bytes: bytes) -&gt; &#34;ED25519Certificate&#34;:
    &#34;&#34;&#34;
    Decode an existing ED25519 Certificate

    Args:
        cert_bytes (bytes): The base64-decoded bytes for the certificate

    Returns:
        ED25519Certificate: The decoded certificate
    &#34;&#34;&#34;
    return super().decode(cert_bytes, _FIELD.ED25519PubkeyField)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.cert.SSHCertificate" href="#sshkey_tools.cert.SSHCertificate">SSHCertificate</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.cert.SSHCertificate.can_sign" href="#sshkey_tools.cert.SSHCertificate.can_sign">can_sign</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.from_bytes" href="#sshkey_tools.cert.SSHCertificate.from_bytes">from_bytes</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.from_file" href="#sshkey_tools.cert.SSHCertificate.from_file">from_file</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.from_public_class" href="#sshkey_tools.cert.SSHCertificate.from_public_class">from_public_class</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.from_string" href="#sshkey_tools.cert.SSHCertificate.from_string">from_string</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.get_signable_data" href="#sshkey_tools.cert.SSHCertificate.get_signable_data">get_signable_data</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.set_ca" href="#sshkey_tools.cert.SSHCertificate.set_ca">set_ca</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.set_opt" href="#sshkey_tools.cert.SSHCertificate.set_opt">set_opt</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.set_opts" href="#sshkey_tools.cert.SSHCertificate.set_opts">set_opts</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.set_type" href="#sshkey_tools.cert.SSHCertificate.set_type">set_type</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.sign" href="#sshkey_tools.cert.SSHCertificate.sign">sign</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.to_bytes" href="#sshkey_tools.cert.SSHCertificate.to_bytes">to_bytes</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.to_file" href="#sshkey_tools.cert.SSHCertificate.to_file">to_file</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.to_string" href="#sshkey_tools.cert.SSHCertificate.to_string">to_string</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.verify" href="#sshkey_tools.cert.SSHCertificate.verify">verify</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.cert.RSACertificate"><code class="flex name class">
<span>class <span class="ident">RSACertificate</span></span>
<span>(</span><span>subject_pubkey:Â <a title="sshkey_tools.keys.RSAPublicKey" href="keys.html#sshkey_tools.keys.RSAPublicKey">RSAPublicKey</a>, ca_privkey:Â <a title="sshkey_tools.keys.PrivateKey" href="keys.html#sshkey_tools.keys.PrivateKey">PrivateKey</a>Â =Â None, rsa_alg:Â <a title="sshkey_tools.keys.RsaAlgs" href="keys.html#sshkey_tools.keys.RsaAlgs">RsaAlgs</a>Â =Â RsaAlgs.SHA512, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Specific class for RSA Certificates. Inherits from SSHCertificate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RSACertificate(SSHCertificate):
    &#34;&#34;&#34;
    Specific class for RSA Certificates. Inherits from SSHCertificate
    &#34;&#34;&#34;

    def __init__(
        self,
        subject_pubkey: RSAPublicKey,
        ca_privkey: PrivateKey = None,
        rsa_alg: RsaAlgs = RsaAlgs.SHA512,
        **kwargs,
    ):

        super().__init__(subject_pubkey, ca_privkey, **kwargs)
        self.rsa_alg = rsa_alg
        self.set_type(f&#34;{rsa_alg.value[0]}-cert-v01@openssh.com&#34;)

    @classmethod
    # pylint: disable=arguments-differ
    def decode(cls, cert_bytes: bytes) -&gt; &#34;SSHCertificate&#34;:
        &#34;&#34;&#34;
        Decode an existing RSA Certificate

        Args:
            cert_bytes (bytes): The base64-decoded bytes for the certificate

        Returns:
            RSACertificate: The decoded certificate
        &#34;&#34;&#34;
        return super().decode(cert_bytes, _FIELD.RSAPubkeyField)

    def sign(self, hash_alg: RsaAlgs = RsaAlgs.SHA512):
        &#34;&#34;&#34;
        Sign the certificate

        Args:
            hash_alg (RsaAlgs): The hashing algorithm to use for creating
                                the hash of the certificate before signing

        Returns:
            SSHCertificate: The signed certificate class
        &#34;&#34;&#34;
        if self.can_sign():
            self.signature.sign(
                data=self.get_signable_data(), 
                hash_alg=hash_alg
            )

        return self</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.cert.SSHCertificate" href="#sshkey_tools.cert.SSHCertificate">SSHCertificate</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.cert.RSACertificate.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>cert_bytes:Â bytes) â€‘>Â <a title="sshkey_tools.cert.SSHCertificate" href="#sshkey_tools.cert.SSHCertificate">SSHCertificate</a></span>
</code></dt>
<dd>
<div class="desc"><p>Decode an existing RSA Certificate</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cert_bytes</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The base64-decoded bytes for the certificate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sshkey_tools.cert.RSACertificate" href="#sshkey_tools.cert.RSACertificate">RSACertificate</a></code></dt>
<dd>The decoded certificate</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
# pylint: disable=arguments-differ
def decode(cls, cert_bytes: bytes) -&gt; &#34;SSHCertificate&#34;:
    &#34;&#34;&#34;
    Decode an existing RSA Certificate

    Args:
        cert_bytes (bytes): The base64-decoded bytes for the certificate

    Returns:
        RSACertificate: The decoded certificate
    &#34;&#34;&#34;
    return super().decode(cert_bytes, _FIELD.RSAPubkeyField)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.cert.RSACertificate.sign"><code class="name flex">
<span>def <span class="ident">sign</span></span>(<span>self, hash_alg:Â <a title="sshkey_tools.keys.RsaAlgs" href="keys.html#sshkey_tools.keys.RsaAlgs">RsaAlgs</a>Â =Â RsaAlgs.SHA512)</span>
</code></dt>
<dd>
<div class="desc"><p>Sign the certificate</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>hash_alg</code></strong> :&ensp;<code>RsaAlgs</code></dt>
<dd>The hashing algorithm to use for creating
the hash of the certificate before signing</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sshkey_tools.cert.SSHCertificate" href="#sshkey_tools.cert.SSHCertificate">SSHCertificate</a></code></dt>
<dd>The signed certificate class</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sign(self, hash_alg: RsaAlgs = RsaAlgs.SHA512):
    &#34;&#34;&#34;
    Sign the certificate

    Args:
        hash_alg (RsaAlgs): The hashing algorithm to use for creating
                            the hash of the certificate before signing

    Returns:
        SSHCertificate: The signed certificate class
    &#34;&#34;&#34;
    if self.can_sign():
        self.signature.sign(
            data=self.get_signable_data(), 
            hash_alg=hash_alg
        )

    return self</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.cert.SSHCertificate" href="#sshkey_tools.cert.SSHCertificate">SSHCertificate</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.cert.SSHCertificate.can_sign" href="#sshkey_tools.cert.SSHCertificate.can_sign">can_sign</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.from_bytes" href="#sshkey_tools.cert.SSHCertificate.from_bytes">from_bytes</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.from_file" href="#sshkey_tools.cert.SSHCertificate.from_file">from_file</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.from_public_class" href="#sshkey_tools.cert.SSHCertificate.from_public_class">from_public_class</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.from_string" href="#sshkey_tools.cert.SSHCertificate.from_string">from_string</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.get_signable_data" href="#sshkey_tools.cert.SSHCertificate.get_signable_data">get_signable_data</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.set_ca" href="#sshkey_tools.cert.SSHCertificate.set_ca">set_ca</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.set_opt" href="#sshkey_tools.cert.SSHCertificate.set_opt">set_opt</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.set_opts" href="#sshkey_tools.cert.SSHCertificate.set_opts">set_opts</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.set_type" href="#sshkey_tools.cert.SSHCertificate.set_type">set_type</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.to_bytes" href="#sshkey_tools.cert.SSHCertificate.to_bytes">to_bytes</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.to_file" href="#sshkey_tools.cert.SSHCertificate.to_file">to_file</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.to_string" href="#sshkey_tools.cert.SSHCertificate.to_string">to_string</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.verify" href="#sshkey_tools.cert.SSHCertificate.verify">verify</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.cert.SSHCertificate"><code class="flex name class">
<span>class <span class="ident">SSHCertificate</span></span>
<span>(</span><span>subject_pubkey:Â <a title="sshkey_tools.keys.PublicKey" href="keys.html#sshkey_tools.keys.PublicKey">PublicKey</a>Â =Â None, ca_privkey:Â <a title="sshkey_tools.keys.PrivateKey" href="keys.html#sshkey_tools.keys.PrivateKey">PrivateKey</a>Â =Â None, decoded:Â dictÂ =Â None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>General class for SSH Certificates, used for loading and parsing.
To create new certificates, use the respective keytype classes
or the from_public_key classmethod</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SSHCertificate:
    &#34;&#34;&#34;
    General class for SSH Certificates, used for loading and parsing.
    To create new certificates, use the respective keytype classes
    or the from_public_key classmethod
    &#34;&#34;&#34;

    def __init__(
        self,
        subject_pubkey: PublicKey = None,
        ca_privkey: PrivateKey = None,
        decoded: dict = None,
        **kwargs,
    ) -&gt; None:
        if self.__class__.__name__ == &#34;SSHCertificate&#34;:
            raise _EX.InvalidClassCallException(
                &#34;You cannot instantiate SSHCertificate directly. Use \n&#34;
                + &#34;one of the child classes, or call via decode, \n&#34;
                + &#34;or one of the from_-classmethods&#34;
            )

        if decoded is not None:
            self.signature = decoded.pop(&#34;signature&#34;)
            self.signature_pubkey = decoded.pop(&#34;ca_pubkey&#34;)

            self.header = {
                &#34;pubkey_type&#34;: decoded.pop(&#34;pubkey_type&#34;),
                &#34;nonce&#34;: decoded.pop(&#34;nonce&#34;),
                &#34;public_key&#34;: decoded.pop(&#34;public_key&#34;),
            }

            self.fields = decoded

            return

        if subject_pubkey is None:
            raise _EX.SSHCertificateException(&#34;The subject public key is required&#34;)

        self.header = {
            &#34;pubkey_type&#34;: _FIELD.PubkeyTypeField,
            &#34;nonce&#34;: _FIELD.NonceField(),
            &#34;public_key&#34;: _FIELD.PublicKeyField.from_object(subject_pubkey),
        }

        if ca_privkey is not None:
            self.signature = _FIELD.SignatureField.from_object(ca_privkey)
            self.signature_pubkey = _FIELD.CAPublicKeyField.from_object(
                ca_privkey.public_key
            )

        self.fields = dict(CERTIFICATE_FIELDS)
        self.set_opts(**kwargs)

    def __str__(self):
        principals = (
            &#34;\n&#34;
            + &#34;\n&#34;.join(
                &#34;&#34;.join([&#34; &#34;] * 32) + (x.decode(&#34;utf-8&#34;) if isinstance(x, bytes) else x)
                for x in self.fields[&#34;principals&#34;].value
            )
            if len(self.fields[&#34;principals&#34;].value) &gt; 0
            else &#34;none&#34;
        )

        critical = (
            &#34;\n&#34;
            + &#34;\n&#34;.join(
                &#34;&#34;.join([&#34; &#34;] * 32) + (x.decode(&#34;utf-8&#34;) if isinstance(x, bytes) else x)
                for x in self.fields[&#34;critical_options&#34;].value
            )
            if len(self.fields[&#34;critical_options&#34;].value) &gt; 0
            else &#34;none&#34;
        )

        extensions = (
            &#34;\n&#34;
            + &#34;\n&#34;.join(
                &#34;&#34;.join([&#34; &#34;] * 32) + (x.decode(&#34;utf-8&#34;) if isinstance(x, bytes) else x)
                for x in self.fields[&#34;extensions&#34;].value
            )
            if len(self.fields[&#34;extensions&#34;].value) &gt; 0
            else &#34;none&#34;
        )

        signature_val = (
            b64encode(self.signature.value).decode(&#34;utf-8&#34;)
            if isinstance(self.signature.value, bytes)
            else &#34;Not signed&#34;
        )

        return f&#34;&#34;&#34;
        Certificate:
            Pubkey Type:        {self.header[&#39;pubkey_type&#39;].value}
            Public Key:         {str(self.header[&#39;public_key&#39;])}
            CA Public Key:      {str(self.signature_pubkey)}
            Nonce:              {self.header[&#39;nonce&#39;].value}
            Certificate Type:   {&#39;User&#39; if self.fields[&#39;cert_type&#39;].value == 1 else &#39;Host&#39;}
            Valid After:        {self.fields[&#39;valid_after&#39;].value.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)}
            Valid Until:        {self.fields[&#39;valid_before&#39;].value.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)}
            Principals:         {principals}
            Critical options:   {critical}
            Extensions:         {extensions}
            Signature:          {signature_val}
        &#34;&#34;&#34;

    @staticmethod
    def decode(
        cert_bytes: bytes, pubkey_class: _FIELD.PublicKeyField = None
    ) -&gt; &#34;SSHCertificate&#34;:
        &#34;&#34;&#34;
        Decode an existing certificate and import it into a new object

        Args:
            cert_bytes (bytes): The certificate bytes, base64 decoded middle part of the certificate
            pubkey_field (_FIELD.PublicKeyField): Instance of the PublicKeyField class, only needs
                to be set if it can&#39;t be detected automatically

        Raises:
            _EX.InvalidCertificateFormatException: Invalid or unknown certificate format

        Returns:
            SSHCertificate: SSHCertificate child class
        &#34;&#34;&#34;
        if pubkey_class is None:
            cert_type = _FIELD.StringField.decode(cert_bytes)[0].encode(&#34;utf-8&#34;)
            pubkey_class = CERT_TYPES.get(cert_type, False)

        if pubkey_class is False:
            raise _EX.InvalidCertificateFormatException(
                &#34;Could not determine certificate type, please use one &#34;
                + &#34;of the specific classes or specify the pubkey_class&#34;
            )

        decode_fields = join_dicts(
            {
                &#34;pubkey_type&#34;: _FIELD.PubkeyTypeField,
                &#34;nonce&#34;: _FIELD.NonceField,
                &#34;public_key&#34;: pubkey_class,
            },
            CERTIFICATE_FIELDS,
            {
                &#34;reserved&#34;: _FIELD.ReservedField,
                &#34;ca_pubkey&#34;: _FIELD.CAPublicKeyField,
                &#34;signature&#34;: _FIELD.SignatureField,
            },
        )

        cert = {}

        for item in decode_fields.keys():
            cert[item], cert_bytes = decode_fields[item].from_decode(cert_bytes)

        if cert_bytes != b&#34;&#34;:
            raise _EX.InvalidCertificateFormatException(
                &#34;The certificate has additional data after everything has been extracted&#34;
            )

        pubkey_type = cert[&#34;pubkey_type&#34;].value
        if isinstance(pubkey_type, bytes):
            pubkey_type = pubkey_type.decode(&#34;utf-8&#34;)

        cert_type = CERT_TYPES[pubkey_type]
        cert.pop(&#34;reserved&#34;)
        return globals()[cert_type[0]](
            subject_pubkey=cert[&#34;public_key&#34;].value, decoded=cert
        )

    @classmethod
    def from_public_class(
        cls, public_key: PublicKey, ca_privkey: PrivateKey = None, **kwargs
    ) -&gt; &#34;SSHCertificate&#34;:
        &#34;&#34;&#34;
        Creates a new certificate from a supplied public key

        Args:
            public_key (PublicKey): The public key for which to create a certificate

        Returns:
            SSHCertificate: SSHCertificate child class
        &#34;&#34;&#34;
        return globals()[
            public_key.__class__.__name__.replace(&#34;PublicKey&#34;, &#34;Certificate&#34;)
        ](public_key, ca_privkey, **kwargs)

    @classmethod
    def from_bytes(cls, cert_bytes: bytes):
        &#34;&#34;&#34;
        Loads an existing certificate from the byte value.

        Args:
            cert_bytes (bytes): Certificate bytes, base64 decoded middle part of the certificate

        Returns:
            SSHCertificate: SSHCertificate child class
        &#34;&#34;&#34;
        cert_type, _ = _FIELD.StringField.decode(cert_bytes)
        target_class = CERT_TYPES[cert_type]
        return globals()[target_class[0]].decode(cert_bytes)

    @classmethod
    def from_string(cls, cert_str: Union[str, bytes], encoding: str = &#34;utf-8&#34;):
        &#34;&#34;&#34;
        Loads an existing certificate from a string in the format
        [certificate-type] [base64-encoded-certificate] [optional-comment]

        Args:
            cert_str (str): The string containing the certificate
            encoding (str, optional): The encoding of the string. Defaults to &#39;utf-8&#39;.

        Returns:
            SSHCertificate: SSHCertificate child class
        &#34;&#34;&#34;
        if isinstance(cert_str, str):
            cert_str = cert_str.encode(encoding)

        certificate = b64decode(cert_str.split(b&#34; &#34;)[1])
        return cls.from_bytes(cert_bytes=certificate)

    @classmethod
    def from_file(cls, path: str, encoding: str = &#34;utf-8&#34;):
        &#34;&#34;&#34;
        Loads an existing certificate from a file

        Args:
            path (str): The path to the certificate file
            encoding (str, optional): Encoding of the file. Defaults to &#39;utf-8&#39;.

        Returns:
            SSHCertificate: SSHCertificate child class
        &#34;&#34;&#34;
        return cls.from_string(open(path, &#34;r&#34;, encoding=encoding).read())

    def set_ca(self, ca_privkey: PrivateKey):
        &#34;&#34;&#34;
        Set the CA Private Key for signing the certificate

        Args:
            ca_privkey (PrivateKey): The CA private key
        &#34;&#34;&#34;
        self.signature = _FIELD.SignatureField.from_object(ca_privkey)
        self.signature_pubkey = _FIELD.CAPublicKeyField.from_object(
            ca_privkey.public_key
        )

    def set_type(self, pubkey_type: str):
        &#34;&#34;&#34;
        Set the type of the public key if not already set automatically
        The child classes will set this automatically

        Args:
            pubkey_type (str): Public key type, e.g. ssh-rsa-cert-v01@openssh.com
        &#34;&#34;&#34;
        if not getattr(self.header[&#34;pubkey_type&#34;], &#34;value&#34;, False):
            self.header[&#34;pubkey_type&#34;] = self.header[&#34;pubkey_type&#34;](pubkey_type)

    def set_opt(self, key: str, value):
        &#34;&#34;&#34;
        Add information to a field in the certificate

        Args:
            key (str): The key to set
            value (mixed): The new value for the field

        Raises:
            _EX.InvalidCertificateFieldException: Invalid field
        &#34;&#34;&#34;
        if key not in self.fields:
            raise _EX.InvalidCertificateFieldException(
                f&#34;{key} is not a valid certificate field&#34;
            )

        try:
            if self.fields[key].value not in [None, False, &#34;&#34;, [], ()]:
                self.fields[key].value = value
        except AttributeError:
            self.fields[key] = self.fields[key](value)

    def set_opts(self, **kwargs):
        &#34;&#34;&#34;
        Set multiple options at once
        &#34;&#34;&#34;
        for key, value in kwargs.items():
            self.set_opt(key, value)

    # pylint: disable=used-before-assignment
    def can_sign(self) -&gt; bool:
        &#34;&#34;&#34;
        Determine if the certificate is ready to be signed

        Raises:
            ...: Exception from the respective field with error
            _EX.NoPrivateKeyException: Private key is missing from class

        Returns:
            bool: True/False if the certificate can be signed
        &#34;&#34;&#34;
        exceptions = []
        for field in self.fields.values():
            try:
                valid = field.validate()
            except TypeError:
                valid = _EX.SignatureNotPossibleException(
                    f&#34;The field {field} is missing a value&#34;
                )
            finally:
                if isinstance(valid, Exception):
                    exceptions.append(valid)

        if (
            getattr(self, &#34;signature&#34;, False) is False
            or getattr(self, &#34;signature_pubkey&#34;, False) is False
        ):
            exceptions.append(
                _EX.SignatureNotPossibleException(&#34;No CA private key is set&#34;)
            )

        if len(exceptions) &gt; 0:
            raise _EX.SignatureNotPossibleException(exceptions)

        if self.signature.can_sign() is True:
            return True

        raise _EX.SignatureNotPossibleException(
            &#34;The certificate cannot be signed, the CA private key is not loaded&#34;
        )

    def get_signable_data(self) -&gt; bytes:
        &#34;&#34;&#34;
        Gets the signable byte string from the certificate fields

        Returns:
            bytes: The data in the certificate which is signed
        &#34;&#34;&#34;
        return (
            b&#34;&#34;.join(
                [
                    bytes(x)
                    for x in tuple(self.header.values()) + tuple(self.fields.values())
                ]
            )
            + bytes(_FIELD.ReservedField())
            + bytes(self.signature_pubkey)
        )

    def sign(self):
        &#34;&#34;&#34;
        Sign the certificate

        Returns:
            SSHCertificate: The signed certificate class
        &#34;&#34;&#34;
        if self.can_sign():
            self.signature.sign(data=self.get_signable_data())

        return self

    def verify(self, ca_pubkey: PublicKey = None) -&gt; bool:
        &#34;&#34;&#34;
        Verifies a signature against a given public key.

        If no public key is provided, the signature is checked against
        the public/private key provided to the class on creation
        or decoding.

        Not providing the public key for the CA with an imported
        certificate means the verification will succeed even if an
        attacker has replaced the signature and public key for signing.

        If the certificate wasn&#39;t created and signed on the same occasion
        as the validity check, you should always provide a public key for
        verificiation.

        Returns:
            bool: If the certificate signature is valid
        &#34;&#34;&#34;

        if ca_pubkey is None:
            ca_pubkey = self.signature_pubkey.value

        cert_data = self.get_signable_data()
        signature = self.signature.value

        return ca_pubkey.verify(
            cert_data,
            signature
        )

    def to_bytes(self) -&gt; bytes:
        &#34;&#34;&#34;
        Export the signed certificate in byte-format

        Raises:
            _EX.NotSignedException: The certificate has not been signed yet

        Returns:
            bytes: The certificate bytes
        &#34;&#34;&#34;
        if self.signature.is_signed is True:
            return self.get_signable_data() + bytes(self.signature)

        raise _EX.NotSignedException(&#34;The certificate has not been signed&#34;)

    def to_string(
        self, comment: Union[str, bytes] = None, encoding: str = &#34;utf-8&#34;
    ) -&gt; str:
        &#34;&#34;&#34;
        Export the signed certificate to a string, ready to be written to file

        Args:
            comment (Union[str, bytes], optional): Comment to add to the string. Defaults to None.
            encoding (str, optional): Encoding to use for the string. Defaults to &#39;utf-8&#39;.

        Returns:
            str: Certificate string
        &#34;&#34;&#34;
        return (
            self.header[&#34;pubkey_type&#34;].value.encode(encoding)
            + b&#34; &#34;
            + b64encode(
                self.to_bytes(),
            )
            + b&#34; &#34;
            + (comment if comment else b&#34;&#34;)
        ).decode(&#34;utf-8&#34;)

    def to_file(
        self, path: str, comment: Union[str, bytes] = None, encoding: str = &#34;utf-8&#34;
    ):
        &#34;&#34;&#34;
        Saves the certificate to a file

        Args:
            path (str): The path of the file to save to
            comment (Union[str, bytes], optional): Comment to add to the certificate end.
                                                   Defaults to None.
            encoding (str, optional): Encoding for the file. Defaults to &#39;utf-8&#39;.
        &#34;&#34;&#34;
        with open(path, &#34;w&#34;, encoding=encoding) as file:
            file.write(self.to_string(comment, encoding))</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sshkey_tools.cert.DSACertificate" href="#sshkey_tools.cert.DSACertificate">DSACertificate</a></li>
<li><a title="sshkey_tools.cert.ECDSACertificate" href="#sshkey_tools.cert.ECDSACertificate">ECDSACertificate</a></li>
<li><a title="sshkey_tools.cert.ED25519Certificate" href="#sshkey_tools.cert.ED25519Certificate">ED25519Certificate</a></li>
<li><a title="sshkey_tools.cert.RSACertificate" href="#sshkey_tools.cert.RSACertificate">RSACertificate</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.cert.SSHCertificate.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>cert_bytes:Â bytes, pubkey_class:Â <a title="sshkey_tools.fields.PublicKeyField" href="fields.html#sshkey_tools.fields.PublicKeyField">PublicKeyField</a>Â =Â None) â€‘>Â <a title="sshkey_tools.cert.SSHCertificate" href="#sshkey_tools.cert.SSHCertificate">SSHCertificate</a></span>
</code></dt>
<dd>
<div class="desc"><p>Decode an existing certificate and import it into a new object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cert_bytes</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The certificate bytes, base64 decoded middle part of the certificate</dd>
<dt><strong><code>pubkey_field</code></strong> :&ensp;<code>_FIELD.PublicKeyField</code></dt>
<dd>Instance of the PublicKeyField class, only needs
to be set if it can't be detected automatically</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>_EX.InvalidCertificateFormatException</code></dt>
<dd>Invalid or unknown certificate format</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sshkey_tools.cert.SSHCertificate" href="#sshkey_tools.cert.SSHCertificate">SSHCertificate</a></code></dt>
<dd>SSHCertificate child class</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(
    cert_bytes: bytes, pubkey_class: _FIELD.PublicKeyField = None
) -&gt; &#34;SSHCertificate&#34;:
    &#34;&#34;&#34;
    Decode an existing certificate and import it into a new object

    Args:
        cert_bytes (bytes): The certificate bytes, base64 decoded middle part of the certificate
        pubkey_field (_FIELD.PublicKeyField): Instance of the PublicKeyField class, only needs
            to be set if it can&#39;t be detected automatically

    Raises:
        _EX.InvalidCertificateFormatException: Invalid or unknown certificate format

    Returns:
        SSHCertificate: SSHCertificate child class
    &#34;&#34;&#34;
    if pubkey_class is None:
        cert_type = _FIELD.StringField.decode(cert_bytes)[0].encode(&#34;utf-8&#34;)
        pubkey_class = CERT_TYPES.get(cert_type, False)

    if pubkey_class is False:
        raise _EX.InvalidCertificateFormatException(
            &#34;Could not determine certificate type, please use one &#34;
            + &#34;of the specific classes or specify the pubkey_class&#34;
        )

    decode_fields = join_dicts(
        {
            &#34;pubkey_type&#34;: _FIELD.PubkeyTypeField,
            &#34;nonce&#34;: _FIELD.NonceField,
            &#34;public_key&#34;: pubkey_class,
        },
        CERTIFICATE_FIELDS,
        {
            &#34;reserved&#34;: _FIELD.ReservedField,
            &#34;ca_pubkey&#34;: _FIELD.CAPublicKeyField,
            &#34;signature&#34;: _FIELD.SignatureField,
        },
    )

    cert = {}

    for item in decode_fields.keys():
        cert[item], cert_bytes = decode_fields[item].from_decode(cert_bytes)

    if cert_bytes != b&#34;&#34;:
        raise _EX.InvalidCertificateFormatException(
            &#34;The certificate has additional data after everything has been extracted&#34;
        )

    pubkey_type = cert[&#34;pubkey_type&#34;].value
    if isinstance(pubkey_type, bytes):
        pubkey_type = pubkey_type.decode(&#34;utf-8&#34;)

    cert_type = CERT_TYPES[pubkey_type]
    cert.pop(&#34;reserved&#34;)
    return globals()[cert_type[0]](
        subject_pubkey=cert[&#34;public_key&#34;].value, decoded=cert
    )</code></pre>
</details>
</dd>
<dt id="sshkey_tools.cert.SSHCertificate.from_bytes"><code class="name flex">
<span>def <span class="ident">from_bytes</span></span>(<span>cert_bytes:Â bytes)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads an existing certificate from the byte value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cert_bytes</code></strong> :&ensp;<code>bytes</code></dt>
<dd>Certificate bytes, base64 decoded middle part of the certificate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sshkey_tools.cert.SSHCertificate" href="#sshkey_tools.cert.SSHCertificate">SSHCertificate</a></code></dt>
<dd>SSHCertificate child class</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_bytes(cls, cert_bytes: bytes):
    &#34;&#34;&#34;
    Loads an existing certificate from the byte value.

    Args:
        cert_bytes (bytes): Certificate bytes, base64 decoded middle part of the certificate

    Returns:
        SSHCertificate: SSHCertificate child class
    &#34;&#34;&#34;
    cert_type, _ = _FIELD.StringField.decode(cert_bytes)
    target_class = CERT_TYPES[cert_type]
    return globals()[target_class[0]].decode(cert_bytes)</code></pre>
</details>
</dd>
<dt id="sshkey_tools.cert.SSHCertificate.from_file"><code class="name flex">
<span>def <span class="ident">from_file</span></span>(<span>path:Â str, encoding:Â strÂ =Â 'utf-8')</span>
</code></dt>
<dd>
<div class="desc"><p>Loads an existing certificate from a file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the certificate file</dd>
<dt><strong><code>encoding</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Encoding of the file. Defaults to 'utf-8'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sshkey_tools.cert.SSHCertificate" href="#sshkey_tools.cert.SSHCertificate">SSHCertificate</a></code></dt>
<dd>SSHCertificate child class</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_file(cls, path: str, encoding: str = &#34;utf-8&#34;):
    &#34;&#34;&#34;
    Loads an existing certificate from a file

    Args:
        path (str): The path to the certificate file
        encoding (str, optional): Encoding of the file. Defaults to &#39;utf-8&#39;.

    Returns:
        SSHCertificate: SSHCertificate child class
    &#34;&#34;&#34;
    return cls.from_string(open(path, &#34;r&#34;, encoding=encoding).read())</code></pre>
</details>
</dd>
<dt id="sshkey_tools.cert.SSHCertificate.from_public_class"><code class="name flex">
<span>def <span class="ident">from_public_class</span></span>(<span>public_key:Â <a title="sshkey_tools.keys.PublicKey" href="keys.html#sshkey_tools.keys.PublicKey">PublicKey</a>, ca_privkey:Â <a title="sshkey_tools.keys.PrivateKey" href="keys.html#sshkey_tools.keys.PrivateKey">PrivateKey</a>Â =Â None, **kwargs) â€‘>Â <a title="sshkey_tools.cert.SSHCertificate" href="#sshkey_tools.cert.SSHCertificate">SSHCertificate</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new certificate from a supplied public key</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>public_key</code></strong> :&ensp;<code>PublicKey</code></dt>
<dd>The public key for which to create a certificate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sshkey_tools.cert.SSHCertificate" href="#sshkey_tools.cert.SSHCertificate">SSHCertificate</a></code></dt>
<dd>SSHCertificate child class</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_public_class(
    cls, public_key: PublicKey, ca_privkey: PrivateKey = None, **kwargs
) -&gt; &#34;SSHCertificate&#34;:
    &#34;&#34;&#34;
    Creates a new certificate from a supplied public key

    Args:
        public_key (PublicKey): The public key for which to create a certificate

    Returns:
        SSHCertificate: SSHCertificate child class
    &#34;&#34;&#34;
    return globals()[
        public_key.__class__.__name__.replace(&#34;PublicKey&#34;, &#34;Certificate&#34;)
    ](public_key, ca_privkey, **kwargs)</code></pre>
</details>
</dd>
<dt id="sshkey_tools.cert.SSHCertificate.from_string"><code class="name flex">
<span>def <span class="ident">from_string</span></span>(<span>cert_str:Â Union[str,Â bytes], encoding:Â strÂ =Â 'utf-8')</span>
</code></dt>
<dd>
<div class="desc"><p>Loads an existing certificate from a string in the format
[certificate-type] [base64-encoded-certificate] [optional-comment]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cert_str</code></strong> :&ensp;<code>str</code></dt>
<dd>The string containing the certificate</dd>
<dt><strong><code>encoding</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The encoding of the string. Defaults to 'utf-8'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sshkey_tools.cert.SSHCertificate" href="#sshkey_tools.cert.SSHCertificate">SSHCertificate</a></code></dt>
<dd>SSHCertificate child class</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_string(cls, cert_str: Union[str, bytes], encoding: str = &#34;utf-8&#34;):
    &#34;&#34;&#34;
    Loads an existing certificate from a string in the format
    [certificate-type] [base64-encoded-certificate] [optional-comment]

    Args:
        cert_str (str): The string containing the certificate
        encoding (str, optional): The encoding of the string. Defaults to &#39;utf-8&#39;.

    Returns:
        SSHCertificate: SSHCertificate child class
    &#34;&#34;&#34;
    if isinstance(cert_str, str):
        cert_str = cert_str.encode(encoding)

    certificate = b64decode(cert_str.split(b&#34; &#34;)[1])
    return cls.from_bytes(cert_bytes=certificate)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.cert.SSHCertificate.can_sign"><code class="name flex">
<span>def <span class="ident">can_sign</span></span>(<span>self) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Determine if the certificate is ready to be signed</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>&hellip;</code></dt>
<dd>Exception from the respective field with error</dd>
<dt><code>_EX.NoPrivateKeyException</code></dt>
<dd>Private key is missing from class</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True/False if the certificate can be signed</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def can_sign(self) -&gt; bool:
    &#34;&#34;&#34;
    Determine if the certificate is ready to be signed

    Raises:
        ...: Exception from the respective field with error
        _EX.NoPrivateKeyException: Private key is missing from class

    Returns:
        bool: True/False if the certificate can be signed
    &#34;&#34;&#34;
    exceptions = []
    for field in self.fields.values():
        try:
            valid = field.validate()
        except TypeError:
            valid = _EX.SignatureNotPossibleException(
                f&#34;The field {field} is missing a value&#34;
            )
        finally:
            if isinstance(valid, Exception):
                exceptions.append(valid)

    if (
        getattr(self, &#34;signature&#34;, False) is False
        or getattr(self, &#34;signature_pubkey&#34;, False) is False
    ):
        exceptions.append(
            _EX.SignatureNotPossibleException(&#34;No CA private key is set&#34;)
        )

    if len(exceptions) &gt; 0:
        raise _EX.SignatureNotPossibleException(exceptions)

    if self.signature.can_sign() is True:
        return True

    raise _EX.SignatureNotPossibleException(
        &#34;The certificate cannot be signed, the CA private key is not loaded&#34;
    )</code></pre>
</details>
</dd>
<dt id="sshkey_tools.cert.SSHCertificate.get_signable_data"><code class="name flex">
<span>def <span class="ident">get_signable_data</span></span>(<span>self) â€‘>Â bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the signable byte string from the certificate fields</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>The data in the certificate which is signed</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_signable_data(self) -&gt; bytes:
    &#34;&#34;&#34;
    Gets the signable byte string from the certificate fields

    Returns:
        bytes: The data in the certificate which is signed
    &#34;&#34;&#34;
    return (
        b&#34;&#34;.join(
            [
                bytes(x)
                for x in tuple(self.header.values()) + tuple(self.fields.values())
            ]
        )
        + bytes(_FIELD.ReservedField())
        + bytes(self.signature_pubkey)
    )</code></pre>
</details>
</dd>
<dt id="sshkey_tools.cert.SSHCertificate.set_ca"><code class="name flex">
<span>def <span class="ident">set_ca</span></span>(<span>self, ca_privkey:Â <a title="sshkey_tools.keys.PrivateKey" href="keys.html#sshkey_tools.keys.PrivateKey">PrivateKey</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the CA Private Key for signing the certificate</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ca_privkey</code></strong> :&ensp;<code>PrivateKey</code></dt>
<dd>The CA private key</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_ca(self, ca_privkey: PrivateKey):
    &#34;&#34;&#34;
    Set the CA Private Key for signing the certificate

    Args:
        ca_privkey (PrivateKey): The CA private key
    &#34;&#34;&#34;
    self.signature = _FIELD.SignatureField.from_object(ca_privkey)
    self.signature_pubkey = _FIELD.CAPublicKeyField.from_object(
        ca_privkey.public_key
    )</code></pre>
</details>
</dd>
<dt id="sshkey_tools.cert.SSHCertificate.set_opt"><code class="name flex">
<span>def <span class="ident">set_opt</span></span>(<span>self, key:Â str, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Add information to a field in the certificate</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>The key to set</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>mixed</code></dt>
<dd>The new value for the field</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>_EX.InvalidCertificateFieldException</code></dt>
<dd>Invalid field</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_opt(self, key: str, value):
    &#34;&#34;&#34;
    Add information to a field in the certificate

    Args:
        key (str): The key to set
        value (mixed): The new value for the field

    Raises:
        _EX.InvalidCertificateFieldException: Invalid field
    &#34;&#34;&#34;
    if key not in self.fields:
        raise _EX.InvalidCertificateFieldException(
            f&#34;{key} is not a valid certificate field&#34;
        )

    try:
        if self.fields[key].value not in [None, False, &#34;&#34;, [], ()]:
            self.fields[key].value = value
    except AttributeError:
        self.fields[key] = self.fields[key](value)</code></pre>
</details>
</dd>
<dt id="sshkey_tools.cert.SSHCertificate.set_opts"><code class="name flex">
<span>def <span class="ident">set_opts</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Set multiple options at once</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_opts(self, **kwargs):
    &#34;&#34;&#34;
    Set multiple options at once
    &#34;&#34;&#34;
    for key, value in kwargs.items():
        self.set_opt(key, value)</code></pre>
</details>
</dd>
<dt id="sshkey_tools.cert.SSHCertificate.set_type"><code class="name flex">
<span>def <span class="ident">set_type</span></span>(<span>self, pubkey_type:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the type of the public key if not already set automatically
The child classes will set this automatically</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pubkey_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Public key type, e.g. ssh-rsa-cert-v01@openssh.com</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_type(self, pubkey_type: str):
    &#34;&#34;&#34;
    Set the type of the public key if not already set automatically
    The child classes will set this automatically

    Args:
        pubkey_type (str): Public key type, e.g. ssh-rsa-cert-v01@openssh.com
    &#34;&#34;&#34;
    if not getattr(self.header[&#34;pubkey_type&#34;], &#34;value&#34;, False):
        self.header[&#34;pubkey_type&#34;] = self.header[&#34;pubkey_type&#34;](pubkey_type)</code></pre>
</details>
</dd>
<dt id="sshkey_tools.cert.SSHCertificate.sign"><code class="name flex">
<span>def <span class="ident">sign</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sign the certificate</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sshkey_tools.cert.SSHCertificate" href="#sshkey_tools.cert.SSHCertificate">SSHCertificate</a></code></dt>
<dd>The signed certificate class</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sign(self):
    &#34;&#34;&#34;
    Sign the certificate

    Returns:
        SSHCertificate: The signed certificate class
    &#34;&#34;&#34;
    if self.can_sign():
        self.signature.sign(data=self.get_signable_data())

    return self</code></pre>
</details>
</dd>
<dt id="sshkey_tools.cert.SSHCertificate.to_bytes"><code class="name flex">
<span>def <span class="ident">to_bytes</span></span>(<span>self) â€‘>Â bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Export the signed certificate in byte-format</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>_EX.NotSignedException</code></dt>
<dd>The certificate has not been signed yet</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>The certificate bytes</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_bytes(self) -&gt; bytes:
    &#34;&#34;&#34;
    Export the signed certificate in byte-format

    Raises:
        _EX.NotSignedException: The certificate has not been signed yet

    Returns:
        bytes: The certificate bytes
    &#34;&#34;&#34;
    if self.signature.is_signed is True:
        return self.get_signable_data() + bytes(self.signature)

    raise _EX.NotSignedException(&#34;The certificate has not been signed&#34;)</code></pre>
</details>
</dd>
<dt id="sshkey_tools.cert.SSHCertificate.to_file"><code class="name flex">
<span>def <span class="ident">to_file</span></span>(<span>self, path:Â str, comment:Â Union[str,Â bytes]Â =Â None, encoding:Â strÂ =Â 'utf-8')</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the certificate to a file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path of the file to save to</dd>
<dt><strong><code>comment</code></strong> :&ensp;<code>Union[str, bytes]</code>, optional</dt>
<dd>Comment to add to the certificate end.
Defaults to None.</dd>
<dt><strong><code>encoding</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Encoding for the file. Defaults to 'utf-8'.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_file(
    self, path: str, comment: Union[str, bytes] = None, encoding: str = &#34;utf-8&#34;
):
    &#34;&#34;&#34;
    Saves the certificate to a file

    Args:
        path (str): The path of the file to save to
        comment (Union[str, bytes], optional): Comment to add to the certificate end.
                                               Defaults to None.
        encoding (str, optional): Encoding for the file. Defaults to &#39;utf-8&#39;.
    &#34;&#34;&#34;
    with open(path, &#34;w&#34;, encoding=encoding) as file:
        file.write(self.to_string(comment, encoding))</code></pre>
</details>
</dd>
<dt id="sshkey_tools.cert.SSHCertificate.to_string"><code class="name flex">
<span>def <span class="ident">to_string</span></span>(<span>self, comment:Â Union[str,Â bytes]Â =Â None, encoding:Â strÂ =Â 'utf-8') â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Export the signed certificate to a string, ready to be written to file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>comment</code></strong> :&ensp;<code>Union[str, bytes]</code>, optional</dt>
<dd>Comment to add to the string. Defaults to None.</dd>
<dt><strong><code>encoding</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Encoding to use for the string. Defaults to 'utf-8'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Certificate string</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_string(
    self, comment: Union[str, bytes] = None, encoding: str = &#34;utf-8&#34;
) -&gt; str:
    &#34;&#34;&#34;
    Export the signed certificate to a string, ready to be written to file

    Args:
        comment (Union[str, bytes], optional): Comment to add to the string. Defaults to None.
        encoding (str, optional): Encoding to use for the string. Defaults to &#39;utf-8&#39;.

    Returns:
        str: Certificate string
    &#34;&#34;&#34;
    return (
        self.header[&#34;pubkey_type&#34;].value.encode(encoding)
        + b&#34; &#34;
        + b64encode(
            self.to_bytes(),
        )
        + b&#34; &#34;
        + (comment if comment else b&#34;&#34;)
    ).decode(&#34;utf-8&#34;)</code></pre>
</details>
</dd>
<dt id="sshkey_tools.cert.SSHCertificate.verify"><code class="name flex">
<span>def <span class="ident">verify</span></span>(<span>self, ca_pubkey:Â <a title="sshkey_tools.keys.PublicKey" href="keys.html#sshkey_tools.keys.PublicKey">PublicKey</a>Â =Â None) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Verifies a signature against a given public key.</p>
<p>If no public key is provided, the signature is checked against
the public/private key provided to the class on creation
or decoding.</p>
<p>Not providing the public key for the CA with an imported
certificate means the verification will succeed even if an
attacker has replaced the signature and public key for signing.</p>
<p>If the certificate wasn't created and signed on the same occasion
as the validity check, you should always provide a public key for
verificiation.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>If the certificate signature is valid</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verify(self, ca_pubkey: PublicKey = None) -&gt; bool:
    &#34;&#34;&#34;
    Verifies a signature against a given public key.

    If no public key is provided, the signature is checked against
    the public/private key provided to the class on creation
    or decoding.

    Not providing the public key for the CA with an imported
    certificate means the verification will succeed even if an
    attacker has replaced the signature and public key for signing.

    If the certificate wasn&#39;t created and signed on the same occasion
    as the validity check, you should always provide a public key for
    verificiation.

    Returns:
        bool: If the certificate signature is valid
    &#34;&#34;&#34;

    if ca_pubkey is None:
        ca_pubkey = self.signature_pubkey.value

    cert_data = self.get_signable_data()
    signature = self.signature.value

    return ca_pubkey.verify(
        cert_data,
        signature
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sshkey_tools" href="index.html">sshkey_tools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sshkey_tools.cert.DSACertificate" href="#sshkey_tools.cert.DSACertificate">DSACertificate</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.cert.DSACertificate.decode" href="#sshkey_tools.cert.DSACertificate.decode">decode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.cert.ECDSACertificate" href="#sshkey_tools.cert.ECDSACertificate">ECDSACertificate</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.cert.ECDSACertificate.decode" href="#sshkey_tools.cert.ECDSACertificate.decode">decode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.cert.ED25519Certificate" href="#sshkey_tools.cert.ED25519Certificate">ED25519Certificate</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.cert.ED25519Certificate.decode" href="#sshkey_tools.cert.ED25519Certificate.decode">decode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.cert.RSACertificate" href="#sshkey_tools.cert.RSACertificate">RSACertificate</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.cert.RSACertificate.decode" href="#sshkey_tools.cert.RSACertificate.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.cert.RSACertificate.sign" href="#sshkey_tools.cert.RSACertificate.sign">sign</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.cert.SSHCertificate" href="#sshkey_tools.cert.SSHCertificate">SSHCertificate</a></code></h4>
<ul class="two-column">
<li><code><a title="sshkey_tools.cert.SSHCertificate.can_sign" href="#sshkey_tools.cert.SSHCertificate.can_sign">can_sign</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.decode" href="#sshkey_tools.cert.SSHCertificate.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.from_bytes" href="#sshkey_tools.cert.SSHCertificate.from_bytes">from_bytes</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.from_file" href="#sshkey_tools.cert.SSHCertificate.from_file">from_file</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.from_public_class" href="#sshkey_tools.cert.SSHCertificate.from_public_class">from_public_class</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.from_string" href="#sshkey_tools.cert.SSHCertificate.from_string">from_string</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.get_signable_data" href="#sshkey_tools.cert.SSHCertificate.get_signable_data">get_signable_data</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.set_ca" href="#sshkey_tools.cert.SSHCertificate.set_ca">set_ca</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.set_opt" href="#sshkey_tools.cert.SSHCertificate.set_opt">set_opt</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.set_opts" href="#sshkey_tools.cert.SSHCertificate.set_opts">set_opts</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.set_type" href="#sshkey_tools.cert.SSHCertificate.set_type">set_type</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.sign" href="#sshkey_tools.cert.SSHCertificate.sign">sign</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.to_bytes" href="#sshkey_tools.cert.SSHCertificate.to_bytes">to_bytes</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.to_file" href="#sshkey_tools.cert.SSHCertificate.to_file">to_file</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.to_string" href="#sshkey_tools.cert.SSHCertificate.to_string">to_string</a></code></li>
<li><code><a title="sshkey_tools.cert.SSHCertificate.verify" href="#sshkey_tools.cert.SSHCertificate.verify">verify</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>