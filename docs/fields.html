<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sshkey_tools.fields API documentation</title>
<meta name="description" content="Field types for SSH Certificates" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sshkey_tools.fields</code></h1>
</header>
<section id="section-intro">
<p>Field types for SSH Certificates</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Field types for SSH Certificates
&#34;&#34;&#34;
# pylint: disable=invalid-name,too-many-lines,arguments-differ
import re
from base64 import b64encode
from datetime import datetime, timedelta
from enum import Enum
from struct import pack, unpack
from typing import Tuple, Union

from cryptography.hazmat.primitives.asymmetric.utils import (
    decode_dss_signature,
    encode_dss_signature,
)

from . import exceptions as _EX
from .keys import (
    DsaPrivateKey,
    DsaPublicKey,
    EcdsaPrivateKey,
    EcdsaPublicKey,
    Ed25519PrivateKey,
    Ed25519PublicKey,
    PrivateKey,
    PublicKey,
    RsaAlgs,
    RsaPrivateKey,
    RsaPublicKey,
)
from .utils import (
    bytes_to_long,
    concat_to_string,
    ensure_bytestring,
    ensure_string,
    generate_secure_nonce,
    long_to_bytes,
    random_keyid,
    random_serial,
    str_to_timedelta,
)

NoneType = type(None)
MAX_INT32 = 2**32
MAX_INT64 = 2**64
NEWLINE = &#34;\n&#34;

ECDSA_CURVE_MAP = {
    &#34;secp256r1&#34;: &#34;nistp256&#34;,
    &#34;secp384r1&#34;: &#34;nistp384&#34;,
    &#34;secp521r1&#34;: &#34;nistp521&#34;,
}

SUBJECT_PUBKEY_MAP = {
    RsaPublicKey: &#34;RsaPubkeyField&#34;,
    DsaPublicKey: &#34;DsaPubkeyField&#34;,
    EcdsaPublicKey: &#34;EcdsaPubkeyField&#34;,
    Ed25519PublicKey: &#34;Ed25519PubkeyField&#34;,
}

CA_SIGNATURE_MAP = {
    RsaPrivateKey: &#34;RsaSignatureField&#34;,
    DsaPrivateKey: &#34;DsaSignatureField&#34;,
    EcdsaPrivateKey: &#34;EcdsaSignatureField&#34;,
    Ed25519PrivateKey: &#34;Ed25519SignatureField&#34;,
}

SIGNATURE_TYPE_MAP = {
    b&#34;rsa&#34;: &#34;RsaSignatureField&#34;,
    b&#34;dss&#34;: &#34;DsaSignatureField&#34;,
    b&#34;ecdsa&#34;: &#34;EcdsaSignatureField&#34;,
    b&#34;ed25519&#34;: &#34;Ed25519SignatureField&#34;,
}


class CERT_TYPE(Enum):
    &#34;&#34;&#34;
    Certificate types, User certificate/Host certificate
    &#34;&#34;&#34;

    USER = 1
    HOST = 2


class CertificateField:
    &#34;&#34;&#34;
    The base class for certificate fields
    &#34;&#34;&#34;

    IS_SET = None
    DEFAULT = None
    REQUIRED = False
    DATA_TYPE = NoneType

    def __init__(self, value=None):
        self.value = value
        self.exception = None
        self.IS_SET = True
        self.name = self.get_name()

    def __table__(self):
        return (str(self.name), str(self.value))

    def __str__(self):
        return f&#34;{self.name}: {self.value}&#34;

    def __bytes__(self) -&gt; bytes:
        return self.encode(self.value)

    @classmethod
    def get_name(cls) -&gt; str:
        &#34;&#34;&#34;
        Fetch the name of the field (identifier format)

        Returns:
            str: The name/id of the field
        &#34;&#34;&#34;
        return &#34;_&#34;.join(re.findall(&#34;[A-Z][^A-Z]*&#34;, cls.__name__)[:-1]).lower()

    @classmethod
    def __validate_type__(cls, value, do_raise: bool = False) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validate the data type of the value against the class data type
        &#34;&#34;&#34;
        if not isinstance(value, cls.DATA_TYPE):
            ex = _EX.InvalidDataException(
                f&#34;Invalid data type for {cls.get_name()}&#34;
                + f&#34;(expected {cls.DATA_TYPE}, got {type(value)})&#34;
            )

            if do_raise:
                raise ex

            return ex

        return True

    def __validate_required__(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates if the field is set when required
        &#34;&#34;&#34;
        if self.DEFAULT == self.value is None:
            return _EX.InvalidFieldDataException(
                f&#34;{self.get_name()} is a required field&#34;
            )
        return True

    def __validate_value__(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the contents of the field
        Meant to be overridden by child classes
        &#34;&#34;&#34;
        return True

    # pylint: disable=not-callable
    def validate(self) -&gt; bool:
        &#34;&#34;&#34;
        Validates all field contents and types
        &#34;&#34;&#34;
        if isinstance(self.value, NoneType) and self.DEFAULT is not None:
            self.value = self.DEFAULT() if callable(self.DEFAULT) else self.DEFAULT

        self.exception = (
            self.__validate_type__(self.value),
            self.__validate_required__(),
            self.__validate_value__(),
        )

        return self.exception == (True, True, True)

    @staticmethod
    def decode(data: bytes) -&gt; tuple:
        &#34;&#34;&#34;
        Returns the decoded value of the field
        &#34;&#34;&#34;

    @classmethod
    def encode(cls, value) -&gt; bytes:
        &#34;&#34;&#34;
        Returns the encoded value of the field
        &#34;&#34;&#34;

    @classmethod
    def from_decode(cls, data: bytes) -&gt; Tuple[&#34;CertificateField&#34;, bytes]:
        &#34;&#34;&#34;
        Creates a field class based on encoded bytes

        Returns:
            tuple: CertificateField, remaining bytes
        &#34;&#34;&#34;
        value, data = cls.decode(data)
        return cls(value), data

    @classmethod
    # pylint: disable=not-callable
    def factory(cls, blank: bool = False) -&gt; &#34;CertificateField&#34;:
        &#34;&#34;&#34;
        Factory to create field with default value if set, otherwise empty

        Args:
            blank (bool): Return a blank class (for decoding)

        Returns:
            CertificateField: A new CertificateField subclass instance
        &#34;&#34;&#34;
        if cls.DEFAULT is None or blank:
            return cls

        if callable(cls.DEFAULT):
            return cls(cls.DEFAULT())

        return cls(cls.DEFAULT)


class BooleanField(CertificateField):
    &#34;&#34;&#34;
    Field representing a boolean value (True/False) or (1/0)
    &#34;&#34;&#34;

    DATA_TYPE = (bool, int)

    @classmethod
    def encode(cls, value: Union[int, bool]) -&gt; bytes:
        &#34;&#34;&#34;
        Encodes a boolean value to a byte string

        Args:
            value (bool): Boolean to encode

        Returns:
            bytes: Packed byte representing the boolean
        &#34;&#34;&#34;
        cls.__validate_type__(value, True)
        return pack(&#34;B&#34;, 1 if value else 0)

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[bool, bytes]:
        &#34;&#34;&#34;
        Decodes a boolean from a bytestring

        Args:
            data (bytes): The byte string starting with an encoded boolean
        &#34;&#34;&#34;
        return bool(unpack(&#34;B&#34;, data[:1])[0]), data[1:]

    def __validate_value__(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the contents of the field
        &#34;&#34;&#34;
        return (
            True
            if self.value in (True, False, 1, 0)
            else _EX.InvalidFieldDataException(
                f&#34;{self.get_name()} must be a boolean (True/1 or False/0)&#34;
            )
        )


class BytestringField(CertificateField):
    &#34;&#34;&#34;
    Field representing a bytestring value
    &#34;&#34;&#34;

    DATA_TYPE = (bytes, str)
    DEFAULT = b&#34;&#34;

    @classmethod
    def encode(cls, value: bytes) -&gt; bytes:
        &#34;&#34;&#34;
        Encodes a string or bytestring into a packed byte string

        Args:
            value (Union[str, bytes]): The string/bytestring to encode
            encoding (str): The encoding to user for the string

        Returns:
            bytes: Packed byte string containing the source data
        &#34;&#34;&#34;
        cls.__validate_type__(value, True)
        return pack(&#34;&gt;I&#34;, len(value)) + ensure_bytestring(value)

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[bytes, bytes]:
        &#34;&#34;&#34;
        Unpacks the next string from a packed byte string

        Args:
            data (bytes): The packed byte string to unpack

        Returns:
            tuple(bytes, bytes):  The next block of bytes from the packed byte
                                  string and remainder of the data
        &#34;&#34;&#34;
        length = unpack(&#34;&gt;I&#34;, data[:4])[0] + 4
        return ensure_bytestring(data[4:length]), data[length:]


class StringField(BytestringField):
    &#34;&#34;&#34;
    Field representing a string value
    &#34;&#34;&#34;

    DATA_TYPE = (str, bytes)
    DEFAULT = &#34;&#34;

    @classmethod
    def encode(cls, value: str, encoding: str = &#34;utf-8&#34;):
        &#34;&#34;&#34;
        Encodes a string or bytestring into a packed byte string

        Args:
            value (Union[str, bytes]): The string/bytestring to encode
            encoding (str): The encoding to user for the string

        Returns:
            bytes: Packed byte string containing the source data
        &#34;&#34;&#34;
        cls.__validate_type__(value, True)
        return BytestringField.encode(ensure_bytestring(value, encoding))

    @staticmethod
    def decode(data: bytes, encoding: str = &#34;utf-8&#34;) -&gt; Tuple[str, bytes]:
        &#34;&#34;&#34;
        Unpacks the next string from a packed byte string

        Args:
            data (bytes): The packed byte string to unpack

        Returns:
            tuple(bytes, bytes):  The next block of bytes from the packed byte
                                  string and remainder of the data
        &#34;&#34;&#34;
        value, data = BytestringField.decode(data)

        return value.decode(encoding), data


class Integer32Field(CertificateField):
    &#34;&#34;&#34;
    Certificate field representing a 32-bit integer
    &#34;&#34;&#34;

    DATA_TYPE = int
    DEFAULT = 0

    @classmethod
    def encode(cls, value: int) -&gt; bytes:
        &#34;&#34;&#34;Encodes a 32-bit integer value to a packed byte string

        Args:
            source_int (int): Integer to be packed

        Returns:
            bytes: Packed byte string containing integer
        &#34;&#34;&#34;
        cls.__validate_type__(value, True)
        return pack(&#34;&gt;I&#34;, value)

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[int, bytes]:
        &#34;&#34;&#34;Decodes a 32-bit integer from a block of bytes

        Args:
            data (bytes): Block of bytes containing an integer

        Returns:
            tuple: Tuple with integer and remainder of data
        &#34;&#34;&#34;
        return int(unpack(&#34;&gt;I&#34;, data[:4])[0]), data[4:]

    def __validate_value__(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the contents of the field
        &#34;&#34;&#34;
        if isinstance(self.__validate_type__(self.value), Exception):
            return _EX.InvalidFieldDataException(
                f&#34;{self.get_name()} Could not validate value, invalid type&#34;
            )

        if self.value &lt; MAX_INT32:
            return True

        return _EX.InvalidFieldDataException(
            f&#34;{self.get_name()} must be a 32-bit integer&#34;
        )


class Integer64Field(CertificateField):
    &#34;&#34;&#34;
    Certificate field representing a 64-bit integer
    &#34;&#34;&#34;

    DATA_TYPE = int
    DEFAULT = 0

    @classmethod
    def encode(cls, value: int) -&gt; bytes:
        &#34;&#34;&#34;Encodes a 64-bit integer value to a packed byte string

        Args:
            source_int (int): Integer to be packed

        Returns:
            bytes: Packed byte string containing integer
        &#34;&#34;&#34;
        cls.__validate_type__(value, True)
        return pack(&#34;&gt;Q&#34;, value)

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[int, bytes]:
        &#34;&#34;&#34;Decodes a 64-bit integer from a block of bytes

        Args:
            data (bytes): Block of bytes containing an integer

        Returns:
            tuple: Tuple with integer and remainder of data
        &#34;&#34;&#34;
        return int(unpack(&#34;&gt;Q&#34;, data[:8])[0]), data[8:]

    def __validate_value__(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the contents of the field
        &#34;&#34;&#34;
        if isinstance(self.__validate_type__(self.value), Exception):
            return _EX.InvalidFieldDataException(
                f&#34;{self.get_name()} Could not validate value, invalid type&#34;
            )

        if self.value &lt; MAX_INT64:
            return True

        return _EX.InvalidFieldDataException(
            f&#34;{self.get_name()} must be a 64-bit integer&#34;
        )


class DateTimeField(Integer64Field):
    &#34;&#34;&#34;
    Certificate field representing a datetime value.
    The value is saved as a 64-bit integer (unix timestamp)
    &#34;&#34;&#34;

    DATA_TYPE = (datetime, int, str)
    DEFAULT = datetime.now

    @classmethod
    def encode(cls, value: Union[datetime, int, str]) -&gt; bytes:
        &#34;&#34;&#34;Encodes a datetime object, integer or time string to a byte string
           Time strings are parsed with pytimeparse2, for example:
            32m
            2h32m
            3d2h32m
            1w3d2h32m
            1w 3d 2h 32m
            1 w 3 d 2 h 32 m
            4:13
            4:13:02
            4:13:02.266
            forever (Returns as MAX_INT64)

        Args:
            value (datetime, int, str): Datetime object

        Returns:
            bytes: Packed byte string containing datetime timestamp
        &#34;&#34;&#34;
        cls.__validate_type__(value, True)

        if isinstance(value, str):
            if value == &#34;forever&#34;:
                return Integer64Field.encode(MAX_INT64)

            value = int(datetime.now() + str_to_timedelta(value))

        if isinstance(value, datetime):
            value = int(value.timestamp())

        return Integer64Field.encode(value)

    @staticmethod
    def decode(data: bytes) -&gt; datetime:
        &#34;&#34;&#34;Decodes a datetime object from a block of bytes

        Args:
            data (bytes): Block of bytes containing a datetime object

        Returns:
            tuple: Tuple with datetime and remainder of data
        &#34;&#34;&#34;
        timestamp, data = Integer64Field.decode(data)
        return datetime.fromtimestamp(timestamp), data

    def __validate_value__(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the contents of the field
        &#34;&#34;&#34;
        if isinstance(self.__validate_type__(self.value), Exception):
            return _EX.InvalidFieldDataException(
                f&#34;{self.get_name()} Could not validate value, invalid type&#34;
            )

        check = self.value if isinstance(self.value, int) else self.value.timestamp()

        if check &lt; MAX_INT64:
            return True

        return _EX.InvalidFieldDataException(
            f&#34;{self.get_name()} must be a 64-bit integer or datetime object&#34;
        )


class MpIntegerField(BytestringField):
    &#34;&#34;&#34;
    Certificate field representing a multiple precision integer,
    an integer too large to fit in 64 bits.
    &#34;&#34;&#34;

    DATA_TYPE = int
    DEFAULT = 0

    @classmethod
    def encode(cls, value: int) -&gt; bytes:
        &#34;&#34;&#34;
        Encodes a multiprecision integer (integer larger than 64bit)
        into a packed byte string

        Args:
            value (int): Large integer

        Returns:
            bytes: Packed byte string containing integer
        &#34;&#34;&#34;
        cls.__validate_type__(value, True)
        return BytestringField.encode(long_to_bytes(value))

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[int, bytes]:
        &#34;&#34;&#34;Decodes a multiprecision integer (integer larger than 64bit)

        Args:
            data (bytes): Block of bytes containing a long (mp) integer

        Returns:
            tuple: Tuple with integer and remainder of data
        &#34;&#34;&#34;
        mpint, data = BytestringField.decode(data)
        return bytes_to_long(mpint), data


class ListField(CertificateField):
    &#34;&#34;&#34;
    Certificate field representing a list or tuple of strings
    &#34;&#34;&#34;

    DATA_TYPE = (list, set, tuple)
    DEFAULT = []

    @classmethod
    def encode(cls, value: Union[list, tuple, set]) -&gt; bytes:
        &#34;&#34;&#34;Encodes a list or tuple to a byte string

        Args:
            source_list (list): list of strings
            null_separator (bool, optional): Insert blank string string between items. Default None

        Returns:
            bytes: Packed byte string containing the source data
        &#34;&#34;&#34;
        cls.__validate_type__(value, True)

        try:
            if sum(not isinstance(item, (str, bytes)) for item in value) &gt; 0:
                raise TypeError
        except TypeError:
            raise _EX.InvalidFieldDataException(
                &#34;Expected list or tuple containing strings or bytes&#34;
            ) from TypeError

        return BytestringField.encode(b&#34;&#34;.join([StringField.encode(x) for x in value]))

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[list, bytes]:
        &#34;&#34;&#34;Decodes a list of strings from a block of bytes

        Args:
            data (bytes): The block of bytes containing a list of strings
        Returns:
            tuple: _description_
        &#34;&#34;&#34;
        list_bytes, data = BytestringField.decode(data)

        decoded = []
        while len(list_bytes) &gt; 0:
            elem, list_bytes = StringField.decode(list_bytes)
            decoded.append(elem)

        return ensure_string(decoded), data

    def __validate_value__(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the contents of the field
        &#34;&#34;&#34;
        if isinstance(self.__validate_type__(self.value), Exception):
            return _EX.InvalidFieldDataException(
                f&#34;{self.get_name()} Could not validate value, invalid type&#34;
            )

        if hasattr(self.value, &#34;__iter__&#34;) and not all(
            (isinstance(val, (str, bytes)) for val in self.value)
        ):
            return _EX.InvalidFieldDataException(
                &#34;Expected list or tuple containing strings or bytes&#34;
            )
        return True


class KeyValueField(CertificateField):
    &#34;&#34;&#34;
    Certificate field representing a list or integer in python,
    separated in byte-form by null-bytes.
    &#34;&#34;&#34;

    DATA_TYPE = (list, tuple, set, dict)
    DEFAULT = {}

    @classmethod
    def encode(cls, value: Union[list, tuple, dict, set]) -&gt; bytes:
        &#34;&#34;&#34;
        Encodes a dict, set, list or tuple into a key-value byte string.
        If a set, list or tuple is provided, the items are considered keys
        and added with empty values.

        Args:
            source_list (dict, set, list, tuple): list of strings

        Returns:
            bytes: Packed byte string containing the source data
        &#34;&#34;&#34;
        cls.__validate_type__(value, True)

        if not isinstance(value, dict):
            value = {item: &#34;&#34; for item in value}

        list_data = b&#34;&#34;

        for key, item in value.items():
            list_data += StringField.encode(key)

            item = (
                StringField.encode(&#34;&#34;)
                if item in [&#34;&#34;, b&#34;&#34;]
                else ListField.encode(
                    [item] if isinstance(item, (str, bytes)) else item
                )
            )

            list_data += item

        return BytestringField.encode(list_data)

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[dict, bytes]:
        &#34;&#34;&#34;Decodes a list of strings from a block of bytes

        Args:
            data (bytes): The block of bytes containing a list of strings
        Returns:
            tuple: _description_
        &#34;&#34;&#34;
        list_bytes, data = BytestringField.decode(data)

        decoded = {}
        while len(list_bytes) &gt; 0:
            key, list_bytes = StringField.decode(list_bytes)
            value, list_bytes = BytestringField.decode(list_bytes)

            if value != b&#34;&#34;:
                value = StringField.decode(value)[0]

            decoded[key] = value

        decoded = ensure_string(decoded)

        if &#34;&#34;.join(decoded.values()) == &#34;&#34;:
            return list(decoded.keys()), data

        return decoded, data

    def __validate_value__(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the contents of the field
        &#34;&#34;&#34;
        if isinstance(self.__validate_type__(self.value), Exception):
            return _EX.InvalidFieldDataException(
                f&#34;{self.get_name()} Could not validate value, invalid type&#34;
            )

        testvals = (
            self.value
            if not isinstance(self.value, dict)
            else list(self.value.keys()) + list(self.value.values())
        )

        if hasattr(self.value, &#34;__iter__&#34;) and not all(
            (isinstance(val, (str, bytes)) for val in testvals)
        ):
            return _EX.InvalidFieldDataException(
                &#34;Expected dict, list, tuple, set with string or byte keys and values&#34;
            )

        return True


class PubkeyTypeField(StringField):
    &#34;&#34;&#34;
    Contains the certificate type, which is based on the
    public key type the certificate is created for, e.g.
    &#39;ssh-ed25519-cert-v01@openssh.com&#39; for an ED25519 key
    &#34;&#34;&#34;

    DEFAULT = None
    DATA_TYPE = (str, bytes)
    ALLOWED_VALUES = (
        &#34;ssh-rsa-cert-v01@openssh.com&#34;,
        &#34;rsa-sha2-256-cert-v01@openssh.com&#34;,
        &#34;rsa-sha2-512-cert-v01@openssh.com&#34;,
        &#34;ssh-dss-cert-v01@openssh.com&#34;,
        &#34;ecdsa-sha2-nistp256-cert-v01@openssh.com&#34;,
        &#34;ecdsa-sha2-nistp384-cert-v01@openssh.com&#34;,
        &#34;ecdsa-sha2-nistp521-cert-v01@openssh.com&#34;,
        &#34;ssh-ed25519-cert-v01@openssh.com&#34;,
    )

    def __validate_value__(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the contents of the field
        &#34;&#34;&#34;
        if isinstance(self.__validate_type__(self.value), Exception):
            return _EX.InvalidFieldDataException(
                f&#34;{self.get_name()} Could not validate value, invalid type&#34;
            )

        if ensure_string(self.value) not in self.ALLOWED_VALUES:
            return _EX.InvalidFieldDataException(
                &#34;Expected one of the following values: &#34;
                + NEWLINE.join(self.ALLOWED_VALUES)
            )

        return True


class NonceField(StringField):
    &#34;&#34;&#34;
    Contains the nonce for the certificate, randomly generated
    this protects the integrity of the private key, especially
    for ecdsa.
    &#34;&#34;&#34;

    DEFAULT = generate_secure_nonce
    DATA_TYPE = (str, bytes)

    def __validate_value__(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the contents of the field
        &#34;&#34;&#34;
        if isinstance(self.__validate_type__(self.value), Exception):
            return _EX.InvalidFieldDataException(
                f&#34;{self.get_name()} Could not validate value, invalid type&#34;
            )

        if hasattr(self.value, &#34;__count__&#34;) and len(self.value) &lt; 32:
            return _EX.InvalidFieldDataException(
                &#34;Expected a nonce of at least 32 bytes&#34;
            )

        return True


class PublicKeyField(CertificateField):
    &#34;&#34;&#34;
    Contains the subject (User or Host) public key for whom/which
    the certificate is created.
    &#34;&#34;&#34;

    DEFAULT = None
    DATA_TYPE = PublicKey

    def __table__(self) -&gt; tuple:
        return [str(self.name), str(self.value.get_fingerprint())]

    def __str__(self) -&gt; str:
        return &#34; &#34;.join(
            [
                self.__class__.__name__.replace(&#34;PubkeyField&#34;, &#34;&#34;),
                self.value.get_fingerprint(),
            ]
        )

    @classmethod
    def encode(cls, value: PublicKey) -&gt; bytes:
        &#34;&#34;&#34;
        Encode the certificate field to a byte string

        Args:
            value (RsaPublicKey): The public key to encode

        Returns:
            bytes: A byte string with the encoded public key
        &#34;&#34;&#34;
        cls.__validate_type__(value, True)
        return BytestringField.decode(value.raw_bytes())[1]

    @staticmethod
    def from_object(public_key: PublicKey):
        &#34;&#34;&#34;
        Loads the public key from a sshkey_tools.keys.PublicKey
        class or childclass

        Args:
            public_key (PublicKey): The public key for which to
                                    create the certificate

        Raises:
            _EX.InvalidKeyException: Invalid public key

        Returns:
            PublicKeyField: A child class of PublicKeyField specific
                            to the chosen public key
        &#34;&#34;&#34;
        try:
            return globals()[SUBJECT_PUBKEY_MAP[public_key.__class__]](value=public_key)
        except KeyError:
            raise _EX.InvalidKeyException(&#34;The public key is invalid&#34;) from KeyError


class RsaPubkeyField(PublicKeyField):
    &#34;&#34;&#34;
    Holds the RSA Public Key for RSA Certificates
    &#34;&#34;&#34;

    DEFAULT = None
    DATA_TYPE = RsaPublicKey

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[RsaPublicKey, bytes]:
        &#34;&#34;&#34;
        Decode the certificate field from a byte string
        starting with the encoded public key

        Args:
            data (bytes): The byte string starting with the encoded key

        Returns:
            Tuple[RsaPublicKey, bytes]: The PublicKey field and remainder of the data
        &#34;&#34;&#34;
        e, data = MpIntegerField.decode(data)
        n, data = MpIntegerField.decode(data)

        return RsaPublicKey.from_numbers(e=e, n=n), data


class DsaPubkeyField(PublicKeyField):
    &#34;&#34;&#34;
    Holds the DSA Public Key for DSA Certificates
    &#34;&#34;&#34;

    DEFAULT = None
    DATA_TYPE = DsaPublicKey

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[DsaPublicKey, bytes]:
        &#34;&#34;&#34;
        Decode the certificate field from a byte string
        starting with the encoded public key

        Args:
            data (bytes): The byte string starting with the encoded key

        Returns:
            Tuple[RsaPublicKey, bytes]: The PublicKey field and remainder of the data
        &#34;&#34;&#34;
        p, data = MpIntegerField.decode(data)
        q, data = MpIntegerField.decode(data)
        g, data = MpIntegerField.decode(data)
        y, data = MpIntegerField.decode(data)

        return DsaPublicKey.from_numbers(p=p, q=q, g=g, y=y), data


class EcdsaPubkeyField(PublicKeyField):
    &#34;&#34;&#34;
    Holds the ECDSA Public Key for ECDSA Certificates
    &#34;&#34;&#34;

    DEFAULT = None
    DATA_TYPE = EcdsaPublicKey

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[EcdsaPublicKey, bytes]:
        &#34;&#34;&#34;
        Decode the certificate field from a byte string
        starting with the encoded public key

        Args:
            data (bytes): The byte string starting with the encoded key

        Returns:
            Tuple[ECPublicKey, bytes]: The PublicKey field and remainder of the data
        &#34;&#34;&#34;
        curve, data = StringField.decode(data)
        key, data = BytestringField.decode(data)

        key_type = &#34;ecdsa-sha2-&#34; + curve

        return (
            EcdsaPublicKey.from_string(
                key_type
                + &#34; &#34;
                + b64encode(
                    StringField.encode(key_type)
                    + StringField.encode(curve)
                    + BytestringField.encode(key)
                ).decode(&#34;utf-8&#34;)
            ),
            data,
        )


class Ed25519PubkeyField(PublicKeyField):
    &#34;&#34;&#34;
    Holds the ED25519 Public Key for ED25519 Certificates
    &#34;&#34;&#34;

    DEFAULT = None
    DATA_TYPE = Ed25519PublicKey

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[Ed25519PublicKey, bytes]:
        &#34;&#34;&#34;
        Decode the certificate field from a byte string
        starting with the encoded public key

        Args:
            data (bytes): The byte string starting with the encoded key

        Returns:
            Tuple[Ed25519PublicKey, bytes]: The PublicKey field and remainder of the data
        &#34;&#34;&#34;
        pubkey, data = BytestringField.decode(data)

        return Ed25519PublicKey.from_raw_bytes(pubkey), data


class SerialField(Integer64Field):
    &#34;&#34;&#34;
    Contains the numeric serial number of the certificate,
    maximum is (2**64)-1
    &#34;&#34;&#34;

    DEFAULT = random_serial
    DATA_TYPE = int


class CertificateTypeField(Integer32Field):
    &#34;&#34;&#34;
    Contains the certificate type
    User certificate: CERT_TYPE.USER/1
    Host certificate: CERT_TYPE.HOST/2
    &#34;&#34;&#34;

    DEFAULT = CERT_TYPE.USER
    DATA_TYPE = (CERT_TYPE, int)
    ALLOWED_VALUES = (CERT_TYPE.USER, CERT_TYPE.HOST, 1, 2)

    @classmethod
    def encode(cls, value: Union[CERT_TYPE, int]) -&gt; bytes:
        &#34;&#34;&#34;
        Encode the certificate type field to a byte string

        Args:
            value (Union[CERT_TYPE, int]): The type of the certificate

        Returns:
            bytes: A byte string with the encoded public key
        &#34;&#34;&#34;
        cls.__validate_type__(value, True)

        if isinstance(value, CERT_TYPE):
            value = value.value

        return Integer32Field.encode(value)

    def __validate_value__(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the contents of the field
        &#34;&#34;&#34;
        if isinstance(self.__validate_type__(self.value), Exception):
            return _EX.InvalidFieldDataException(
                f&#34;{self.get_name()} Could not validate value, invalid type&#34;
            )

        if self.value not in self.ALLOWED_VALUES:
            return _EX.InvalidCertificateFieldException(
                &#34;The certificate type is invalid (expected int(1,2) or CERT_TYPE.X)&#34;
            )

        return True


class KeyIdField(StringField):
    &#34;&#34;&#34;
    Contains the key identifier (subject) of the certificate,
    alphanumeric string
    &#34;&#34;&#34;

    DEFAULT = random_keyid
    DATA_TYPE = (str, bytes)


class PrincipalsField(ListField):
    &#34;&#34;&#34;
    Contains a list of principals for the certificate,
    e.g. SERVERHOSTNAME01 or all-web-servers.
    If no principals are added, the certificate is valid
    only for servers that have no allowed principals specified
    &#34;&#34;&#34;

    DEFAFULT = []
    DATA_TYPE = (list, set, tuple)


class ValidAfterField(DateTimeField):
    &#34;&#34;&#34;
    Contains the start of the validity period for the certificate,
    represented by a datetime object
    &#34;&#34;&#34;

    DEFAULT = datetime.now()
    DATA_TYPE = (datetime, int)


class ValidBeforeField(DateTimeField):
    &#34;&#34;&#34;
    Contains the end of the validity period for the certificate,
    represented by a datetime object
    &#34;&#34;&#34;

    DEFAULT = datetime.now() + timedelta(minutes=10)
    DATA_TYPE = (datetime, int)

    def __validate_value__(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the contents of the field
        Additional checks over standard datetime field are
        done to ensure no already expired certificates are
        created
        &#34;&#34;&#34;
        if isinstance(self.__validate_type__(self.value), Exception):
            return _EX.InvalidFieldDataException(
                f&#34;{self.get_name()} Could not validate value, invalid type&#34;
            )

        super().__validate_value__()
        check = (
            self.value
            if isinstance(self.value, datetime)
            else datetime.fromtimestamp(self.value)
        )

        if check &lt; datetime.now():
            return _EX.InvalidCertificateFieldException(
                &#34;The certificate validity period is invalid&#34;
                + &#34; (expected a future datetime object or timestamp)&#34;
            )

        return True


class CriticalOptionsField(KeyValueField):
    &#34;&#34;&#34;
    Contains the critical options part of the certificate (optional).
    This should be a list of strings with one of the following

    options:
        force-command=&lt;command&gt;
            Limits the connecting user to a specific command,
            e.g. sftp-internal
        source-address=&lt;ip_address&gt;
            Limits the user to connect only from a certain
            ip, subnet or host
        verify-required=&lt;true|false&gt;
            If set to true, the user must verify their identity
            if using a hardware token
    &#34;&#34;&#34;

    DEFAULT = []
    DATA_TYPE = (list, set, tuple, dict)
    ALLOWED_VALUES = (&#34;force-command&#34;, &#34;source-address&#34;, &#34;verify-required&#34;)

    def __validate_value__(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the contents of the field
        &#34;&#34;&#34;
        if isinstance(self.__validate_type__(self.value), Exception):
            return _EX.InvalidFieldDataException(
                f&#34;{self.get_name()} Could not validate value, invalid type&#34;
            )

        for elem in (
            self.value if not isinstance(self.value, dict) else list(self.value.keys())
        ):
            if elem not in self.ALLOWED_VALUES:
                return _EX.InvalidCertificateFieldException(
                    f&#34;Critical option not recognized ({elem}){NEWLINE}&#34;
                    + f&#34;Valid options are {&#39;, &#39;.join(self.ALLOWED_VALUES)}&#34;
                )

        return True


class ExtensionsField(KeyValueField):
    &#34;&#34;&#34;
    Contains a list of extensions for the certificate,
    set to give the user limitations and/or additional
    privileges on the host.

    flags:
        no-touch-required
            The user doesn&#39;t need to touch the
            physical key to authenticate.

        permit-X11-forwarding
            Permits the user to use X11 Forwarding

        permit-agent-forwarding
            Permits the user to use agent forwarding

        permit-port-forwarding
            Permits the user to forward ports

        permit-pty
            Permits the user to use a pseudo-terminal

        permit-user-rc
            Permits the user to use the user rc file

    &#34;&#34;&#34;

    DEFAULT = []
    DATA_TYPE = (list, set, tuple, dict)
    ALLOWED_VALUES = (
        &#34;no-touch-required&#34;,
        &#34;permit-X11-forwarding&#34;,
        &#34;permit-agent-forwarding&#34;,
        &#34;permit-port-forwarding&#34;,
        &#34;permit-pty&#34;,
        &#34;permit-user-rc&#34;,
    )

    def __validate_value__(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the contents of the field
        &#34;&#34;&#34;
        if isinstance(self.__validate_type__(self.value), Exception):
            return _EX.InvalidFieldDataException(
                f&#34;{self.get_name()} Could not validate value, invalid type&#34;
            )

        for item in self.value:
            if item not in self.ALLOWED_VALUES:
                return _EX.InvalidDataException(
                    f&#34;Invalid extension &#39;{item}&#39;{NEWLINE}&#34;
                    + f&#34;Allowed values are: {NEWLINE.join(self.ALLOWED_VALUES)}&#34;
                )

        return True


class ReservedField(StringField):
    &#34;&#34;&#34;
    This field is reserved for future use, and
    doesn&#39;t contain any actual data, just an empty string.
    &#34;&#34;&#34;

    DEFAULT = &#34;&#34;
    DATA_TYPE = str

    def __validate_value__(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the contents of the field
        &#34;&#34;&#34;
        if isinstance(self.__validate_type__(self.value), Exception):
            return _EX.InvalidFieldDataException(
                f&#34;{self.get_name()} Could not validate value, invalid type&#34;
            )

        return (
            True
            if self.value == &#34;&#34;
            else _EX.InvalidDataException(&#34;The reserved field is not empty&#34;)
        )


class CAPublicKeyField(BytestringField):
    &#34;&#34;&#34;
    Contains the public key of the certificate authority
    that is used to sign the certificate.
    &#34;&#34;&#34;

    DEFAULT = None
    DATA_TYPE = (str, bytes)

    def __str__(self) -&gt; str:
        return &#34; &#34;.join(
            [
                (
                    self.value.__class__.__name__.replace(&#34;PublicKey&#34;, &#34;&#34;).replace(
                        &#34;EllipticCurve&#34;, &#34;ECDSA&#34;
                    )
                ),
                self.value.get_fingerprint(),
            ]
        )

    def __bytes__(self) -&gt; bytes:
        return self.encode(self.value.raw_bytes())

    def __table__(self) -&gt; tuple:
        return (&#34;CA Public Key&#34;, self.value.get_fingerprint())

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the contents of the field
        &#34;&#34;&#34;
        if self.value in [None, False, &#34;&#34;, &#34; &#34;]:
            return _EX.InvalidFieldDataException(&#34;You need to provide a CA public key&#34;)

        if not isinstance(self.value, PublicKey):
            return _EX.InvalidFieldDataException(
                &#34;The CA public key needs to be a sshkey_tools.keys.PublicKey object&#34;
            )

        return True

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[PublicKey, bytes]:
        &#34;&#34;&#34;
        Decode the certificate field from a byte string
        starting with the encoded public key

        Args:
            data (bytes): The byte string starting with the encoded key

        Returns:
            Tuple[PublicKey, bytes]: The PublicKey field and remainder of the data
        &#34;&#34;&#34;
        pubkey, data = BytestringField.decode(data)
        pubkey_type = StringField.decode(pubkey)[0]

        return (
            PublicKey.from_string(
                concat_to_string(pubkey_type, &#34; &#34;, b64encode(pubkey))
            ),
            data,
        )

    @classmethod
    def from_object(cls, public_key: PublicKey) -&gt; &#34;CAPublicKeyField&#34;:
        &#34;&#34;&#34;
        Creates a new CAPublicKeyField from a PublicKey object
        &#34;&#34;&#34;
        return cls(value=public_key)


class SignatureField(CertificateField):
    &#34;&#34;&#34;
    Creates and contains the signature of the certificate
    &#34;&#34;&#34;

    DEFAULT = None
    DATA_TYPE = bytes

    # pylint: disable=super-init-not-called
    def __init__(self, private_key: PrivateKey = None, signature: bytes = None):
        self.private_key = private_key
        self.is_signed = False
        self.value = signature

        if signature is not None and ensure_bytestring(signature) not in (&#34;&#34;, &#34; &#34;):
            self.is_signed = True

    def __table__(self) -&gt; tuple:
        msg = &#34;No signature&#34;
        if self.is_signed:
            msg = f&#34;Signed with private key {self.private_key.get_fingerprint()}&#34;

        return (&#34;Signature&#34;, msg)

    @staticmethod
    def from_object(private_key: PrivateKey):
        &#34;&#34;&#34;
        Load a private key from a PrivateKey object

        Args:
            private_key (PrivateKey): Private key to use for signing

        Raises:
            _EX.InvalidKeyException: Invalid private key

        Returns:
            SignatureField: SignatureField child class
        &#34;&#34;&#34;
        try:
            return globals()[CA_SIGNATURE_MAP[private_key.__class__]](
                private_key=private_key
            )
        except KeyError:
            raise _EX.InvalidKeyException(
                &#34;The private key provided is invalid or not supported&#34;
            ) from KeyError

    @staticmethod
    def from_decode(data: bytes) -&gt; Tuple[&#34;SignatureField&#34;, bytes]:
        &#34;&#34;&#34;
        Generates a SignatureField child class from the encoded signature

        Args:
            data (bytes): The bytestring containing the encoded signature

        Raises:
            _EX.InvalidDataException: Invalid data

        Returns:
            SignatureField: child of SignatureField
        &#34;&#34;&#34;
        signature, _ = BytestringField.decode(data)
        signature_type = BytestringField.decode(signature)[0]

        for key, value in SIGNATURE_TYPE_MAP.items():
            if key in signature_type:
                return globals()[value].from_decode(data)

        raise _EX.InvalidDataException(&#34;No matching signature type found&#34;)

    def can_sign(self):
        &#34;&#34;&#34;
        Determines if a signature can be generated from
        this private key
        &#34;&#34;&#34;
        return self.private_key is not None

    def sign(self, data: bytes) -&gt; None:
        &#34;&#34;&#34;
        Placeholder signing function
        &#34;&#34;&#34;
        raise _EX.InvalidClassCallException(&#34;The base class has no sign function&#34;)

    def __bytes__(self) -&gt; None:
        return self.encode(self.value)


class RsaSignatureField(SignatureField):
    &#34;&#34;&#34;
    Creates and contains the RSA signature from an RSA Private Key
    &#34;&#34;&#34;

    DEFAULT = None
    DATA_TYPE = bytes

    def __init__(
        self,
        private_key: RsaPrivateKey = None,
        hash_alg: RsaAlgs = RsaAlgs.SHA512,
        signature: bytes = None,
    ):
        super().__init__(private_key, signature)
        self.hash_alg = hash_alg

    @classmethod
    # pylint: disable=arguments-renamed
    def encode(cls, value: bytes, hash_alg: RsaAlgs = RsaAlgs.SHA512) -&gt; bytes:
        &#34;&#34;&#34;
        Encodes the value to a byte string

        Args:
            signature (bytes): The signature bytes to encode
            hash_alg (RsaAlgs, optional):  The hash algorithm used for the signature.
                                            Defaults to RsaAlgs.SHA256.

        Returns:
            bytes: The encoded byte string
        &#34;&#34;&#34;
        cls.__validate_type__(value, True)

        return BytestringField.encode(
            StringField.encode(hash_alg.value[0]) + BytestringField.encode(value)
        )

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[Tuple[bytes, bytes], bytes]:
        &#34;&#34;&#34;
        Decodes a bytestring containing a signature

        Args:
            data (bytes): The bytestring starting with the RSA Signature

        Returns:
            Tuple[ Tuple[ bytes, bytes ], bytes ]: (signature_type, signature), remainder of data
        &#34;&#34;&#34;
        signature, data = BytestringField.decode(data)

        sig_type, signature = StringField.decode(signature)
        signature, _ = BytestringField.decode(signature)

        return (sig_type, signature), data

    @classmethod
    def from_decode(cls, data: bytes) -&gt; Tuple[&#34;RsaSignatureField&#34;, bytes]:
        &#34;&#34;&#34;
        Generates an RsaSignatureField class from the encoded signature

        Args:
            data (bytes): The bytestring containing the encoded signature

        Raises:
            _EX.InvalidDataException: Invalid data

        Returns:
            Tuple[RsaSignatureField, bytes]: RSA Signature field and remainder of data
        &#34;&#34;&#34;
        signature, data = cls.decode(data)

        return (
            cls(
                private_key=None,
                hash_alg=[alg for alg in RsaAlgs if alg.value[0] == signature[0]][0],
                signature=signature[1],
            ),
            data,
        )

    # pylint: disable=unused-argument
    def sign(self, data: bytes, hash_alg: RsaAlgs = RsaAlgs.SHA512, **kwargs) -&gt; None:
        &#34;&#34;&#34;
        Signs the provided data with the provided private key

        Args:
            data (bytes): The data to be signed
            hash_alg (RsaAlgs, optional): The RSA algorithm to use for hashing.
                                           Defaults to RsaAlgs.SHA256.
        &#34;&#34;&#34;
        self.value = self.private_key.sign(data, hash_alg)

        self.hash_alg = hash_alg
        self.is_signed = True

    def __bytes__(self):
        return self.encode(self.value, self.hash_alg)


class DsaSignatureField(SignatureField):
    &#34;&#34;&#34;
    Creates and contains the DSA signature from an DSA Private Key
    &#34;&#34;&#34;

    DEFAULT = None
    DATA_TYPE = bytes

    def __init__(
        self, private_key: DsaPrivateKey = None, signature: bytes = None
    ) -&gt; None:
        super().__init__(private_key, signature)

    @classmethod
    def encode(cls, value: bytes):
        &#34;&#34;&#34;
        Encodes the signature to a byte string

        Args:
            signature (bytes): The signature bytes to encode

        Returns:
            bytes: The encoded byte string
        &#34;&#34;&#34;
        cls.__validate_type__(value, True)

        r, s = decode_dss_signature(value)

        return BytestringField.encode(
            StringField.encode(&#34;ssh-dss&#34;)
            + BytestringField.encode(long_to_bytes(r, 20) + long_to_bytes(s, 20))
        )

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[bytes, bytes]:
        &#34;&#34;&#34;
        Decodes a bytestring containing a signature

        Args:
            data (bytes): The bytestring starting with the Signature

        Returns:
            Tuple[ bytes, bytes ]: signature, remainder of the data
        &#34;&#34;&#34;
        signature, data = BytestringField.decode(data)

        signature = BytestringField.decode(BytestringField.decode(signature)[1])[0]
        r = bytes_to_long(signature[:20])
        s = bytes_to_long(signature[20:])

        signature = encode_dss_signature(r, s)

        return signature, data

    @classmethod
    def from_decode(cls, data: bytes) -&gt; Tuple[&#34;DsaSignatureField&#34;, bytes]:
        &#34;&#34;&#34;
        Creates a signature field class from the encoded signature

        Args:
            data (bytes): The bytestring starting with the Signature

        Returns:
            Tuple[ DsaSignatureField, bytes ]: signature, remainder of the data
        &#34;&#34;&#34;
        signature, data = cls.decode(data)

        return cls(private_key=None, signature=signature), data

    # pylint: disable=unused-argument
    def sign(self, data: bytes, **kwargs) -&gt; None:
        &#34;&#34;&#34;
        Signs the provided data with the provided private key

        Args:
            data (bytes): The data to be signed
        &#34;&#34;&#34;
        self.value = self.private_key.sign(data)
        self.is_signed = True


class EcdsaSignatureField(SignatureField):
    &#34;&#34;&#34;
    Creates and contains the ECDSA signature from an ECDSA Private Key
    &#34;&#34;&#34;

    DEFAULT = None
    DATA_TYPE = bytes

    def __init__(
        self,
        private_key: EcdsaPrivateKey = None,
        signature: bytes = None,
        curve_name: str = None,
    ) -&gt; None:
        super().__init__(private_key, signature)

        if curve_name is None:
            curve_size = self.private_key.public_key.key.curve.key_size
            curve_name = f&#34;ecdsa-sha2-nistp{curve_size}&#34;

        self.curve = curve_name

    @classmethod
    def encode(cls, value: bytes, curve_name: str = None) -&gt; bytes:
        &#34;&#34;&#34;
        Encodes the signature to a byte string

        Args:
            signature (bytes): The signature bytes to encode
            curve_name (str): The name of the curve used for the signature
                              private key

        Returns:
            bytes: The encoded byte string
        &#34;&#34;&#34;
        cls.__validate_type__(value, True)

        r, s = decode_dss_signature(value)

        return BytestringField.encode(
            StringField.encode(curve_name)
            + BytestringField.encode(
                MpIntegerField.encode(r) + MpIntegerField.encode(s)
            )
        )

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[Tuple[bytes, bytes], bytes]:
        &#34;&#34;&#34;
        Decodes a bytestring containing a signature

        Args:
            data (bytes): The bytestring starting with the Signature

        Returns:
            Tuple[ Tuple[ bytes, bytes ], bytes]: (curve, signature), remainder of the data
        &#34;&#34;&#34;
        signature, data = BytestringField.decode(data)

        curve, signature = StringField.decode(signature)
        signature, _ = BytestringField.decode(signature)

        r, signature = MpIntegerField.decode(signature)
        s, _ = MpIntegerField.decode(signature)

        signature = encode_dss_signature(r, s)

        return (curve, signature), data

    @classmethod
    def from_decode(cls, data: bytes) -&gt; Tuple[&#34;EcdsaSignatureField&#34;, bytes]:
        &#34;&#34;&#34;
        Creates a signature field class from the encoded signature

        Args:
            data (bytes): The bytestring starting with the Signature

        Returns:
            Tuple[ EcdsaSignatureField , bytes ]: signature, remainder of the data
        &#34;&#34;&#34;
        signature, data = cls.decode(data)

        return (
            cls(private_key=None, signature=signature[1], curve_name=signature[0]),
            data,
        )

    # pylint: disable=unused-argument
    def sign(self, data: bytes, **kwargs) -&gt; None:
        &#34;&#34;&#34;
        Signs the provided data with the provided private key

        Args:
            data (bytes): The data to be signed
        &#34;&#34;&#34;
        self.value = self.private_key.sign(data)
        self.is_signed = True

    def __bytes__(self):
        return self.encode(self.value, self.curve)


class Ed25519SignatureField(SignatureField):
    &#34;&#34;&#34;
    Creates and contains the ED25519 signature from an ED25519 Private Key
    &#34;&#34;&#34;

    DEFAULT = None
    DATA_TYPE = bytes

    def __init__(
        self,
        # trunk-ignore(gitleaks/generic-api-key)
        private_key: Ed25519PrivateKey = None,
        signature: bytes = None,
    ) -&gt; None:
        super().__init__(private_key, signature)

    @classmethod
    def encode(cls, value: bytes) -&gt; None:
        &#34;&#34;&#34;
        Encodes the signature to a byte string

        Args:
            signature (bytes): The signature bytes to encode

        Returns:
            bytes: The encoded byte string
        &#34;&#34;&#34;
        cls.__validate_type__(value, True)

        return BytestringField.encode(
            StringField.encode(&#34;ssh-ed25519&#34;) + BytestringField.encode(value)
        )

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[bytes, bytes]:
        &#34;&#34;&#34;
        Decodes a bytestring containing a signature

        Args:
            data (bytes): The bytestring starting with the Signature

        Returns:
            Tuple[ bytes, bytes ]: signature, remainder of the data
        &#34;&#34;&#34;
        signature, data = BytestringField.decode(data)

        signature = BytestringField.decode(BytestringField.decode(signature)[1])[0]

        return signature, data

    @classmethod
    def from_decode(cls, data: bytes) -&gt; Tuple[&#34;Ed25519SignatureField&#34;, bytes]:
        &#34;&#34;&#34;
        Creates a signature field class from the encoded signature

        Args:
            data (bytes): The bytestring starting with the Signature

        Returns:
            Tuple[ Ed25519SignatureField , bytes ]: signature, remainder of the data
        &#34;&#34;&#34;
        signature, data = cls.decode(data)

        return cls(private_key=None, signature=signature), data

    # pylint: disable=unused-argument
    def sign(self, data: bytes, **kwargs) -&gt; None:
        &#34;&#34;&#34;
        Signs the provided data with the provided private key

        Args:
            data (bytes): The data to be signed
            hash_alg (RsaAlgs, optional): The RSA algorithm to use for hashing.
                                           Defaults to RsaAlgs.SHA256.
        &#34;&#34;&#34;
        self.value = self.private_key.sign(data)
        self.is_signed = True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sshkey_tools.fields.decode_dss_signature"><code class="name flex">
<span>def <span class="ident">decode_dss_signature</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sshkey_tools.fields.encode_dss_signature"><code class="name flex">
<span>def <span class="ident">encode_dss_signature</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sshkey_tools.fields.BooleanField"><code class="flex name class">
<span>class <span class="ident">BooleanField</span></span>
<span>(</span><span>value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Field representing a boolean value (True/False) or (1/0)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BooleanField(CertificateField):
    &#34;&#34;&#34;
    Field representing a boolean value (True/False) or (1/0)
    &#34;&#34;&#34;

    DATA_TYPE = (bool, int)

    @classmethod
    def encode(cls, value: Union[int, bool]) -&gt; bytes:
        &#34;&#34;&#34;
        Encodes a boolean value to a byte string

        Args:
            value (bool): Boolean to encode

        Returns:
            bytes: Packed byte representing the boolean
        &#34;&#34;&#34;
        cls.__validate_type__(value, True)
        return pack(&#34;B&#34;, 1 if value else 0)

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[bool, bytes]:
        &#34;&#34;&#34;
        Decodes a boolean from a bytestring

        Args:
            data (bytes): The byte string starting with an encoded boolean
        &#34;&#34;&#34;
        return bool(unpack(&#34;B&#34;, data[:1])[0]), data[1:]

    def __validate_value__(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the contents of the field
        &#34;&#34;&#34;
        return (
            True
            if self.value in (True, False, 1, 0)
            else _EX.InvalidFieldDataException(
                f&#34;{self.get_name()} must be a boolean (True/1 or False/0)&#34;
            )
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sshkey_tools.fields.BooleanField.DATA_TYPE"><code class="name">var <span class="ident">DATA_TYPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.BooleanField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data: bytes) ‑> Tuple[bool, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes a boolean from a bytestring</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The byte string starting with an encoded boolean</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; Tuple[bool, bytes]:
    &#34;&#34;&#34;
    Decodes a boolean from a bytestring

    Args:
        data (bytes): The byte string starting with an encoded boolean
    &#34;&#34;&#34;
    return bool(unpack(&#34;B&#34;, data[:1])[0]), data[1:]</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.BooleanField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>value: Union[int, bool]) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes a boolean value to a byte string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>bool</code></dt>
<dd>Boolean to encode</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>Packed byte representing the boolean</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def encode(cls, value: Union[int, bool]) -&gt; bytes:
    &#34;&#34;&#34;
    Encodes a boolean value to a byte string

    Args:
        value (bool): Boolean to encode

    Returns:
        bytes: Packed byte representing the boolean
    &#34;&#34;&#34;
    cls.__validate_type__(value, True)
    return pack(&#34;B&#34;, 1 if value else 0)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.CertificateField.factory" href="#sshkey_tools.fields.CertificateField.factory">factory</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.get_name" href="#sshkey_tools.fields.CertificateField.get_name">get_name</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.BytestringField"><code class="flex name class">
<span>class <span class="ident">BytestringField</span></span>
<span>(</span><span>value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Field representing a bytestring value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BytestringField(CertificateField):
    &#34;&#34;&#34;
    Field representing a bytestring value
    &#34;&#34;&#34;

    DATA_TYPE = (bytes, str)
    DEFAULT = b&#34;&#34;

    @classmethod
    def encode(cls, value: bytes) -&gt; bytes:
        &#34;&#34;&#34;
        Encodes a string or bytestring into a packed byte string

        Args:
            value (Union[str, bytes]): The string/bytestring to encode
            encoding (str): The encoding to user for the string

        Returns:
            bytes: Packed byte string containing the source data
        &#34;&#34;&#34;
        cls.__validate_type__(value, True)
        return pack(&#34;&gt;I&#34;, len(value)) + ensure_bytestring(value)

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[bytes, bytes]:
        &#34;&#34;&#34;
        Unpacks the next string from a packed byte string

        Args:
            data (bytes): The packed byte string to unpack

        Returns:
            tuple(bytes, bytes):  The next block of bytes from the packed byte
                                  string and remainder of the data
        &#34;&#34;&#34;
        length = unpack(&#34;&gt;I&#34;, data[:4])[0] + 4
        return ensure_bytestring(data[4:length]), data[length:]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.CAPublicKeyField" href="#sshkey_tools.fields.CAPublicKeyField">CAPublicKeyField</a></li>
<li><a title="sshkey_tools.fields.MpIntegerField" href="#sshkey_tools.fields.MpIntegerField">MpIntegerField</a></li>
<li><a title="sshkey_tools.fields.StringField" href="#sshkey_tools.fields.StringField">StringField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sshkey_tools.fields.BytestringField.DATA_TYPE"><code class="name">var <span class="ident">DATA_TYPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sshkey_tools.fields.BytestringField.DEFAULT"><code class="name">var <span class="ident">DEFAULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.BytestringField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data: bytes) ‑> Tuple[bytes, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Unpacks the next string from a packed byte string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The packed byte string to unpack</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>tuple(bytes, bytes):
The next block of bytes from the packed byte
string and remainder of the data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; Tuple[bytes, bytes]:
    &#34;&#34;&#34;
    Unpacks the next string from a packed byte string

    Args:
        data (bytes): The packed byte string to unpack

    Returns:
        tuple(bytes, bytes):  The next block of bytes from the packed byte
                              string and remainder of the data
    &#34;&#34;&#34;
    length = unpack(&#34;&gt;I&#34;, data[:4])[0] + 4
    return ensure_bytestring(data[4:length]), data[length:]</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.BytestringField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>value: bytes) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes a string or bytestring into a packed byte string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>Union[str, bytes]</code></dt>
<dd>The string/bytestring to encode</dd>
<dt><strong><code>encoding</code></strong> :&ensp;<code>str</code></dt>
<dd>The encoding to user for the string</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>Packed byte string containing the source data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def encode(cls, value: bytes) -&gt; bytes:
    &#34;&#34;&#34;
    Encodes a string or bytestring into a packed byte string

    Args:
        value (Union[str, bytes]): The string/bytestring to encode
        encoding (str): The encoding to user for the string

    Returns:
        bytes: Packed byte string containing the source data
    &#34;&#34;&#34;
    cls.__validate_type__(value, True)
    return pack(&#34;&gt;I&#34;, len(value)) + ensure_bytestring(value)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.CertificateField.factory" href="#sshkey_tools.fields.CertificateField.factory">factory</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.get_name" href="#sshkey_tools.fields.CertificateField.get_name">get_name</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.CAPublicKeyField"><code class="flex name class">
<span>class <span class="ident">CAPublicKeyField</span></span>
<span>(</span><span>value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains the public key of the certificate authority
that is used to sign the certificate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CAPublicKeyField(BytestringField):
    &#34;&#34;&#34;
    Contains the public key of the certificate authority
    that is used to sign the certificate.
    &#34;&#34;&#34;

    DEFAULT = None
    DATA_TYPE = (str, bytes)

    def __str__(self) -&gt; str:
        return &#34; &#34;.join(
            [
                (
                    self.value.__class__.__name__.replace(&#34;PublicKey&#34;, &#34;&#34;).replace(
                        &#34;EllipticCurve&#34;, &#34;ECDSA&#34;
                    )
                ),
                self.value.get_fingerprint(),
            ]
        )

    def __bytes__(self) -&gt; bytes:
        return self.encode(self.value.raw_bytes())

    def __table__(self) -&gt; tuple:
        return (&#34;CA Public Key&#34;, self.value.get_fingerprint())

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the contents of the field
        &#34;&#34;&#34;
        if self.value in [None, False, &#34;&#34;, &#34; &#34;]:
            return _EX.InvalidFieldDataException(&#34;You need to provide a CA public key&#34;)

        if not isinstance(self.value, PublicKey):
            return _EX.InvalidFieldDataException(
                &#34;The CA public key needs to be a sshkey_tools.keys.PublicKey object&#34;
            )

        return True

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[PublicKey, bytes]:
        &#34;&#34;&#34;
        Decode the certificate field from a byte string
        starting with the encoded public key

        Args:
            data (bytes): The byte string starting with the encoded key

        Returns:
            Tuple[PublicKey, bytes]: The PublicKey field and remainder of the data
        &#34;&#34;&#34;
        pubkey, data = BytestringField.decode(data)
        pubkey_type = StringField.decode(pubkey)[0]

        return (
            PublicKey.from_string(
                concat_to_string(pubkey_type, &#34; &#34;, b64encode(pubkey))
            ),
            data,
        )

    @classmethod
    def from_object(cls, public_key: PublicKey) -&gt; &#34;CAPublicKeyField&#34;:
        &#34;&#34;&#34;
        Creates a new CAPublicKeyField from a PublicKey object
        &#34;&#34;&#34;
        return cls(value=public_key)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.BytestringField" href="#sshkey_tools.fields.BytestringField">BytestringField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sshkey_tools.fields.CAPublicKeyField.DATA_TYPE"><code class="name">var <span class="ident">DATA_TYPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sshkey_tools.fields.CAPublicKeyField.DEFAULT"><code class="name">var <span class="ident">DEFAULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.CAPublicKeyField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data: bytes) ‑> Tuple[<a title="sshkey_tools.keys.PublicKey" href="keys.html#sshkey_tools.keys.PublicKey">PublicKey</a>, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Decode the certificate field from a byte string
starting with the encoded public key</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The byte string starting with the encoded key</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[PublicKey, bytes]</code></dt>
<dd>The PublicKey field and remainder of the data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; Tuple[PublicKey, bytes]:
    &#34;&#34;&#34;
    Decode the certificate field from a byte string
    starting with the encoded public key

    Args:
        data (bytes): The byte string starting with the encoded key

    Returns:
        Tuple[PublicKey, bytes]: The PublicKey field and remainder of the data
    &#34;&#34;&#34;
    pubkey, data = BytestringField.decode(data)
    pubkey_type = StringField.decode(pubkey)[0]

    return (
        PublicKey.from_string(
            concat_to_string(pubkey_type, &#34; &#34;, b64encode(pubkey))
        ),
        data,
    )</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.CAPublicKeyField.from_object"><code class="name flex">
<span>def <span class="ident">from_object</span></span>(<span>public_key: <a title="sshkey_tools.keys.PublicKey" href="keys.html#sshkey_tools.keys.PublicKey">PublicKey</a>) ‑> <a title="sshkey_tools.fields.CAPublicKeyField" href="#sshkey_tools.fields.CAPublicKeyField">CAPublicKeyField</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new CAPublicKeyField from a PublicKey object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_object(cls, public_key: PublicKey) -&gt; &#34;CAPublicKeyField&#34;:
    &#34;&#34;&#34;
    Creates a new CAPublicKeyField from a PublicKey object
    &#34;&#34;&#34;
    return cls(value=public_key)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.CAPublicKeyField.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) ‑> Union[bool, Exception]</span>
</code></dt>
<dd>
<div class="desc"><p>Validates the contents of the field</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; Union[bool, Exception]:
    &#34;&#34;&#34;
    Validates the contents of the field
    &#34;&#34;&#34;
    if self.value in [None, False, &#34;&#34;, &#34; &#34;]:
        return _EX.InvalidFieldDataException(&#34;You need to provide a CA public key&#34;)

    if not isinstance(self.value, PublicKey):
        return _EX.InvalidFieldDataException(
            &#34;The CA public key needs to be a sshkey_tools.keys.PublicKey object&#34;
        )

    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.BytestringField" href="#sshkey_tools.fields.BytestringField">BytestringField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.BytestringField.encode" href="#sshkey_tools.fields.BytestringField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.BytestringField.factory" href="#sshkey_tools.fields.CertificateField.factory">factory</a></code></li>
<li><code><a title="sshkey_tools.fields.BytestringField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.BytestringField.get_name" href="#sshkey_tools.fields.CertificateField.get_name">get_name</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.CERT_TYPE"><code class="flex name class">
<span>class <span class="ident">CERT_TYPE</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Certificate types, User certificate/Host certificate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CERT_TYPE(Enum):
    &#34;&#34;&#34;
    Certificate types, User certificate/Host certificate
    &#34;&#34;&#34;

    USER = 1
    HOST = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sshkey_tools.fields.CERT_TYPE.HOST"><code class="name">var <span class="ident">HOST</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sshkey_tools.fields.CERT_TYPE.USER"><code class="name">var <span class="ident">USER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="sshkey_tools.fields.CertificateField"><code class="flex name class">
<span>class <span class="ident">CertificateField</span></span>
<span>(</span><span>value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for certificate fields</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CertificateField:
    &#34;&#34;&#34;
    The base class for certificate fields
    &#34;&#34;&#34;

    IS_SET = None
    DEFAULT = None
    REQUIRED = False
    DATA_TYPE = NoneType

    def __init__(self, value=None):
        self.value = value
        self.exception = None
        self.IS_SET = True
        self.name = self.get_name()

    def __table__(self):
        return (str(self.name), str(self.value))

    def __str__(self):
        return f&#34;{self.name}: {self.value}&#34;

    def __bytes__(self) -&gt; bytes:
        return self.encode(self.value)

    @classmethod
    def get_name(cls) -&gt; str:
        &#34;&#34;&#34;
        Fetch the name of the field (identifier format)

        Returns:
            str: The name/id of the field
        &#34;&#34;&#34;
        return &#34;_&#34;.join(re.findall(&#34;[A-Z][^A-Z]*&#34;, cls.__name__)[:-1]).lower()

    @classmethod
    def __validate_type__(cls, value, do_raise: bool = False) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validate the data type of the value against the class data type
        &#34;&#34;&#34;
        if not isinstance(value, cls.DATA_TYPE):
            ex = _EX.InvalidDataException(
                f&#34;Invalid data type for {cls.get_name()}&#34;
                + f&#34;(expected {cls.DATA_TYPE}, got {type(value)})&#34;
            )

            if do_raise:
                raise ex

            return ex

        return True

    def __validate_required__(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates if the field is set when required
        &#34;&#34;&#34;
        if self.DEFAULT == self.value is None:
            return _EX.InvalidFieldDataException(
                f&#34;{self.get_name()} is a required field&#34;
            )
        return True

    def __validate_value__(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the contents of the field
        Meant to be overridden by child classes
        &#34;&#34;&#34;
        return True

    # pylint: disable=not-callable
    def validate(self) -&gt; bool:
        &#34;&#34;&#34;
        Validates all field contents and types
        &#34;&#34;&#34;
        if isinstance(self.value, NoneType) and self.DEFAULT is not None:
            self.value = self.DEFAULT() if callable(self.DEFAULT) else self.DEFAULT

        self.exception = (
            self.__validate_type__(self.value),
            self.__validate_required__(),
            self.__validate_value__(),
        )

        return self.exception == (True, True, True)

    @staticmethod
    def decode(data: bytes) -&gt; tuple:
        &#34;&#34;&#34;
        Returns the decoded value of the field
        &#34;&#34;&#34;

    @classmethod
    def encode(cls, value) -&gt; bytes:
        &#34;&#34;&#34;
        Returns the encoded value of the field
        &#34;&#34;&#34;

    @classmethod
    def from_decode(cls, data: bytes) -&gt; Tuple[&#34;CertificateField&#34;, bytes]:
        &#34;&#34;&#34;
        Creates a field class based on encoded bytes

        Returns:
            tuple: CertificateField, remaining bytes
        &#34;&#34;&#34;
        value, data = cls.decode(data)
        return cls(value), data

    @classmethod
    # pylint: disable=not-callable
    def factory(cls, blank: bool = False) -&gt; &#34;CertificateField&#34;:
        &#34;&#34;&#34;
        Factory to create field with default value if set, otherwise empty

        Args:
            blank (bool): Return a blank class (for decoding)

        Returns:
            CertificateField: A new CertificateField subclass instance
        &#34;&#34;&#34;
        if cls.DEFAULT is None or blank:
            return cls

        if callable(cls.DEFAULT):
            return cls(cls.DEFAULT())

        return cls(cls.DEFAULT)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.BooleanField" href="#sshkey_tools.fields.BooleanField">BooleanField</a></li>
<li><a title="sshkey_tools.fields.BytestringField" href="#sshkey_tools.fields.BytestringField">BytestringField</a></li>
<li><a title="sshkey_tools.fields.Integer32Field" href="#sshkey_tools.fields.Integer32Field">Integer32Field</a></li>
<li><a title="sshkey_tools.fields.Integer64Field" href="#sshkey_tools.fields.Integer64Field">Integer64Field</a></li>
<li><a title="sshkey_tools.fields.KeyValueField" href="#sshkey_tools.fields.KeyValueField">KeyValueField</a></li>
<li><a title="sshkey_tools.fields.ListField" href="#sshkey_tools.fields.ListField">ListField</a></li>
<li><a title="sshkey_tools.fields.PublicKeyField" href="#sshkey_tools.fields.PublicKeyField">PublicKeyField</a></li>
<li><a title="sshkey_tools.fields.SignatureField" href="#sshkey_tools.fields.SignatureField">SignatureField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sshkey_tools.fields.CertificateField.DATA_TYPE"><code class="name">var <span class="ident">DATA_TYPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sshkey_tools.fields.CertificateField.DEFAULT"><code class="name">var <span class="ident">DEFAULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sshkey_tools.fields.CertificateField.IS_SET"><code class="name">var <span class="ident">IS_SET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sshkey_tools.fields.CertificateField.REQUIRED"><code class="name">var <span class="ident">REQUIRED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.CertificateField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data: bytes) ‑> tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the decoded value of the field</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; tuple:
    &#34;&#34;&#34;
    Returns the decoded value of the field
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.CertificateField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>value) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the encoded value of the field</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def encode(cls, value) -&gt; bytes:
    &#34;&#34;&#34;
    Returns the encoded value of the field
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.CertificateField.factory"><code class="name flex">
<span>def <span class="ident">factory</span></span>(<span>blank: bool = False) ‑> <a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></span>
</code></dt>
<dd>
<div class="desc"><p>Factory to create field with default value if set, otherwise empty</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>blank</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return a blank class (for decoding)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></code></dt>
<dd>A new CertificateField subclass instance</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
# pylint: disable=not-callable
def factory(cls, blank: bool = False) -&gt; &#34;CertificateField&#34;:
    &#34;&#34;&#34;
    Factory to create field with default value if set, otherwise empty

    Args:
        blank (bool): Return a blank class (for decoding)

    Returns:
        CertificateField: A new CertificateField subclass instance
    &#34;&#34;&#34;
    if cls.DEFAULT is None or blank:
        return cls

    if callable(cls.DEFAULT):
        return cls(cls.DEFAULT())

    return cls(cls.DEFAULT)</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.CertificateField.from_decode"><code class="name flex">
<span>def <span class="ident">from_decode</span></span>(<span>data: bytes) ‑> Tuple[<a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a>, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a field class based on encoded bytes</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>CertificateField, remaining bytes</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_decode(cls, data: bytes) -&gt; Tuple[&#34;CertificateField&#34;, bytes]:
    &#34;&#34;&#34;
    Creates a field class based on encoded bytes

    Returns:
        tuple: CertificateField, remaining bytes
    &#34;&#34;&#34;
    value, data = cls.decode(data)
    return cls(value), data</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.CertificateField.get_name"><code class="name flex">
<span>def <span class="ident">get_name</span></span>(<span>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch the name of the field (identifier format)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The name/id of the field</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_name(cls) -&gt; str:
    &#34;&#34;&#34;
    Fetch the name of the field (identifier format)

    Returns:
        str: The name/id of the field
    &#34;&#34;&#34;
    return &#34;_&#34;.join(re.findall(&#34;[A-Z][^A-Z]*&#34;, cls.__name__)[:-1]).lower()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.CertificateField.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Validates all field contents and types</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; bool:
    &#34;&#34;&#34;
    Validates all field contents and types
    &#34;&#34;&#34;
    if isinstance(self.value, NoneType) and self.DEFAULT is not None:
        self.value = self.DEFAULT() if callable(self.DEFAULT) else self.DEFAULT

    self.exception = (
        self.__validate_type__(self.value),
        self.__validate_required__(),
        self.__validate_value__(),
    )

    return self.exception == (True, True, True)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sshkey_tools.fields.CertificateTypeField"><code class="flex name class">
<span>class <span class="ident">CertificateTypeField</span></span>
<span>(</span><span>value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains the certificate type
User certificate: CERT_TYPE.USER/1
Host certificate: CERT_TYPE.HOST/2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CertificateTypeField(Integer32Field):
    &#34;&#34;&#34;
    Contains the certificate type
    User certificate: CERT_TYPE.USER/1
    Host certificate: CERT_TYPE.HOST/2
    &#34;&#34;&#34;

    DEFAULT = CERT_TYPE.USER
    DATA_TYPE = (CERT_TYPE, int)
    ALLOWED_VALUES = (CERT_TYPE.USER, CERT_TYPE.HOST, 1, 2)

    @classmethod
    def encode(cls, value: Union[CERT_TYPE, int]) -&gt; bytes:
        &#34;&#34;&#34;
        Encode the certificate type field to a byte string

        Args:
            value (Union[CERT_TYPE, int]): The type of the certificate

        Returns:
            bytes: A byte string with the encoded public key
        &#34;&#34;&#34;
        cls.__validate_type__(value, True)

        if isinstance(value, CERT_TYPE):
            value = value.value

        return Integer32Field.encode(value)

    def __validate_value__(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the contents of the field
        &#34;&#34;&#34;
        if isinstance(self.__validate_type__(self.value), Exception):
            return _EX.InvalidFieldDataException(
                f&#34;{self.get_name()} Could not validate value, invalid type&#34;
            )

        if self.value not in self.ALLOWED_VALUES:
            return _EX.InvalidCertificateFieldException(
                &#34;The certificate type is invalid (expected int(1,2) or CERT_TYPE.X)&#34;
            )

        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.Integer32Field" href="#sshkey_tools.fields.Integer32Field">Integer32Field</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sshkey_tools.fields.CertificateTypeField.ALLOWED_VALUES"><code class="name">var <span class="ident">ALLOWED_VALUES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sshkey_tools.fields.CertificateTypeField.DEFAULT"><code class="name">var <span class="ident">DEFAULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.CertificateTypeField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>value: Union[<a title="sshkey_tools.fields.CERT_TYPE" href="#sshkey_tools.fields.CERT_TYPE">CERT_TYPE</a>, int]) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encode the certificate type field to a byte string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>Union[<a title="sshkey_tools.fields.CERT_TYPE" href="#sshkey_tools.fields.CERT_TYPE">CERT_TYPE</a>, int]</code></dt>
<dd>The type of the certificate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>A byte string with the encoded public key</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def encode(cls, value: Union[CERT_TYPE, int]) -&gt; bytes:
    &#34;&#34;&#34;
    Encode the certificate type field to a byte string

    Args:
        value (Union[CERT_TYPE, int]): The type of the certificate

    Returns:
        bytes: A byte string with the encoded public key
    &#34;&#34;&#34;
    cls.__validate_type__(value, True)

    if isinstance(value, CERT_TYPE):
        value = value.value

    return Integer32Field.encode(value)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.Integer32Field" href="#sshkey_tools.fields.Integer32Field">Integer32Field</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.Integer32Field.DATA_TYPE" href="#sshkey_tools.fields.Integer32Field.DATA_TYPE">DATA_TYPE</a></code></li>
<li><code><a title="sshkey_tools.fields.Integer32Field.decode" href="#sshkey_tools.fields.Integer32Field.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.Integer32Field.factory" href="#sshkey_tools.fields.CertificateField.factory">factory</a></code></li>
<li><code><a title="sshkey_tools.fields.Integer32Field.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.Integer32Field.get_name" href="#sshkey_tools.fields.CertificateField.get_name">get_name</a></code></li>
<li><code><a title="sshkey_tools.fields.Integer32Field.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.CriticalOptionsField"><code class="flex name class">
<span>class <span class="ident">CriticalOptionsField</span></span>
<span>(</span><span>value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains the critical options part of the certificate (optional).
This should be a list of strings with one of the following</p>
<p>options:
force-command=<command>
Limits the connecting user to a specific command,
e.g. sftp-internal
source-address=<ip_address>
Limits the user to connect only from a certain
ip, subnet or host
verify-required=<true|false>
If set to true, the user must verify their identity
if using a hardware token</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CriticalOptionsField(KeyValueField):
    &#34;&#34;&#34;
    Contains the critical options part of the certificate (optional).
    This should be a list of strings with one of the following

    options:
        force-command=&lt;command&gt;
            Limits the connecting user to a specific command,
            e.g. sftp-internal
        source-address=&lt;ip_address&gt;
            Limits the user to connect only from a certain
            ip, subnet or host
        verify-required=&lt;true|false&gt;
            If set to true, the user must verify their identity
            if using a hardware token
    &#34;&#34;&#34;

    DEFAULT = []
    DATA_TYPE = (list, set, tuple, dict)
    ALLOWED_VALUES = (&#34;force-command&#34;, &#34;source-address&#34;, &#34;verify-required&#34;)

    def __validate_value__(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the contents of the field
        &#34;&#34;&#34;
        if isinstance(self.__validate_type__(self.value), Exception):
            return _EX.InvalidFieldDataException(
                f&#34;{self.get_name()} Could not validate value, invalid type&#34;
            )

        for elem in (
            self.value if not isinstance(self.value, dict) else list(self.value.keys())
        ):
            if elem not in self.ALLOWED_VALUES:
                return _EX.InvalidCertificateFieldException(
                    f&#34;Critical option not recognized ({elem}){NEWLINE}&#34;
                    + f&#34;Valid options are {&#39;, &#39;.join(self.ALLOWED_VALUES)}&#34;
                )

        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.KeyValueField" href="#sshkey_tools.fields.KeyValueField">KeyValueField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sshkey_tools.fields.CriticalOptionsField.ALLOWED_VALUES"><code class="name">var <span class="ident">ALLOWED_VALUES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sshkey_tools.fields.CriticalOptionsField.DATA_TYPE"><code class="name">var <span class="ident">DATA_TYPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sshkey_tools.fields.CriticalOptionsField.DEFAULT"><code class="name">var <span class="ident">DEFAULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.KeyValueField" href="#sshkey_tools.fields.KeyValueField">KeyValueField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.KeyValueField.decode" href="#sshkey_tools.fields.KeyValueField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.KeyValueField.encode" href="#sshkey_tools.fields.KeyValueField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.KeyValueField.factory" href="#sshkey_tools.fields.CertificateField.factory">factory</a></code></li>
<li><code><a title="sshkey_tools.fields.KeyValueField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.KeyValueField.get_name" href="#sshkey_tools.fields.CertificateField.get_name">get_name</a></code></li>
<li><code><a title="sshkey_tools.fields.KeyValueField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.DateTimeField"><code class="flex name class">
<span>class <span class="ident">DateTimeField</span></span>
<span>(</span><span>value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Certificate field representing a datetime value.
The value is saved as a 64-bit integer (unix timestamp)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DateTimeField(Integer64Field):
    &#34;&#34;&#34;
    Certificate field representing a datetime value.
    The value is saved as a 64-bit integer (unix timestamp)
    &#34;&#34;&#34;

    DATA_TYPE = (datetime, int, str)
    DEFAULT = datetime.now

    @classmethod
    def encode(cls, value: Union[datetime, int, str]) -&gt; bytes:
        &#34;&#34;&#34;Encodes a datetime object, integer or time string to a byte string
           Time strings are parsed with pytimeparse2, for example:
            32m
            2h32m
            3d2h32m
            1w3d2h32m
            1w 3d 2h 32m
            1 w 3 d 2 h 32 m
            4:13
            4:13:02
            4:13:02.266
            forever (Returns as MAX_INT64)

        Args:
            value (datetime, int, str): Datetime object

        Returns:
            bytes: Packed byte string containing datetime timestamp
        &#34;&#34;&#34;
        cls.__validate_type__(value, True)

        if isinstance(value, str):
            if value == &#34;forever&#34;:
                return Integer64Field.encode(MAX_INT64)

            value = int(datetime.now() + str_to_timedelta(value))

        if isinstance(value, datetime):
            value = int(value.timestamp())

        return Integer64Field.encode(value)

    @staticmethod
    def decode(data: bytes) -&gt; datetime:
        &#34;&#34;&#34;Decodes a datetime object from a block of bytes

        Args:
            data (bytes): Block of bytes containing a datetime object

        Returns:
            tuple: Tuple with datetime and remainder of data
        &#34;&#34;&#34;
        timestamp, data = Integer64Field.decode(data)
        return datetime.fromtimestamp(timestamp), data

    def __validate_value__(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the contents of the field
        &#34;&#34;&#34;
        if isinstance(self.__validate_type__(self.value), Exception):
            return _EX.InvalidFieldDataException(
                f&#34;{self.get_name()} Could not validate value, invalid type&#34;
            )

        check = self.value if isinstance(self.value, int) else self.value.timestamp()

        if check &lt; MAX_INT64:
            return True

        return _EX.InvalidFieldDataException(
            f&#34;{self.get_name()} must be a 64-bit integer or datetime object&#34;
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.Integer64Field" href="#sshkey_tools.fields.Integer64Field">Integer64Field</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.ValidAfterField" href="#sshkey_tools.fields.ValidAfterField">ValidAfterField</a></li>
<li><a title="sshkey_tools.fields.ValidBeforeField" href="#sshkey_tools.fields.ValidBeforeField">ValidBeforeField</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.DateTimeField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data: bytes) ‑> datetime.datetime</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes a datetime object from a block of bytes</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>Block of bytes containing a datetime object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>Tuple with datetime and remainder of data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; datetime:
    &#34;&#34;&#34;Decodes a datetime object from a block of bytes

    Args:
        data (bytes): Block of bytes containing a datetime object

    Returns:
        tuple: Tuple with datetime and remainder of data
    &#34;&#34;&#34;
    timestamp, data = Integer64Field.decode(data)
    return datetime.fromtimestamp(timestamp), data</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.DateTimeField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>value: Union[datetime.datetime, int, str]) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes a datetime object, integer or time string to a byte string
Time strings are parsed with pytimeparse2, for example:
32m
2h32m
3d2h32m
1w3d2h32m
1w 3d 2h 32m
1 w 3 d 2 h 32 m
4:13
4:13:02
4:13:02.266
forever (Returns as MAX_INT64)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>datetime, int, str</code></dt>
<dd>Datetime object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>Packed byte string containing datetime timestamp</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def encode(cls, value: Union[datetime, int, str]) -&gt; bytes:
    &#34;&#34;&#34;Encodes a datetime object, integer or time string to a byte string
       Time strings are parsed with pytimeparse2, for example:
        32m
        2h32m
        3d2h32m
        1w3d2h32m
        1w 3d 2h 32m
        1 w 3 d 2 h 32 m
        4:13
        4:13:02
        4:13:02.266
        forever (Returns as MAX_INT64)

    Args:
        value (datetime, int, str): Datetime object

    Returns:
        bytes: Packed byte string containing datetime timestamp
    &#34;&#34;&#34;
    cls.__validate_type__(value, True)

    if isinstance(value, str):
        if value == &#34;forever&#34;:
            return Integer64Field.encode(MAX_INT64)

        value = int(datetime.now() + str_to_timedelta(value))

    if isinstance(value, datetime):
        value = int(value.timestamp())

    return Integer64Field.encode(value)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.DateTimeField.DEFAULT"><code class="name flex">
<span>def <span class="ident">DEFAULT</span></span>(<span>tz=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns new datetime object representing current time local to tz.</p>
<p>tz
Timezone object.</p>
<p>If no tz is specified, uses local timezone.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.Integer64Field" href="#sshkey_tools.fields.Integer64Field">Integer64Field</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.Integer64Field.DATA_TYPE" href="#sshkey_tools.fields.Integer64Field.DATA_TYPE">DATA_TYPE</a></code></li>
<li><code><a title="sshkey_tools.fields.Integer64Field.factory" href="#sshkey_tools.fields.CertificateField.factory">factory</a></code></li>
<li><code><a title="sshkey_tools.fields.Integer64Field.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.Integer64Field.get_name" href="#sshkey_tools.fields.CertificateField.get_name">get_name</a></code></li>
<li><code><a title="sshkey_tools.fields.Integer64Field.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.DsaPubkeyField"><code class="flex name class">
<span>class <span class="ident">DsaPubkeyField</span></span>
<span>(</span><span>value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Holds the DSA Public Key for DSA Certificates</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DsaPubkeyField(PublicKeyField):
    &#34;&#34;&#34;
    Holds the DSA Public Key for DSA Certificates
    &#34;&#34;&#34;

    DEFAULT = None
    DATA_TYPE = DsaPublicKey

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[DsaPublicKey, bytes]:
        &#34;&#34;&#34;
        Decode the certificate field from a byte string
        starting with the encoded public key

        Args:
            data (bytes): The byte string starting with the encoded key

        Returns:
            Tuple[RsaPublicKey, bytes]: The PublicKey field and remainder of the data
        &#34;&#34;&#34;
        p, data = MpIntegerField.decode(data)
        q, data = MpIntegerField.decode(data)
        g, data = MpIntegerField.decode(data)
        y, data = MpIntegerField.decode(data)

        return DsaPublicKey.from_numbers(p=p, q=q, g=g, y=y), data</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.PublicKeyField" href="#sshkey_tools.fields.PublicKeyField">PublicKeyField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sshkey_tools.fields.DsaPubkeyField.DEFAULT"><code class="name">var <span class="ident">DEFAULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.DsaPubkeyField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data: bytes) ‑> Tuple[<a title="sshkey_tools.keys.DsaPublicKey" href="keys.html#sshkey_tools.keys.DsaPublicKey">DsaPublicKey</a>, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Decode the certificate field from a byte string
starting with the encoded public key</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The byte string starting with the encoded key</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[RsaPublicKey, bytes]</code></dt>
<dd>The PublicKey field and remainder of the data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; Tuple[DsaPublicKey, bytes]:
    &#34;&#34;&#34;
    Decode the certificate field from a byte string
    starting with the encoded public key

    Args:
        data (bytes): The byte string starting with the encoded key

    Returns:
        Tuple[RsaPublicKey, bytes]: The PublicKey field and remainder of the data
    &#34;&#34;&#34;
    p, data = MpIntegerField.decode(data)
    q, data = MpIntegerField.decode(data)
    g, data = MpIntegerField.decode(data)
    y, data = MpIntegerField.decode(data)

    return DsaPublicKey.from_numbers(p=p, q=q, g=g, y=y), data</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.PublicKeyField" href="#sshkey_tools.fields.PublicKeyField">PublicKeyField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.PublicKeyField.DATA_TYPE" href="#sshkey_tools.fields.PublicKeyField.DATA_TYPE">DATA_TYPE</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.encode" href="#sshkey_tools.fields.PublicKeyField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.factory" href="#sshkey_tools.fields.CertificateField.factory">factory</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.from_object" href="#sshkey_tools.fields.PublicKeyField.from_object">from_object</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.get_name" href="#sshkey_tools.fields.CertificateField.get_name">get_name</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.DsaSignatureField"><code class="flex name class">
<span>class <span class="ident">DsaSignatureField</span></span>
<span>(</span><span>private_key: <a title="sshkey_tools.keys.DsaPrivateKey" href="keys.html#sshkey_tools.keys.DsaPrivateKey">DsaPrivateKey</a> = None, signature: bytes = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and contains the DSA signature from an DSA Private Key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DsaSignatureField(SignatureField):
    &#34;&#34;&#34;
    Creates and contains the DSA signature from an DSA Private Key
    &#34;&#34;&#34;

    DEFAULT = None
    DATA_TYPE = bytes

    def __init__(
        self, private_key: DsaPrivateKey = None, signature: bytes = None
    ) -&gt; None:
        super().__init__(private_key, signature)

    @classmethod
    def encode(cls, value: bytes):
        &#34;&#34;&#34;
        Encodes the signature to a byte string

        Args:
            signature (bytes): The signature bytes to encode

        Returns:
            bytes: The encoded byte string
        &#34;&#34;&#34;
        cls.__validate_type__(value, True)

        r, s = decode_dss_signature(value)

        return BytestringField.encode(
            StringField.encode(&#34;ssh-dss&#34;)
            + BytestringField.encode(long_to_bytes(r, 20) + long_to_bytes(s, 20))
        )

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[bytes, bytes]:
        &#34;&#34;&#34;
        Decodes a bytestring containing a signature

        Args:
            data (bytes): The bytestring starting with the Signature

        Returns:
            Tuple[ bytes, bytes ]: signature, remainder of the data
        &#34;&#34;&#34;
        signature, data = BytestringField.decode(data)

        signature = BytestringField.decode(BytestringField.decode(signature)[1])[0]
        r = bytes_to_long(signature[:20])
        s = bytes_to_long(signature[20:])

        signature = encode_dss_signature(r, s)

        return signature, data

    @classmethod
    def from_decode(cls, data: bytes) -&gt; Tuple[&#34;DsaSignatureField&#34;, bytes]:
        &#34;&#34;&#34;
        Creates a signature field class from the encoded signature

        Args:
            data (bytes): The bytestring starting with the Signature

        Returns:
            Tuple[ DsaSignatureField, bytes ]: signature, remainder of the data
        &#34;&#34;&#34;
        signature, data = cls.decode(data)

        return cls(private_key=None, signature=signature), data

    # pylint: disable=unused-argument
    def sign(self, data: bytes, **kwargs) -&gt; None:
        &#34;&#34;&#34;
        Signs the provided data with the provided private key

        Args:
            data (bytes): The data to be signed
        &#34;&#34;&#34;
        self.value = self.private_key.sign(data)
        self.is_signed = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.SignatureField" href="#sshkey_tools.fields.SignatureField">SignatureField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sshkey_tools.fields.DsaSignatureField.DEFAULT"><code class="name">var <span class="ident">DEFAULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.DsaSignatureField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data: bytes) ‑> Tuple[bytes, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes a bytestring containing a signature</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The bytestring starting with the Signature</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[ bytes, bytes ]</code></dt>
<dd>signature, remainder of the data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; Tuple[bytes, bytes]:
    &#34;&#34;&#34;
    Decodes a bytestring containing a signature

    Args:
        data (bytes): The bytestring starting with the Signature

    Returns:
        Tuple[ bytes, bytes ]: signature, remainder of the data
    &#34;&#34;&#34;
    signature, data = BytestringField.decode(data)

    signature = BytestringField.decode(BytestringField.decode(signature)[1])[0]
    r = bytes_to_long(signature[:20])
    s = bytes_to_long(signature[20:])

    signature = encode_dss_signature(r, s)

    return signature, data</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.DsaSignatureField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>value: bytes)</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes the signature to a byte string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>signature</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The signature bytes to encode</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>The encoded byte string</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def encode(cls, value: bytes):
    &#34;&#34;&#34;
    Encodes the signature to a byte string

    Args:
        signature (bytes): The signature bytes to encode

    Returns:
        bytes: The encoded byte string
    &#34;&#34;&#34;
    cls.__validate_type__(value, True)

    r, s = decode_dss_signature(value)

    return BytestringField.encode(
        StringField.encode(&#34;ssh-dss&#34;)
        + BytestringField.encode(long_to_bytes(r, 20) + long_to_bytes(s, 20))
    )</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.DsaSignatureField.from_decode"><code class="name flex">
<span>def <span class="ident">from_decode</span></span>(<span>data: bytes) ‑> Tuple[<a title="sshkey_tools.fields.DsaSignatureField" href="#sshkey_tools.fields.DsaSignatureField">DsaSignatureField</a>, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a signature field class from the encoded signature</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The bytestring starting with the Signature</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[ <a title="sshkey_tools.fields.DsaSignatureField" href="#sshkey_tools.fields.DsaSignatureField">DsaSignatureField</a>, bytes ]</code></dt>
<dd>signature, remainder of the data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_decode(cls, data: bytes) -&gt; Tuple[&#34;DsaSignatureField&#34;, bytes]:
    &#34;&#34;&#34;
    Creates a signature field class from the encoded signature

    Args:
        data (bytes): The bytestring starting with the Signature

    Returns:
        Tuple[ DsaSignatureField, bytes ]: signature, remainder of the data
    &#34;&#34;&#34;
    signature, data = cls.decode(data)

    return cls(private_key=None, signature=signature), data</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.DsaSignatureField.sign"><code class="name flex">
<span>def <span class="ident">sign</span></span>(<span>self, data: bytes, **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Signs the provided data with the provided private key</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The data to be signed</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sign(self, data: bytes, **kwargs) -&gt; None:
    &#34;&#34;&#34;
    Signs the provided data with the provided private key

    Args:
        data (bytes): The data to be signed
    &#34;&#34;&#34;
    self.value = self.private_key.sign(data)
    self.is_signed = True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.SignatureField" href="#sshkey_tools.fields.SignatureField">SignatureField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.SignatureField.DATA_TYPE" href="#sshkey_tools.fields.SignatureField.DATA_TYPE">DATA_TYPE</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.can_sign" href="#sshkey_tools.fields.SignatureField.can_sign">can_sign</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.factory" href="#sshkey_tools.fields.CertificateField.factory">factory</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.from_object" href="#sshkey_tools.fields.SignatureField.from_object">from_object</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.get_name" href="#sshkey_tools.fields.CertificateField.get_name">get_name</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.EcdsaPubkeyField"><code class="flex name class">
<span>class <span class="ident">EcdsaPubkeyField</span></span>
<span>(</span><span>value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Holds the ECDSA Public Key for ECDSA Certificates</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EcdsaPubkeyField(PublicKeyField):
    &#34;&#34;&#34;
    Holds the ECDSA Public Key for ECDSA Certificates
    &#34;&#34;&#34;

    DEFAULT = None
    DATA_TYPE = EcdsaPublicKey

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[EcdsaPublicKey, bytes]:
        &#34;&#34;&#34;
        Decode the certificate field from a byte string
        starting with the encoded public key

        Args:
            data (bytes): The byte string starting with the encoded key

        Returns:
            Tuple[ECPublicKey, bytes]: The PublicKey field and remainder of the data
        &#34;&#34;&#34;
        curve, data = StringField.decode(data)
        key, data = BytestringField.decode(data)

        key_type = &#34;ecdsa-sha2-&#34; + curve

        return (
            EcdsaPublicKey.from_string(
                key_type
                + &#34; &#34;
                + b64encode(
                    StringField.encode(key_type)
                    + StringField.encode(curve)
                    + BytestringField.encode(key)
                ).decode(&#34;utf-8&#34;)
            ),
            data,
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.PublicKeyField" href="#sshkey_tools.fields.PublicKeyField">PublicKeyField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sshkey_tools.fields.EcdsaPubkeyField.DEFAULT"><code class="name">var <span class="ident">DEFAULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.EcdsaPubkeyField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data: bytes) ‑> Tuple[<a title="sshkey_tools.keys.EcdsaPublicKey" href="keys.html#sshkey_tools.keys.EcdsaPublicKey">EcdsaPublicKey</a>, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Decode the certificate field from a byte string
starting with the encoded public key</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The byte string starting with the encoded key</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[ECPublicKey, bytes]</code></dt>
<dd>The PublicKey field and remainder of the data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; Tuple[EcdsaPublicKey, bytes]:
    &#34;&#34;&#34;
    Decode the certificate field from a byte string
    starting with the encoded public key

    Args:
        data (bytes): The byte string starting with the encoded key

    Returns:
        Tuple[ECPublicKey, bytes]: The PublicKey field and remainder of the data
    &#34;&#34;&#34;
    curve, data = StringField.decode(data)
    key, data = BytestringField.decode(data)

    key_type = &#34;ecdsa-sha2-&#34; + curve

    return (
        EcdsaPublicKey.from_string(
            key_type
            + &#34; &#34;
            + b64encode(
                StringField.encode(key_type)
                + StringField.encode(curve)
                + BytestringField.encode(key)
            ).decode(&#34;utf-8&#34;)
        ),
        data,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.PublicKeyField" href="#sshkey_tools.fields.PublicKeyField">PublicKeyField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.PublicKeyField.DATA_TYPE" href="#sshkey_tools.fields.PublicKeyField.DATA_TYPE">DATA_TYPE</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.encode" href="#sshkey_tools.fields.PublicKeyField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.factory" href="#sshkey_tools.fields.CertificateField.factory">factory</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.from_object" href="#sshkey_tools.fields.PublicKeyField.from_object">from_object</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.get_name" href="#sshkey_tools.fields.CertificateField.get_name">get_name</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.EcdsaSignatureField"><code class="flex name class">
<span>class <span class="ident">EcdsaSignatureField</span></span>
<span>(</span><span>private_key: <a title="sshkey_tools.keys.EcdsaPrivateKey" href="keys.html#sshkey_tools.keys.EcdsaPrivateKey">EcdsaPrivateKey</a> = None, signature: bytes = None, curve_name: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and contains the ECDSA signature from an ECDSA Private Key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EcdsaSignatureField(SignatureField):
    &#34;&#34;&#34;
    Creates and contains the ECDSA signature from an ECDSA Private Key
    &#34;&#34;&#34;

    DEFAULT = None
    DATA_TYPE = bytes

    def __init__(
        self,
        private_key: EcdsaPrivateKey = None,
        signature: bytes = None,
        curve_name: str = None,
    ) -&gt; None:
        super().__init__(private_key, signature)

        if curve_name is None:
            curve_size = self.private_key.public_key.key.curve.key_size
            curve_name = f&#34;ecdsa-sha2-nistp{curve_size}&#34;

        self.curve = curve_name

    @classmethod
    def encode(cls, value: bytes, curve_name: str = None) -&gt; bytes:
        &#34;&#34;&#34;
        Encodes the signature to a byte string

        Args:
            signature (bytes): The signature bytes to encode
            curve_name (str): The name of the curve used for the signature
                              private key

        Returns:
            bytes: The encoded byte string
        &#34;&#34;&#34;
        cls.__validate_type__(value, True)

        r, s = decode_dss_signature(value)

        return BytestringField.encode(
            StringField.encode(curve_name)
            + BytestringField.encode(
                MpIntegerField.encode(r) + MpIntegerField.encode(s)
            )
        )

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[Tuple[bytes, bytes], bytes]:
        &#34;&#34;&#34;
        Decodes a bytestring containing a signature

        Args:
            data (bytes): The bytestring starting with the Signature

        Returns:
            Tuple[ Tuple[ bytes, bytes ], bytes]: (curve, signature), remainder of the data
        &#34;&#34;&#34;
        signature, data = BytestringField.decode(data)

        curve, signature = StringField.decode(signature)
        signature, _ = BytestringField.decode(signature)

        r, signature = MpIntegerField.decode(signature)
        s, _ = MpIntegerField.decode(signature)

        signature = encode_dss_signature(r, s)

        return (curve, signature), data

    @classmethod
    def from_decode(cls, data: bytes) -&gt; Tuple[&#34;EcdsaSignatureField&#34;, bytes]:
        &#34;&#34;&#34;
        Creates a signature field class from the encoded signature

        Args:
            data (bytes): The bytestring starting with the Signature

        Returns:
            Tuple[ EcdsaSignatureField , bytes ]: signature, remainder of the data
        &#34;&#34;&#34;
        signature, data = cls.decode(data)

        return (
            cls(private_key=None, signature=signature[1], curve_name=signature[0]),
            data,
        )

    # pylint: disable=unused-argument
    def sign(self, data: bytes, **kwargs) -&gt; None:
        &#34;&#34;&#34;
        Signs the provided data with the provided private key

        Args:
            data (bytes): The data to be signed
        &#34;&#34;&#34;
        self.value = self.private_key.sign(data)
        self.is_signed = True

    def __bytes__(self):
        return self.encode(self.value, self.curve)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.SignatureField" href="#sshkey_tools.fields.SignatureField">SignatureField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sshkey_tools.fields.EcdsaSignatureField.DEFAULT"><code class="name">var <span class="ident">DEFAULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.EcdsaSignatureField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data: bytes) ‑> Tuple[Tuple[bytes, bytes], bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes a bytestring containing a signature</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The bytestring starting with the Signature</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[ Tuple[ bytes, bytes ], bytes]</code></dt>
<dd>(curve, signature), remainder of the data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; Tuple[Tuple[bytes, bytes], bytes]:
    &#34;&#34;&#34;
    Decodes a bytestring containing a signature

    Args:
        data (bytes): The bytestring starting with the Signature

    Returns:
        Tuple[ Tuple[ bytes, bytes ], bytes]: (curve, signature), remainder of the data
    &#34;&#34;&#34;
    signature, data = BytestringField.decode(data)

    curve, signature = StringField.decode(signature)
    signature, _ = BytestringField.decode(signature)

    r, signature = MpIntegerField.decode(signature)
    s, _ = MpIntegerField.decode(signature)

    signature = encode_dss_signature(r, s)

    return (curve, signature), data</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.EcdsaSignatureField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>value: bytes, curve_name: str = None) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes the signature to a byte string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>signature</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The signature bytes to encode</dd>
<dt><strong><code>curve_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the curve used for the signature
private key</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>The encoded byte string</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def encode(cls, value: bytes, curve_name: str = None) -&gt; bytes:
    &#34;&#34;&#34;
    Encodes the signature to a byte string

    Args:
        signature (bytes): The signature bytes to encode
        curve_name (str): The name of the curve used for the signature
                          private key

    Returns:
        bytes: The encoded byte string
    &#34;&#34;&#34;
    cls.__validate_type__(value, True)

    r, s = decode_dss_signature(value)

    return BytestringField.encode(
        StringField.encode(curve_name)
        + BytestringField.encode(
            MpIntegerField.encode(r) + MpIntegerField.encode(s)
        )
    )</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.EcdsaSignatureField.from_decode"><code class="name flex">
<span>def <span class="ident">from_decode</span></span>(<span>data: bytes) ‑> Tuple[<a title="sshkey_tools.fields.EcdsaSignatureField" href="#sshkey_tools.fields.EcdsaSignatureField">EcdsaSignatureField</a>, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a signature field class from the encoded signature</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The bytestring starting with the Signature</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[ <a title="sshkey_tools.fields.EcdsaSignatureField" href="#sshkey_tools.fields.EcdsaSignatureField">EcdsaSignatureField</a> , bytes ]</code></dt>
<dd>signature, remainder of the data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_decode(cls, data: bytes) -&gt; Tuple[&#34;EcdsaSignatureField&#34;, bytes]:
    &#34;&#34;&#34;
    Creates a signature field class from the encoded signature

    Args:
        data (bytes): The bytestring starting with the Signature

    Returns:
        Tuple[ EcdsaSignatureField , bytes ]: signature, remainder of the data
    &#34;&#34;&#34;
    signature, data = cls.decode(data)

    return (
        cls(private_key=None, signature=signature[1], curve_name=signature[0]),
        data,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.EcdsaSignatureField.sign"><code class="name flex">
<span>def <span class="ident">sign</span></span>(<span>self, data: bytes, **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Signs the provided data with the provided private key</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The data to be signed</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sign(self, data: bytes, **kwargs) -&gt; None:
    &#34;&#34;&#34;
    Signs the provided data with the provided private key

    Args:
        data (bytes): The data to be signed
    &#34;&#34;&#34;
    self.value = self.private_key.sign(data)
    self.is_signed = True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.SignatureField" href="#sshkey_tools.fields.SignatureField">SignatureField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.SignatureField.DATA_TYPE" href="#sshkey_tools.fields.SignatureField.DATA_TYPE">DATA_TYPE</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.can_sign" href="#sshkey_tools.fields.SignatureField.can_sign">can_sign</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.factory" href="#sshkey_tools.fields.CertificateField.factory">factory</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.from_object" href="#sshkey_tools.fields.SignatureField.from_object">from_object</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.get_name" href="#sshkey_tools.fields.CertificateField.get_name">get_name</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.Ed25519PubkeyField"><code class="flex name class">
<span>class <span class="ident">Ed25519PubkeyField</span></span>
<span>(</span><span>value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Holds the ED25519 Public Key for ED25519 Certificates</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Ed25519PubkeyField(PublicKeyField):
    &#34;&#34;&#34;
    Holds the ED25519 Public Key for ED25519 Certificates
    &#34;&#34;&#34;

    DEFAULT = None
    DATA_TYPE = Ed25519PublicKey

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[Ed25519PublicKey, bytes]:
        &#34;&#34;&#34;
        Decode the certificate field from a byte string
        starting with the encoded public key

        Args:
            data (bytes): The byte string starting with the encoded key

        Returns:
            Tuple[Ed25519PublicKey, bytes]: The PublicKey field and remainder of the data
        &#34;&#34;&#34;
        pubkey, data = BytestringField.decode(data)

        return Ed25519PublicKey.from_raw_bytes(pubkey), data</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.PublicKeyField" href="#sshkey_tools.fields.PublicKeyField">PublicKeyField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sshkey_tools.fields.Ed25519PubkeyField.DEFAULT"><code class="name">var <span class="ident">DEFAULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.Ed25519PubkeyField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data: bytes) ‑> Tuple[<a title="sshkey_tools.keys.Ed25519PublicKey" href="keys.html#sshkey_tools.keys.Ed25519PublicKey">Ed25519PublicKey</a>, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Decode the certificate field from a byte string
starting with the encoded public key</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The byte string starting with the encoded key</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[Ed25519PublicKey, bytes]</code></dt>
<dd>The PublicKey field and remainder of the data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; Tuple[Ed25519PublicKey, bytes]:
    &#34;&#34;&#34;
    Decode the certificate field from a byte string
    starting with the encoded public key

    Args:
        data (bytes): The byte string starting with the encoded key

    Returns:
        Tuple[Ed25519PublicKey, bytes]: The PublicKey field and remainder of the data
    &#34;&#34;&#34;
    pubkey, data = BytestringField.decode(data)

    return Ed25519PublicKey.from_raw_bytes(pubkey), data</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.PublicKeyField" href="#sshkey_tools.fields.PublicKeyField">PublicKeyField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.PublicKeyField.DATA_TYPE" href="#sshkey_tools.fields.PublicKeyField.DATA_TYPE">DATA_TYPE</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.encode" href="#sshkey_tools.fields.PublicKeyField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.factory" href="#sshkey_tools.fields.CertificateField.factory">factory</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.from_object" href="#sshkey_tools.fields.PublicKeyField.from_object">from_object</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.get_name" href="#sshkey_tools.fields.CertificateField.get_name">get_name</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.Ed25519SignatureField"><code class="flex name class">
<span>class <span class="ident">Ed25519SignatureField</span></span>
<span>(</span><span>private_key: <a title="sshkey_tools.keys.Ed25519PrivateKey" href="keys.html#sshkey_tools.keys.Ed25519PrivateKey">Ed25519PrivateKey</a> = None, signature: bytes = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and contains the ED25519 signature from an ED25519 Private Key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Ed25519SignatureField(SignatureField):
    &#34;&#34;&#34;
    Creates and contains the ED25519 signature from an ED25519 Private Key
    &#34;&#34;&#34;

    DEFAULT = None
    DATA_TYPE = bytes

    def __init__(
        self,
        # trunk-ignore(gitleaks/generic-api-key)
        private_key: Ed25519PrivateKey = None,
        signature: bytes = None,
    ) -&gt; None:
        super().__init__(private_key, signature)

    @classmethod
    def encode(cls, value: bytes) -&gt; None:
        &#34;&#34;&#34;
        Encodes the signature to a byte string

        Args:
            signature (bytes): The signature bytes to encode

        Returns:
            bytes: The encoded byte string
        &#34;&#34;&#34;
        cls.__validate_type__(value, True)

        return BytestringField.encode(
            StringField.encode(&#34;ssh-ed25519&#34;) + BytestringField.encode(value)
        )

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[bytes, bytes]:
        &#34;&#34;&#34;
        Decodes a bytestring containing a signature

        Args:
            data (bytes): The bytestring starting with the Signature

        Returns:
            Tuple[ bytes, bytes ]: signature, remainder of the data
        &#34;&#34;&#34;
        signature, data = BytestringField.decode(data)

        signature = BytestringField.decode(BytestringField.decode(signature)[1])[0]

        return signature, data

    @classmethod
    def from_decode(cls, data: bytes) -&gt; Tuple[&#34;Ed25519SignatureField&#34;, bytes]:
        &#34;&#34;&#34;
        Creates a signature field class from the encoded signature

        Args:
            data (bytes): The bytestring starting with the Signature

        Returns:
            Tuple[ Ed25519SignatureField , bytes ]: signature, remainder of the data
        &#34;&#34;&#34;
        signature, data = cls.decode(data)

        return cls(private_key=None, signature=signature), data

    # pylint: disable=unused-argument
    def sign(self, data: bytes, **kwargs) -&gt; None:
        &#34;&#34;&#34;
        Signs the provided data with the provided private key

        Args:
            data (bytes): The data to be signed
            hash_alg (RsaAlgs, optional): The RSA algorithm to use for hashing.
                                           Defaults to RsaAlgs.SHA256.
        &#34;&#34;&#34;
        self.value = self.private_key.sign(data)
        self.is_signed = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.SignatureField" href="#sshkey_tools.fields.SignatureField">SignatureField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sshkey_tools.fields.Ed25519SignatureField.DEFAULT"><code class="name">var <span class="ident">DEFAULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.Ed25519SignatureField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data: bytes) ‑> Tuple[bytes, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes a bytestring containing a signature</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The bytestring starting with the Signature</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[ bytes, bytes ]</code></dt>
<dd>signature, remainder of the data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; Tuple[bytes, bytes]:
    &#34;&#34;&#34;
    Decodes a bytestring containing a signature

    Args:
        data (bytes): The bytestring starting with the Signature

    Returns:
        Tuple[ bytes, bytes ]: signature, remainder of the data
    &#34;&#34;&#34;
    signature, data = BytestringField.decode(data)

    signature = BytestringField.decode(BytestringField.decode(signature)[1])[0]

    return signature, data</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.Ed25519SignatureField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>value: bytes) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes the signature to a byte string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>signature</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The signature bytes to encode</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>The encoded byte string</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def encode(cls, value: bytes) -&gt; None:
    &#34;&#34;&#34;
    Encodes the signature to a byte string

    Args:
        signature (bytes): The signature bytes to encode

    Returns:
        bytes: The encoded byte string
    &#34;&#34;&#34;
    cls.__validate_type__(value, True)

    return BytestringField.encode(
        StringField.encode(&#34;ssh-ed25519&#34;) + BytestringField.encode(value)
    )</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.Ed25519SignatureField.from_decode"><code class="name flex">
<span>def <span class="ident">from_decode</span></span>(<span>data: bytes) ‑> Tuple[<a title="sshkey_tools.fields.Ed25519SignatureField" href="#sshkey_tools.fields.Ed25519SignatureField">Ed25519SignatureField</a>, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a signature field class from the encoded signature</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The bytestring starting with the Signature</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[ <a title="sshkey_tools.fields.Ed25519SignatureField" href="#sshkey_tools.fields.Ed25519SignatureField">Ed25519SignatureField</a> , bytes ]</code></dt>
<dd>signature, remainder of the data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_decode(cls, data: bytes) -&gt; Tuple[&#34;Ed25519SignatureField&#34;, bytes]:
    &#34;&#34;&#34;
    Creates a signature field class from the encoded signature

    Args:
        data (bytes): The bytestring starting with the Signature

    Returns:
        Tuple[ Ed25519SignatureField , bytes ]: signature, remainder of the data
    &#34;&#34;&#34;
    signature, data = cls.decode(data)

    return cls(private_key=None, signature=signature), data</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.Ed25519SignatureField.sign"><code class="name flex">
<span>def <span class="ident">sign</span></span>(<span>self, data: bytes, **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Signs the provided data with the provided private key</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The data to be signed</dd>
<dt><strong><code>hash_alg</code></strong> :&ensp;<code>RsaAlgs</code>, optional</dt>
<dd>The RSA algorithm to use for hashing.
Defaults to RsaAlgs.SHA256.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sign(self, data: bytes, **kwargs) -&gt; None:
    &#34;&#34;&#34;
    Signs the provided data with the provided private key

    Args:
        data (bytes): The data to be signed
        hash_alg (RsaAlgs, optional): The RSA algorithm to use for hashing.
                                       Defaults to RsaAlgs.SHA256.
    &#34;&#34;&#34;
    self.value = self.private_key.sign(data)
    self.is_signed = True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.SignatureField" href="#sshkey_tools.fields.SignatureField">SignatureField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.SignatureField.DATA_TYPE" href="#sshkey_tools.fields.SignatureField.DATA_TYPE">DATA_TYPE</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.can_sign" href="#sshkey_tools.fields.SignatureField.can_sign">can_sign</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.factory" href="#sshkey_tools.fields.CertificateField.factory">factory</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.from_object" href="#sshkey_tools.fields.SignatureField.from_object">from_object</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.get_name" href="#sshkey_tools.fields.CertificateField.get_name">get_name</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.ExtensionsField"><code class="flex name class">
<span>class <span class="ident">ExtensionsField</span></span>
<span>(</span><span>value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains a list of extensions for the certificate,
set to give the user limitations and/or additional
privileges on the host.</p>
<p>flags:
no-touch-required
The user doesn't need to touch the
physical key to authenticate.</p>
<pre><code>permit-X11-forwarding
    Permits the user to use X11 Forwarding

permit-agent-forwarding
    Permits the user to use agent forwarding

permit-port-forwarding
    Permits the user to forward ports

permit-pty
    Permits the user to use a pseudo-terminal

permit-user-rc
    Permits the user to use the user rc file
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExtensionsField(KeyValueField):
    &#34;&#34;&#34;
    Contains a list of extensions for the certificate,
    set to give the user limitations and/or additional
    privileges on the host.

    flags:
        no-touch-required
            The user doesn&#39;t need to touch the
            physical key to authenticate.

        permit-X11-forwarding
            Permits the user to use X11 Forwarding

        permit-agent-forwarding
            Permits the user to use agent forwarding

        permit-port-forwarding
            Permits the user to forward ports

        permit-pty
            Permits the user to use a pseudo-terminal

        permit-user-rc
            Permits the user to use the user rc file

    &#34;&#34;&#34;

    DEFAULT = []
    DATA_TYPE = (list, set, tuple, dict)
    ALLOWED_VALUES = (
        &#34;no-touch-required&#34;,
        &#34;permit-X11-forwarding&#34;,
        &#34;permit-agent-forwarding&#34;,
        &#34;permit-port-forwarding&#34;,
        &#34;permit-pty&#34;,
        &#34;permit-user-rc&#34;,
    )

    def __validate_value__(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the contents of the field
        &#34;&#34;&#34;
        if isinstance(self.__validate_type__(self.value), Exception):
            return _EX.InvalidFieldDataException(
                f&#34;{self.get_name()} Could not validate value, invalid type&#34;
            )

        for item in self.value:
            if item not in self.ALLOWED_VALUES:
                return _EX.InvalidDataException(
                    f&#34;Invalid extension &#39;{item}&#39;{NEWLINE}&#34;
                    + f&#34;Allowed values are: {NEWLINE.join(self.ALLOWED_VALUES)}&#34;
                )

        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.KeyValueField" href="#sshkey_tools.fields.KeyValueField">KeyValueField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sshkey_tools.fields.ExtensionsField.ALLOWED_VALUES"><code class="name">var <span class="ident">ALLOWED_VALUES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sshkey_tools.fields.ExtensionsField.DATA_TYPE"><code class="name">var <span class="ident">DATA_TYPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sshkey_tools.fields.ExtensionsField.DEFAULT"><code class="name">var <span class="ident">DEFAULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.KeyValueField" href="#sshkey_tools.fields.KeyValueField">KeyValueField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.KeyValueField.decode" href="#sshkey_tools.fields.KeyValueField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.KeyValueField.encode" href="#sshkey_tools.fields.KeyValueField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.KeyValueField.factory" href="#sshkey_tools.fields.CertificateField.factory">factory</a></code></li>
<li><code><a title="sshkey_tools.fields.KeyValueField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.KeyValueField.get_name" href="#sshkey_tools.fields.CertificateField.get_name">get_name</a></code></li>
<li><code><a title="sshkey_tools.fields.KeyValueField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.Integer32Field"><code class="flex name class">
<span>class <span class="ident">Integer32Field</span></span>
<span>(</span><span>value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Certificate field representing a 32-bit integer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Integer32Field(CertificateField):
    &#34;&#34;&#34;
    Certificate field representing a 32-bit integer
    &#34;&#34;&#34;

    DATA_TYPE = int
    DEFAULT = 0

    @classmethod
    def encode(cls, value: int) -&gt; bytes:
        &#34;&#34;&#34;Encodes a 32-bit integer value to a packed byte string

        Args:
            source_int (int): Integer to be packed

        Returns:
            bytes: Packed byte string containing integer
        &#34;&#34;&#34;
        cls.__validate_type__(value, True)
        return pack(&#34;&gt;I&#34;, value)

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[int, bytes]:
        &#34;&#34;&#34;Decodes a 32-bit integer from a block of bytes

        Args:
            data (bytes): Block of bytes containing an integer

        Returns:
            tuple: Tuple with integer and remainder of data
        &#34;&#34;&#34;
        return int(unpack(&#34;&gt;I&#34;, data[:4])[0]), data[4:]

    def __validate_value__(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the contents of the field
        &#34;&#34;&#34;
        if isinstance(self.__validate_type__(self.value), Exception):
            return _EX.InvalidFieldDataException(
                f&#34;{self.get_name()} Could not validate value, invalid type&#34;
            )

        if self.value &lt; MAX_INT32:
            return True

        return _EX.InvalidFieldDataException(
            f&#34;{self.get_name()} must be a 32-bit integer&#34;
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.CertificateTypeField" href="#sshkey_tools.fields.CertificateTypeField">CertificateTypeField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sshkey_tools.fields.Integer32Field.DATA_TYPE"><code class="name">var <span class="ident">DATA_TYPE</span></code></dt>
<dd>
<div class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></div>
</dd>
<dt id="sshkey_tools.fields.Integer32Field.DEFAULT"><code class="name">var <span class="ident">DEFAULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.Integer32Field.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data: bytes) ‑> Tuple[int, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes a 32-bit integer from a block of bytes</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>Block of bytes containing an integer</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>Tuple with integer and remainder of data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; Tuple[int, bytes]:
    &#34;&#34;&#34;Decodes a 32-bit integer from a block of bytes

    Args:
        data (bytes): Block of bytes containing an integer

    Returns:
        tuple: Tuple with integer and remainder of data
    &#34;&#34;&#34;
    return int(unpack(&#34;&gt;I&#34;, data[:4])[0]), data[4:]</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.Integer32Field.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>value: int) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes a 32-bit integer value to a packed byte string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source_int</code></strong> :&ensp;<code>int</code></dt>
<dd>Integer to be packed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>Packed byte string containing integer</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def encode(cls, value: int) -&gt; bytes:
    &#34;&#34;&#34;Encodes a 32-bit integer value to a packed byte string

    Args:
        source_int (int): Integer to be packed

    Returns:
        bytes: Packed byte string containing integer
    &#34;&#34;&#34;
    cls.__validate_type__(value, True)
    return pack(&#34;&gt;I&#34;, value)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.CertificateField.factory" href="#sshkey_tools.fields.CertificateField.factory">factory</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.get_name" href="#sshkey_tools.fields.CertificateField.get_name">get_name</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.Integer64Field"><code class="flex name class">
<span>class <span class="ident">Integer64Field</span></span>
<span>(</span><span>value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Certificate field representing a 64-bit integer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Integer64Field(CertificateField):
    &#34;&#34;&#34;
    Certificate field representing a 64-bit integer
    &#34;&#34;&#34;

    DATA_TYPE = int
    DEFAULT = 0

    @classmethod
    def encode(cls, value: int) -&gt; bytes:
        &#34;&#34;&#34;Encodes a 64-bit integer value to a packed byte string

        Args:
            source_int (int): Integer to be packed

        Returns:
            bytes: Packed byte string containing integer
        &#34;&#34;&#34;
        cls.__validate_type__(value, True)
        return pack(&#34;&gt;Q&#34;, value)

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[int, bytes]:
        &#34;&#34;&#34;Decodes a 64-bit integer from a block of bytes

        Args:
            data (bytes): Block of bytes containing an integer

        Returns:
            tuple: Tuple with integer and remainder of data
        &#34;&#34;&#34;
        return int(unpack(&#34;&gt;Q&#34;, data[:8])[0]), data[8:]

    def __validate_value__(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the contents of the field
        &#34;&#34;&#34;
        if isinstance(self.__validate_type__(self.value), Exception):
            return _EX.InvalidFieldDataException(
                f&#34;{self.get_name()} Could not validate value, invalid type&#34;
            )

        if self.value &lt; MAX_INT64:
            return True

        return _EX.InvalidFieldDataException(
            f&#34;{self.get_name()} must be a 64-bit integer&#34;
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.DateTimeField" href="#sshkey_tools.fields.DateTimeField">DateTimeField</a></li>
<li><a title="sshkey_tools.fields.SerialField" href="#sshkey_tools.fields.SerialField">SerialField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sshkey_tools.fields.Integer64Field.DATA_TYPE"><code class="name">var <span class="ident">DATA_TYPE</span></code></dt>
<dd>
<div class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></div>
</dd>
<dt id="sshkey_tools.fields.Integer64Field.DEFAULT"><code class="name">var <span class="ident">DEFAULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.Integer64Field.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data: bytes) ‑> Tuple[int, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes a 64-bit integer from a block of bytes</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>Block of bytes containing an integer</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>Tuple with integer and remainder of data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; Tuple[int, bytes]:
    &#34;&#34;&#34;Decodes a 64-bit integer from a block of bytes

    Args:
        data (bytes): Block of bytes containing an integer

    Returns:
        tuple: Tuple with integer and remainder of data
    &#34;&#34;&#34;
    return int(unpack(&#34;&gt;Q&#34;, data[:8])[0]), data[8:]</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.Integer64Field.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>value: int) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes a 64-bit integer value to a packed byte string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source_int</code></strong> :&ensp;<code>int</code></dt>
<dd>Integer to be packed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>Packed byte string containing integer</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def encode(cls, value: int) -&gt; bytes:
    &#34;&#34;&#34;Encodes a 64-bit integer value to a packed byte string

    Args:
        source_int (int): Integer to be packed

    Returns:
        bytes: Packed byte string containing integer
    &#34;&#34;&#34;
    cls.__validate_type__(value, True)
    return pack(&#34;&gt;Q&#34;, value)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.CertificateField.factory" href="#sshkey_tools.fields.CertificateField.factory">factory</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.get_name" href="#sshkey_tools.fields.CertificateField.get_name">get_name</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.KeyIdField"><code class="flex name class">
<span>class <span class="ident">KeyIdField</span></span>
<span>(</span><span>value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains the key identifier (subject) of the certificate,
alphanumeric string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KeyIdField(StringField):
    &#34;&#34;&#34;
    Contains the key identifier (subject) of the certificate,
    alphanumeric string
    &#34;&#34;&#34;

    DEFAULT = random_keyid
    DATA_TYPE = (str, bytes)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.StringField" href="#sshkey_tools.fields.StringField">StringField</a></li>
<li><a title="sshkey_tools.fields.BytestringField" href="#sshkey_tools.fields.BytestringField">BytestringField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sshkey_tools.fields.KeyIdField.DATA_TYPE"><code class="name">var <span class="ident">DATA_TYPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.KeyIdField.DEFAULT"><code class="name flex">
<span>def <span class="ident">DEFAULT</span></span>(<span>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a random Key ID</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Random keyid</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def random_keyid() -&gt; str:
    &#34;&#34;&#34;Generates a random Key ID

    Returns:
        str: Random keyid
    &#34;&#34;&#34;
    return str(uuid4())</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.StringField" href="#sshkey_tools.fields.StringField">StringField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.StringField.decode" href="#sshkey_tools.fields.BytestringField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.StringField.encode" href="#sshkey_tools.fields.BytestringField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.StringField.factory" href="#sshkey_tools.fields.CertificateField.factory">factory</a></code></li>
<li><code><a title="sshkey_tools.fields.StringField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.StringField.get_name" href="#sshkey_tools.fields.CertificateField.get_name">get_name</a></code></li>
<li><code><a title="sshkey_tools.fields.StringField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.KeyValueField"><code class="flex name class">
<span>class <span class="ident">KeyValueField</span></span>
<span>(</span><span>value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Certificate field representing a list or integer in python,
separated in byte-form by null-bytes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KeyValueField(CertificateField):
    &#34;&#34;&#34;
    Certificate field representing a list or integer in python,
    separated in byte-form by null-bytes.
    &#34;&#34;&#34;

    DATA_TYPE = (list, tuple, set, dict)
    DEFAULT = {}

    @classmethod
    def encode(cls, value: Union[list, tuple, dict, set]) -&gt; bytes:
        &#34;&#34;&#34;
        Encodes a dict, set, list or tuple into a key-value byte string.
        If a set, list or tuple is provided, the items are considered keys
        and added with empty values.

        Args:
            source_list (dict, set, list, tuple): list of strings

        Returns:
            bytes: Packed byte string containing the source data
        &#34;&#34;&#34;
        cls.__validate_type__(value, True)

        if not isinstance(value, dict):
            value = {item: &#34;&#34; for item in value}

        list_data = b&#34;&#34;

        for key, item in value.items():
            list_data += StringField.encode(key)

            item = (
                StringField.encode(&#34;&#34;)
                if item in [&#34;&#34;, b&#34;&#34;]
                else ListField.encode(
                    [item] if isinstance(item, (str, bytes)) else item
                )
            )

            list_data += item

        return BytestringField.encode(list_data)

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[dict, bytes]:
        &#34;&#34;&#34;Decodes a list of strings from a block of bytes

        Args:
            data (bytes): The block of bytes containing a list of strings
        Returns:
            tuple: _description_
        &#34;&#34;&#34;
        list_bytes, data = BytestringField.decode(data)

        decoded = {}
        while len(list_bytes) &gt; 0:
            key, list_bytes = StringField.decode(list_bytes)
            value, list_bytes = BytestringField.decode(list_bytes)

            if value != b&#34;&#34;:
                value = StringField.decode(value)[0]

            decoded[key] = value

        decoded = ensure_string(decoded)

        if &#34;&#34;.join(decoded.values()) == &#34;&#34;:
            return list(decoded.keys()), data

        return decoded, data

    def __validate_value__(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the contents of the field
        &#34;&#34;&#34;
        if isinstance(self.__validate_type__(self.value), Exception):
            return _EX.InvalidFieldDataException(
                f&#34;{self.get_name()} Could not validate value, invalid type&#34;
            )

        testvals = (
            self.value
            if not isinstance(self.value, dict)
            else list(self.value.keys()) + list(self.value.values())
        )

        if hasattr(self.value, &#34;__iter__&#34;) and not all(
            (isinstance(val, (str, bytes)) for val in testvals)
        ):
            return _EX.InvalidFieldDataException(
                &#34;Expected dict, list, tuple, set with string or byte keys and values&#34;
            )

        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.CriticalOptionsField" href="#sshkey_tools.fields.CriticalOptionsField">CriticalOptionsField</a></li>
<li><a title="sshkey_tools.fields.ExtensionsField" href="#sshkey_tools.fields.ExtensionsField">ExtensionsField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sshkey_tools.fields.KeyValueField.DATA_TYPE"><code class="name">var <span class="ident">DATA_TYPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sshkey_tools.fields.KeyValueField.DEFAULT"><code class="name">var <span class="ident">DEFAULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.KeyValueField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data: bytes) ‑> Tuple[dict, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes a list of strings from a block of bytes</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The block of bytes containing a list of strings</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd><em>description</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; Tuple[dict, bytes]:
    &#34;&#34;&#34;Decodes a list of strings from a block of bytes

    Args:
        data (bytes): The block of bytes containing a list of strings
    Returns:
        tuple: _description_
    &#34;&#34;&#34;
    list_bytes, data = BytestringField.decode(data)

    decoded = {}
    while len(list_bytes) &gt; 0:
        key, list_bytes = StringField.decode(list_bytes)
        value, list_bytes = BytestringField.decode(list_bytes)

        if value != b&#34;&#34;:
            value = StringField.decode(value)[0]

        decoded[key] = value

    decoded = ensure_string(decoded)

    if &#34;&#34;.join(decoded.values()) == &#34;&#34;:
        return list(decoded.keys()), data

    return decoded, data</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.KeyValueField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>value: Union[list, tuple, dict, set]) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes a dict, set, list or tuple into a key-value byte string.
If a set, list or tuple is provided, the items are considered keys
and added with empty values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source_list</code></strong> :&ensp;<code>dict, set, list, tuple</code></dt>
<dd>list of strings</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>Packed byte string containing the source data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def encode(cls, value: Union[list, tuple, dict, set]) -&gt; bytes:
    &#34;&#34;&#34;
    Encodes a dict, set, list or tuple into a key-value byte string.
    If a set, list or tuple is provided, the items are considered keys
    and added with empty values.

    Args:
        source_list (dict, set, list, tuple): list of strings

    Returns:
        bytes: Packed byte string containing the source data
    &#34;&#34;&#34;
    cls.__validate_type__(value, True)

    if not isinstance(value, dict):
        value = {item: &#34;&#34; for item in value}

    list_data = b&#34;&#34;

    for key, item in value.items():
        list_data += StringField.encode(key)

        item = (
            StringField.encode(&#34;&#34;)
            if item in [&#34;&#34;, b&#34;&#34;]
            else ListField.encode(
                [item] if isinstance(item, (str, bytes)) else item
            )
        )

        list_data += item

    return BytestringField.encode(list_data)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.CertificateField.factory" href="#sshkey_tools.fields.CertificateField.factory">factory</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.get_name" href="#sshkey_tools.fields.CertificateField.get_name">get_name</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.ListField"><code class="flex name class">
<span>class <span class="ident">ListField</span></span>
<span>(</span><span>value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Certificate field representing a list or tuple of strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ListField(CertificateField):
    &#34;&#34;&#34;
    Certificate field representing a list or tuple of strings
    &#34;&#34;&#34;

    DATA_TYPE = (list, set, tuple)
    DEFAULT = []

    @classmethod
    def encode(cls, value: Union[list, tuple, set]) -&gt; bytes:
        &#34;&#34;&#34;Encodes a list or tuple to a byte string

        Args:
            source_list (list): list of strings
            null_separator (bool, optional): Insert blank string string between items. Default None

        Returns:
            bytes: Packed byte string containing the source data
        &#34;&#34;&#34;
        cls.__validate_type__(value, True)

        try:
            if sum(not isinstance(item, (str, bytes)) for item in value) &gt; 0:
                raise TypeError
        except TypeError:
            raise _EX.InvalidFieldDataException(
                &#34;Expected list or tuple containing strings or bytes&#34;
            ) from TypeError

        return BytestringField.encode(b&#34;&#34;.join([StringField.encode(x) for x in value]))

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[list, bytes]:
        &#34;&#34;&#34;Decodes a list of strings from a block of bytes

        Args:
            data (bytes): The block of bytes containing a list of strings
        Returns:
            tuple: _description_
        &#34;&#34;&#34;
        list_bytes, data = BytestringField.decode(data)

        decoded = []
        while len(list_bytes) &gt; 0:
            elem, list_bytes = StringField.decode(list_bytes)
            decoded.append(elem)

        return ensure_string(decoded), data

    def __validate_value__(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the contents of the field
        &#34;&#34;&#34;
        if isinstance(self.__validate_type__(self.value), Exception):
            return _EX.InvalidFieldDataException(
                f&#34;{self.get_name()} Could not validate value, invalid type&#34;
            )

        if hasattr(self.value, &#34;__iter__&#34;) and not all(
            (isinstance(val, (str, bytes)) for val in self.value)
        ):
            return _EX.InvalidFieldDataException(
                &#34;Expected list or tuple containing strings or bytes&#34;
            )
        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.PrincipalsField" href="#sshkey_tools.fields.PrincipalsField">PrincipalsField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sshkey_tools.fields.ListField.DATA_TYPE"><code class="name">var <span class="ident">DATA_TYPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sshkey_tools.fields.ListField.DEFAULT"><code class="name">var <span class="ident">DEFAULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.ListField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data: bytes) ‑> Tuple[list, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes a list of strings from a block of bytes</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The block of bytes containing a list of strings</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd><em>description</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; Tuple[list, bytes]:
    &#34;&#34;&#34;Decodes a list of strings from a block of bytes

    Args:
        data (bytes): The block of bytes containing a list of strings
    Returns:
        tuple: _description_
    &#34;&#34;&#34;
    list_bytes, data = BytestringField.decode(data)

    decoded = []
    while len(list_bytes) &gt; 0:
        elem, list_bytes = StringField.decode(list_bytes)
        decoded.append(elem)

    return ensure_string(decoded), data</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.ListField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>value: Union[list, tuple, set]) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes a list or tuple to a byte string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source_list</code></strong> :&ensp;<code>list</code></dt>
<dd>list of strings</dd>
<dt><strong><code>null_separator</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Insert blank string string between items. Default None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>Packed byte string containing the source data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def encode(cls, value: Union[list, tuple, set]) -&gt; bytes:
    &#34;&#34;&#34;Encodes a list or tuple to a byte string

    Args:
        source_list (list): list of strings
        null_separator (bool, optional): Insert blank string string between items. Default None

    Returns:
        bytes: Packed byte string containing the source data
    &#34;&#34;&#34;
    cls.__validate_type__(value, True)

    try:
        if sum(not isinstance(item, (str, bytes)) for item in value) &gt; 0:
            raise TypeError
    except TypeError:
        raise _EX.InvalidFieldDataException(
            &#34;Expected list or tuple containing strings or bytes&#34;
        ) from TypeError

    return BytestringField.encode(b&#34;&#34;.join([StringField.encode(x) for x in value]))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.CertificateField.factory" href="#sshkey_tools.fields.CertificateField.factory">factory</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.get_name" href="#sshkey_tools.fields.CertificateField.get_name">get_name</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.MpIntegerField"><code class="flex name class">
<span>class <span class="ident">MpIntegerField</span></span>
<span>(</span><span>value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Certificate field representing a multiple precision integer,
an integer too large to fit in 64 bits.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MpIntegerField(BytestringField):
    &#34;&#34;&#34;
    Certificate field representing a multiple precision integer,
    an integer too large to fit in 64 bits.
    &#34;&#34;&#34;

    DATA_TYPE = int
    DEFAULT = 0

    @classmethod
    def encode(cls, value: int) -&gt; bytes:
        &#34;&#34;&#34;
        Encodes a multiprecision integer (integer larger than 64bit)
        into a packed byte string

        Args:
            value (int): Large integer

        Returns:
            bytes: Packed byte string containing integer
        &#34;&#34;&#34;
        cls.__validate_type__(value, True)
        return BytestringField.encode(long_to_bytes(value))

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[int, bytes]:
        &#34;&#34;&#34;Decodes a multiprecision integer (integer larger than 64bit)

        Args:
            data (bytes): Block of bytes containing a long (mp) integer

        Returns:
            tuple: Tuple with integer and remainder of data
        &#34;&#34;&#34;
        mpint, data = BytestringField.decode(data)
        return bytes_to_long(mpint), data</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.BytestringField" href="#sshkey_tools.fields.BytestringField">BytestringField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sshkey_tools.fields.MpIntegerField.DATA_TYPE"><code class="name">var <span class="ident">DATA_TYPE</span></code></dt>
<dd>
<div class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></div>
</dd>
<dt id="sshkey_tools.fields.MpIntegerField.DEFAULT"><code class="name">var <span class="ident">DEFAULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.MpIntegerField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data: bytes) ‑> Tuple[int, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes a multiprecision integer (integer larger than 64bit)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>Block of bytes containing a long (mp) integer</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>Tuple with integer and remainder of data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; Tuple[int, bytes]:
    &#34;&#34;&#34;Decodes a multiprecision integer (integer larger than 64bit)

    Args:
        data (bytes): Block of bytes containing a long (mp) integer

    Returns:
        tuple: Tuple with integer and remainder of data
    &#34;&#34;&#34;
    mpint, data = BytestringField.decode(data)
    return bytes_to_long(mpint), data</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.MpIntegerField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>value: int) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes a multiprecision integer (integer larger than 64bit)
into a packed byte string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code></dt>
<dd>Large integer</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>Packed byte string containing integer</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def encode(cls, value: int) -&gt; bytes:
    &#34;&#34;&#34;
    Encodes a multiprecision integer (integer larger than 64bit)
    into a packed byte string

    Args:
        value (int): Large integer

    Returns:
        bytes: Packed byte string containing integer
    &#34;&#34;&#34;
    cls.__validate_type__(value, True)
    return BytestringField.encode(long_to_bytes(value))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.BytestringField" href="#sshkey_tools.fields.BytestringField">BytestringField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.BytestringField.factory" href="#sshkey_tools.fields.CertificateField.factory">factory</a></code></li>
<li><code><a title="sshkey_tools.fields.BytestringField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.BytestringField.get_name" href="#sshkey_tools.fields.CertificateField.get_name">get_name</a></code></li>
<li><code><a title="sshkey_tools.fields.BytestringField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.NonceField"><code class="flex name class">
<span>class <span class="ident">NonceField</span></span>
<span>(</span><span>value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains the nonce for the certificate, randomly generated
this protects the integrity of the private key, especially
for ecdsa.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NonceField(StringField):
    &#34;&#34;&#34;
    Contains the nonce for the certificate, randomly generated
    this protects the integrity of the private key, especially
    for ecdsa.
    &#34;&#34;&#34;

    DEFAULT = generate_secure_nonce
    DATA_TYPE = (str, bytes)

    def __validate_value__(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the contents of the field
        &#34;&#34;&#34;
        if isinstance(self.__validate_type__(self.value), Exception):
            return _EX.InvalidFieldDataException(
                f&#34;{self.get_name()} Could not validate value, invalid type&#34;
            )

        if hasattr(self.value, &#34;__count__&#34;) and len(self.value) &lt; 32:
            return _EX.InvalidFieldDataException(
                &#34;Expected a nonce of at least 32 bytes&#34;
            )

        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.StringField" href="#sshkey_tools.fields.StringField">StringField</a></li>
<li><a title="sshkey_tools.fields.BytestringField" href="#sshkey_tools.fields.BytestringField">BytestringField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sshkey_tools.fields.NonceField.DATA_TYPE"><code class="name">var <span class="ident">DATA_TYPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.NonceField.DEFAULT"><code class="name flex">
<span>def <span class="ident">DEFAULT</span></span>(<span>length: int = 128)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a secure random nonce of the specified length.
Mainly important for ECDSA keys, but is used with all key/certificate types
<a href="https://blog.trailofbits.com/2020/06/11/ecdsa-handle-with-care/">https://blog.trailofbits.com/2020/06/11/ecdsa-handle-with-care/</a>
<a href="https://datatracker.ietf.org/doc/html/rfc6979">https://datatracker.ietf.org/doc/html/rfc6979</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>length</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Length of the nonce. Defaults to 64.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Nonce of the specified length</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_secure_nonce(length: int = 128):
    &#34;&#34;&#34;Generates a secure random nonce of the specified length.
        Mainly important for ECDSA keys, but is used with all key/certificate types
        https://blog.trailofbits.com/2020/06/11/ecdsa-handle-with-care/
        https://datatracker.ietf.org/doc/html/rfc6979
    Args:
        length (int, optional): Length of the nonce. Defaults to 64.

    Returns:
        str: Nonce of the specified length
    &#34;&#34;&#34;
    return str(randbits(length))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.StringField" href="#sshkey_tools.fields.StringField">StringField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.StringField.decode" href="#sshkey_tools.fields.BytestringField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.StringField.encode" href="#sshkey_tools.fields.BytestringField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.StringField.factory" href="#sshkey_tools.fields.CertificateField.factory">factory</a></code></li>
<li><code><a title="sshkey_tools.fields.StringField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.StringField.get_name" href="#sshkey_tools.fields.CertificateField.get_name">get_name</a></code></li>
<li><code><a title="sshkey_tools.fields.StringField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.PrincipalsField"><code class="flex name class">
<span>class <span class="ident">PrincipalsField</span></span>
<span>(</span><span>value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains a list of principals for the certificate,
e.g. SERVERHOSTNAME01 or all-web-servers.
If no principals are added, the certificate is valid
only for servers that have no allowed principals specified</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PrincipalsField(ListField):
    &#34;&#34;&#34;
    Contains a list of principals for the certificate,
    e.g. SERVERHOSTNAME01 or all-web-servers.
    If no principals are added, the certificate is valid
    only for servers that have no allowed principals specified
    &#34;&#34;&#34;

    DEFAFULT = []
    DATA_TYPE = (list, set, tuple)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.ListField" href="#sshkey_tools.fields.ListField">ListField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sshkey_tools.fields.PrincipalsField.DATA_TYPE"><code class="name">var <span class="ident">DATA_TYPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sshkey_tools.fields.PrincipalsField.DEFAFULT"><code class="name">var <span class="ident">DEFAFULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.ListField" href="#sshkey_tools.fields.ListField">ListField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.ListField.decode" href="#sshkey_tools.fields.ListField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.ListField.encode" href="#sshkey_tools.fields.ListField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.ListField.factory" href="#sshkey_tools.fields.CertificateField.factory">factory</a></code></li>
<li><code><a title="sshkey_tools.fields.ListField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.ListField.get_name" href="#sshkey_tools.fields.CertificateField.get_name">get_name</a></code></li>
<li><code><a title="sshkey_tools.fields.ListField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.PubkeyTypeField"><code class="flex name class">
<span>class <span class="ident">PubkeyTypeField</span></span>
<span>(</span><span>value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains the certificate type, which is based on the
public key type the certificate is created for, e.g.
'ssh-ed25519-cert-v01@openssh.com' for an ED25519 key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PubkeyTypeField(StringField):
    &#34;&#34;&#34;
    Contains the certificate type, which is based on the
    public key type the certificate is created for, e.g.
    &#39;ssh-ed25519-cert-v01@openssh.com&#39; for an ED25519 key
    &#34;&#34;&#34;

    DEFAULT = None
    DATA_TYPE = (str, bytes)
    ALLOWED_VALUES = (
        &#34;ssh-rsa-cert-v01@openssh.com&#34;,
        &#34;rsa-sha2-256-cert-v01@openssh.com&#34;,
        &#34;rsa-sha2-512-cert-v01@openssh.com&#34;,
        &#34;ssh-dss-cert-v01@openssh.com&#34;,
        &#34;ecdsa-sha2-nistp256-cert-v01@openssh.com&#34;,
        &#34;ecdsa-sha2-nistp384-cert-v01@openssh.com&#34;,
        &#34;ecdsa-sha2-nistp521-cert-v01@openssh.com&#34;,
        &#34;ssh-ed25519-cert-v01@openssh.com&#34;,
    )

    def __validate_value__(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the contents of the field
        &#34;&#34;&#34;
        if isinstance(self.__validate_type__(self.value), Exception):
            return _EX.InvalidFieldDataException(
                f&#34;{self.get_name()} Could not validate value, invalid type&#34;
            )

        if ensure_string(self.value) not in self.ALLOWED_VALUES:
            return _EX.InvalidFieldDataException(
                &#34;Expected one of the following values: &#34;
                + NEWLINE.join(self.ALLOWED_VALUES)
            )

        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.StringField" href="#sshkey_tools.fields.StringField">StringField</a></li>
<li><a title="sshkey_tools.fields.BytestringField" href="#sshkey_tools.fields.BytestringField">BytestringField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sshkey_tools.fields.PubkeyTypeField.ALLOWED_VALUES"><code class="name">var <span class="ident">ALLOWED_VALUES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sshkey_tools.fields.PubkeyTypeField.DATA_TYPE"><code class="name">var <span class="ident">DATA_TYPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sshkey_tools.fields.PubkeyTypeField.DEFAULT"><code class="name">var <span class="ident">DEFAULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.StringField" href="#sshkey_tools.fields.StringField">StringField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.StringField.decode" href="#sshkey_tools.fields.BytestringField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.StringField.encode" href="#sshkey_tools.fields.BytestringField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.StringField.factory" href="#sshkey_tools.fields.CertificateField.factory">factory</a></code></li>
<li><code><a title="sshkey_tools.fields.StringField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.StringField.get_name" href="#sshkey_tools.fields.CertificateField.get_name">get_name</a></code></li>
<li><code><a title="sshkey_tools.fields.StringField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.PublicKeyField"><code class="flex name class">
<span>class <span class="ident">PublicKeyField</span></span>
<span>(</span><span>value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains the subject (User or Host) public key for whom/which
the certificate is created.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PublicKeyField(CertificateField):
    &#34;&#34;&#34;
    Contains the subject (User or Host) public key for whom/which
    the certificate is created.
    &#34;&#34;&#34;

    DEFAULT = None
    DATA_TYPE = PublicKey

    def __table__(self) -&gt; tuple:
        return [str(self.name), str(self.value.get_fingerprint())]

    def __str__(self) -&gt; str:
        return &#34; &#34;.join(
            [
                self.__class__.__name__.replace(&#34;PubkeyField&#34;, &#34;&#34;),
                self.value.get_fingerprint(),
            ]
        )

    @classmethod
    def encode(cls, value: PublicKey) -&gt; bytes:
        &#34;&#34;&#34;
        Encode the certificate field to a byte string

        Args:
            value (RsaPublicKey): The public key to encode

        Returns:
            bytes: A byte string with the encoded public key
        &#34;&#34;&#34;
        cls.__validate_type__(value, True)
        return BytestringField.decode(value.raw_bytes())[1]

    @staticmethod
    def from_object(public_key: PublicKey):
        &#34;&#34;&#34;
        Loads the public key from a sshkey_tools.keys.PublicKey
        class or childclass

        Args:
            public_key (PublicKey): The public key for which to
                                    create the certificate

        Raises:
            _EX.InvalidKeyException: Invalid public key

        Returns:
            PublicKeyField: A child class of PublicKeyField specific
                            to the chosen public key
        &#34;&#34;&#34;
        try:
            return globals()[SUBJECT_PUBKEY_MAP[public_key.__class__]](value=public_key)
        except KeyError:
            raise _EX.InvalidKeyException(&#34;The public key is invalid&#34;) from KeyError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.DsaPubkeyField" href="#sshkey_tools.fields.DsaPubkeyField">DsaPubkeyField</a></li>
<li><a title="sshkey_tools.fields.EcdsaPubkeyField" href="#sshkey_tools.fields.EcdsaPubkeyField">EcdsaPubkeyField</a></li>
<li><a title="sshkey_tools.fields.Ed25519PubkeyField" href="#sshkey_tools.fields.Ed25519PubkeyField">Ed25519PubkeyField</a></li>
<li><a title="sshkey_tools.fields.RsaPubkeyField" href="#sshkey_tools.fields.RsaPubkeyField">RsaPubkeyField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sshkey_tools.fields.PublicKeyField.DATA_TYPE"><code class="name">var <span class="ident">DATA_TYPE</span></code></dt>
<dd>
<div class="desc"><p>Class for handling SSH public keys</p></div>
</dd>
<dt id="sshkey_tools.fields.PublicKeyField.DEFAULT"><code class="name">var <span class="ident">DEFAULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.PublicKeyField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>value: <a title="sshkey_tools.keys.PublicKey" href="keys.html#sshkey_tools.keys.PublicKey">PublicKey</a>) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encode the certificate field to a byte string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>RsaPublicKey</code></dt>
<dd>The public key to encode</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>A byte string with the encoded public key</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def encode(cls, value: PublicKey) -&gt; bytes:
    &#34;&#34;&#34;
    Encode the certificate field to a byte string

    Args:
        value (RsaPublicKey): The public key to encode

    Returns:
        bytes: A byte string with the encoded public key
    &#34;&#34;&#34;
    cls.__validate_type__(value, True)
    return BytestringField.decode(value.raw_bytes())[1]</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.PublicKeyField.from_object"><code class="name flex">
<span>def <span class="ident">from_object</span></span>(<span>public_key: <a title="sshkey_tools.keys.PublicKey" href="keys.html#sshkey_tools.keys.PublicKey">PublicKey</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads the public key from a sshkey_tools.keys.PublicKey
class or childclass</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>public_key</code></strong> :&ensp;<code>PublicKey</code></dt>
<dd>The public key for which to
create the certificate</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>_EX.InvalidKeyException</code></dt>
<dd>Invalid public key</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sshkey_tools.fields.PublicKeyField" href="#sshkey_tools.fields.PublicKeyField">PublicKeyField</a></code></dt>
<dd>A child class of PublicKeyField specific
to the chosen public key</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_object(public_key: PublicKey):
    &#34;&#34;&#34;
    Loads the public key from a sshkey_tools.keys.PublicKey
    class or childclass

    Args:
        public_key (PublicKey): The public key for which to
                                create the certificate

    Raises:
        _EX.InvalidKeyException: Invalid public key

    Returns:
        PublicKeyField: A child class of PublicKeyField specific
                        to the chosen public key
    &#34;&#34;&#34;
    try:
        return globals()[SUBJECT_PUBKEY_MAP[public_key.__class__]](value=public_key)
    except KeyError:
        raise _EX.InvalidKeyException(&#34;The public key is invalid&#34;) from KeyError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.CertificateField.decode" href="#sshkey_tools.fields.CertificateField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.factory" href="#sshkey_tools.fields.CertificateField.factory">factory</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.get_name" href="#sshkey_tools.fields.CertificateField.get_name">get_name</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.ReservedField"><code class="flex name class">
<span>class <span class="ident">ReservedField</span></span>
<span>(</span><span>value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This field is reserved for future use, and
doesn't contain any actual data, just an empty string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReservedField(StringField):
    &#34;&#34;&#34;
    This field is reserved for future use, and
    doesn&#39;t contain any actual data, just an empty string.
    &#34;&#34;&#34;

    DEFAULT = &#34;&#34;
    DATA_TYPE = str

    def __validate_value__(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the contents of the field
        &#34;&#34;&#34;
        if isinstance(self.__validate_type__(self.value), Exception):
            return _EX.InvalidFieldDataException(
                f&#34;{self.get_name()} Could not validate value, invalid type&#34;
            )

        return (
            True
            if self.value == &#34;&#34;
            else _EX.InvalidDataException(&#34;The reserved field is not empty&#34;)
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.StringField" href="#sshkey_tools.fields.StringField">StringField</a></li>
<li><a title="sshkey_tools.fields.BytestringField" href="#sshkey_tools.fields.BytestringField">BytestringField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sshkey_tools.fields.ReservedField.DATA_TYPE"><code class="name">var <span class="ident">DATA_TYPE</span></code></dt>
<dd>
<div class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></div>
</dd>
<dt id="sshkey_tools.fields.ReservedField.DEFAULT"><code class="name">var <span class="ident">DEFAULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.StringField" href="#sshkey_tools.fields.StringField">StringField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.StringField.decode" href="#sshkey_tools.fields.BytestringField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.StringField.encode" href="#sshkey_tools.fields.BytestringField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.StringField.factory" href="#sshkey_tools.fields.CertificateField.factory">factory</a></code></li>
<li><code><a title="sshkey_tools.fields.StringField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.StringField.get_name" href="#sshkey_tools.fields.CertificateField.get_name">get_name</a></code></li>
<li><code><a title="sshkey_tools.fields.StringField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.RsaPubkeyField"><code class="flex name class">
<span>class <span class="ident">RsaPubkeyField</span></span>
<span>(</span><span>value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Holds the RSA Public Key for RSA Certificates</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RsaPubkeyField(PublicKeyField):
    &#34;&#34;&#34;
    Holds the RSA Public Key for RSA Certificates
    &#34;&#34;&#34;

    DEFAULT = None
    DATA_TYPE = RsaPublicKey

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[RsaPublicKey, bytes]:
        &#34;&#34;&#34;
        Decode the certificate field from a byte string
        starting with the encoded public key

        Args:
            data (bytes): The byte string starting with the encoded key

        Returns:
            Tuple[RsaPublicKey, bytes]: The PublicKey field and remainder of the data
        &#34;&#34;&#34;
        e, data = MpIntegerField.decode(data)
        n, data = MpIntegerField.decode(data)

        return RsaPublicKey.from_numbers(e=e, n=n), data</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.PublicKeyField" href="#sshkey_tools.fields.PublicKeyField">PublicKeyField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sshkey_tools.fields.RsaPubkeyField.DEFAULT"><code class="name">var <span class="ident">DEFAULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.RsaPubkeyField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data: bytes) ‑> Tuple[<a title="sshkey_tools.keys.RsaPublicKey" href="keys.html#sshkey_tools.keys.RsaPublicKey">RsaPublicKey</a>, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Decode the certificate field from a byte string
starting with the encoded public key</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The byte string starting with the encoded key</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[RsaPublicKey, bytes]</code></dt>
<dd>The PublicKey field and remainder of the data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; Tuple[RsaPublicKey, bytes]:
    &#34;&#34;&#34;
    Decode the certificate field from a byte string
    starting with the encoded public key

    Args:
        data (bytes): The byte string starting with the encoded key

    Returns:
        Tuple[RsaPublicKey, bytes]: The PublicKey field and remainder of the data
    &#34;&#34;&#34;
    e, data = MpIntegerField.decode(data)
    n, data = MpIntegerField.decode(data)

    return RsaPublicKey.from_numbers(e=e, n=n), data</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.PublicKeyField" href="#sshkey_tools.fields.PublicKeyField">PublicKeyField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.PublicKeyField.DATA_TYPE" href="#sshkey_tools.fields.PublicKeyField.DATA_TYPE">DATA_TYPE</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.encode" href="#sshkey_tools.fields.PublicKeyField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.factory" href="#sshkey_tools.fields.CertificateField.factory">factory</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.from_object" href="#sshkey_tools.fields.PublicKeyField.from_object">from_object</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.get_name" href="#sshkey_tools.fields.CertificateField.get_name">get_name</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.RsaSignatureField"><code class="flex name class">
<span>class <span class="ident">RsaSignatureField</span></span>
<span>(</span><span>private_key: <a title="sshkey_tools.keys.RsaPrivateKey" href="keys.html#sshkey_tools.keys.RsaPrivateKey">RsaPrivateKey</a> = None, hash_alg: <a title="sshkey_tools.keys.RsaAlgs" href="keys.html#sshkey_tools.keys.RsaAlgs">RsaAlgs</a> = RsaAlgs.SHA512, signature: bytes = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and contains the RSA signature from an RSA Private Key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RsaSignatureField(SignatureField):
    &#34;&#34;&#34;
    Creates and contains the RSA signature from an RSA Private Key
    &#34;&#34;&#34;

    DEFAULT = None
    DATA_TYPE = bytes

    def __init__(
        self,
        private_key: RsaPrivateKey = None,
        hash_alg: RsaAlgs = RsaAlgs.SHA512,
        signature: bytes = None,
    ):
        super().__init__(private_key, signature)
        self.hash_alg = hash_alg

    @classmethod
    # pylint: disable=arguments-renamed
    def encode(cls, value: bytes, hash_alg: RsaAlgs = RsaAlgs.SHA512) -&gt; bytes:
        &#34;&#34;&#34;
        Encodes the value to a byte string

        Args:
            signature (bytes): The signature bytes to encode
            hash_alg (RsaAlgs, optional):  The hash algorithm used for the signature.
                                            Defaults to RsaAlgs.SHA256.

        Returns:
            bytes: The encoded byte string
        &#34;&#34;&#34;
        cls.__validate_type__(value, True)

        return BytestringField.encode(
            StringField.encode(hash_alg.value[0]) + BytestringField.encode(value)
        )

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[Tuple[bytes, bytes], bytes]:
        &#34;&#34;&#34;
        Decodes a bytestring containing a signature

        Args:
            data (bytes): The bytestring starting with the RSA Signature

        Returns:
            Tuple[ Tuple[ bytes, bytes ], bytes ]: (signature_type, signature), remainder of data
        &#34;&#34;&#34;
        signature, data = BytestringField.decode(data)

        sig_type, signature = StringField.decode(signature)
        signature, _ = BytestringField.decode(signature)

        return (sig_type, signature), data

    @classmethod
    def from_decode(cls, data: bytes) -&gt; Tuple[&#34;RsaSignatureField&#34;, bytes]:
        &#34;&#34;&#34;
        Generates an RsaSignatureField class from the encoded signature

        Args:
            data (bytes): The bytestring containing the encoded signature

        Raises:
            _EX.InvalidDataException: Invalid data

        Returns:
            Tuple[RsaSignatureField, bytes]: RSA Signature field and remainder of data
        &#34;&#34;&#34;
        signature, data = cls.decode(data)

        return (
            cls(
                private_key=None,
                hash_alg=[alg for alg in RsaAlgs if alg.value[0] == signature[0]][0],
                signature=signature[1],
            ),
            data,
        )

    # pylint: disable=unused-argument
    def sign(self, data: bytes, hash_alg: RsaAlgs = RsaAlgs.SHA512, **kwargs) -&gt; None:
        &#34;&#34;&#34;
        Signs the provided data with the provided private key

        Args:
            data (bytes): The data to be signed
            hash_alg (RsaAlgs, optional): The RSA algorithm to use for hashing.
                                           Defaults to RsaAlgs.SHA256.
        &#34;&#34;&#34;
        self.value = self.private_key.sign(data, hash_alg)

        self.hash_alg = hash_alg
        self.is_signed = True

    def __bytes__(self):
        return self.encode(self.value, self.hash_alg)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.SignatureField" href="#sshkey_tools.fields.SignatureField">SignatureField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sshkey_tools.fields.RsaSignatureField.DEFAULT"><code class="name">var <span class="ident">DEFAULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.RsaSignatureField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data: bytes) ‑> Tuple[Tuple[bytes, bytes], bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes a bytestring containing a signature</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The bytestring starting with the RSA Signature</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[ Tuple[ bytes, bytes ], bytes ]</code></dt>
<dd>(signature_type, signature), remainder of data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; Tuple[Tuple[bytes, bytes], bytes]:
    &#34;&#34;&#34;
    Decodes a bytestring containing a signature

    Args:
        data (bytes): The bytestring starting with the RSA Signature

    Returns:
        Tuple[ Tuple[ bytes, bytes ], bytes ]: (signature_type, signature), remainder of data
    &#34;&#34;&#34;
    signature, data = BytestringField.decode(data)

    sig_type, signature = StringField.decode(signature)
    signature, _ = BytestringField.decode(signature)

    return (sig_type, signature), data</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.RsaSignatureField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>value: bytes, hash_alg: <a title="sshkey_tools.keys.RsaAlgs" href="keys.html#sshkey_tools.keys.RsaAlgs">RsaAlgs</a> = RsaAlgs.SHA512) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes the value to a byte string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>signature</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The signature bytes to encode</dd>
<dt><strong><code>hash_alg</code></strong> :&ensp;<code>RsaAlgs</code>, optional</dt>
<dd>The hash algorithm used for the signature.
Defaults to RsaAlgs.SHA256.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>The encoded byte string</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
# pylint: disable=arguments-renamed
def encode(cls, value: bytes, hash_alg: RsaAlgs = RsaAlgs.SHA512) -&gt; bytes:
    &#34;&#34;&#34;
    Encodes the value to a byte string

    Args:
        signature (bytes): The signature bytes to encode
        hash_alg (RsaAlgs, optional):  The hash algorithm used for the signature.
                                        Defaults to RsaAlgs.SHA256.

    Returns:
        bytes: The encoded byte string
    &#34;&#34;&#34;
    cls.__validate_type__(value, True)

    return BytestringField.encode(
        StringField.encode(hash_alg.value[0]) + BytestringField.encode(value)
    )</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.RsaSignatureField.from_decode"><code class="name flex">
<span>def <span class="ident">from_decode</span></span>(<span>data: bytes) ‑> Tuple[<a title="sshkey_tools.fields.RsaSignatureField" href="#sshkey_tools.fields.RsaSignatureField">RsaSignatureField</a>, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Generates an RsaSignatureField class from the encoded signature</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The bytestring containing the encoded signature</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>_EX.InvalidDataException</code></dt>
<dd>Invalid data</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[<a title="sshkey_tools.fields.RsaSignatureField" href="#sshkey_tools.fields.RsaSignatureField">RsaSignatureField</a>, bytes]</code></dt>
<dd>RSA Signature field and remainder of data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_decode(cls, data: bytes) -&gt; Tuple[&#34;RsaSignatureField&#34;, bytes]:
    &#34;&#34;&#34;
    Generates an RsaSignatureField class from the encoded signature

    Args:
        data (bytes): The bytestring containing the encoded signature

    Raises:
        _EX.InvalidDataException: Invalid data

    Returns:
        Tuple[RsaSignatureField, bytes]: RSA Signature field and remainder of data
    &#34;&#34;&#34;
    signature, data = cls.decode(data)

    return (
        cls(
            private_key=None,
            hash_alg=[alg for alg in RsaAlgs if alg.value[0] == signature[0]][0],
            signature=signature[1],
        ),
        data,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.RsaSignatureField.sign"><code class="name flex">
<span>def <span class="ident">sign</span></span>(<span>self, data: bytes, hash_alg: <a title="sshkey_tools.keys.RsaAlgs" href="keys.html#sshkey_tools.keys.RsaAlgs">RsaAlgs</a> = RsaAlgs.SHA512, **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Signs the provided data with the provided private key</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The data to be signed</dd>
<dt><strong><code>hash_alg</code></strong> :&ensp;<code>RsaAlgs</code>, optional</dt>
<dd>The RSA algorithm to use for hashing.
Defaults to RsaAlgs.SHA256.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sign(self, data: bytes, hash_alg: RsaAlgs = RsaAlgs.SHA512, **kwargs) -&gt; None:
    &#34;&#34;&#34;
    Signs the provided data with the provided private key

    Args:
        data (bytes): The data to be signed
        hash_alg (RsaAlgs, optional): The RSA algorithm to use for hashing.
                                       Defaults to RsaAlgs.SHA256.
    &#34;&#34;&#34;
    self.value = self.private_key.sign(data, hash_alg)

    self.hash_alg = hash_alg
    self.is_signed = True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.SignatureField" href="#sshkey_tools.fields.SignatureField">SignatureField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.SignatureField.DATA_TYPE" href="#sshkey_tools.fields.SignatureField.DATA_TYPE">DATA_TYPE</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.can_sign" href="#sshkey_tools.fields.SignatureField.can_sign">can_sign</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.factory" href="#sshkey_tools.fields.CertificateField.factory">factory</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.from_object" href="#sshkey_tools.fields.SignatureField.from_object">from_object</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.get_name" href="#sshkey_tools.fields.CertificateField.get_name">get_name</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.SerialField"><code class="flex name class">
<span>class <span class="ident">SerialField</span></span>
<span>(</span><span>value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains the numeric serial number of the certificate,
maximum is (2**64)-1</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SerialField(Integer64Field):
    &#34;&#34;&#34;
    Contains the numeric serial number of the certificate,
    maximum is (2**64)-1
    &#34;&#34;&#34;

    DEFAULT = random_serial
    DATA_TYPE = int</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.Integer64Field" href="#sshkey_tools.fields.Integer64Field">Integer64Field</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.SerialField.DEFAULT"><code class="name flex">
<span>def <span class="ident">DEFAULT</span></span>(<span>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a random serial number</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Random serial</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def random_serial() -&gt; str:
    &#34;&#34;&#34;Generates a random serial number

    Returns:
        int: Random serial
    &#34;&#34;&#34;
    return randint(0, 2**64 - 1)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.Integer64Field" href="#sshkey_tools.fields.Integer64Field">Integer64Field</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.Integer64Field.DATA_TYPE" href="#sshkey_tools.fields.Integer64Field.DATA_TYPE">DATA_TYPE</a></code></li>
<li><code><a title="sshkey_tools.fields.Integer64Field.decode" href="#sshkey_tools.fields.Integer64Field.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.Integer64Field.encode" href="#sshkey_tools.fields.Integer64Field.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.Integer64Field.factory" href="#sshkey_tools.fields.CertificateField.factory">factory</a></code></li>
<li><code><a title="sshkey_tools.fields.Integer64Field.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.Integer64Field.get_name" href="#sshkey_tools.fields.CertificateField.get_name">get_name</a></code></li>
<li><code><a title="sshkey_tools.fields.Integer64Field.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.SignatureField"><code class="flex name class">
<span>class <span class="ident">SignatureField</span></span>
<span>(</span><span>private_key: <a title="sshkey_tools.keys.PrivateKey" href="keys.html#sshkey_tools.keys.PrivateKey">PrivateKey</a> = None, signature: bytes = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and contains the signature of the certificate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SignatureField(CertificateField):
    &#34;&#34;&#34;
    Creates and contains the signature of the certificate
    &#34;&#34;&#34;

    DEFAULT = None
    DATA_TYPE = bytes

    # pylint: disable=super-init-not-called
    def __init__(self, private_key: PrivateKey = None, signature: bytes = None):
        self.private_key = private_key
        self.is_signed = False
        self.value = signature

        if signature is not None and ensure_bytestring(signature) not in (&#34;&#34;, &#34; &#34;):
            self.is_signed = True

    def __table__(self) -&gt; tuple:
        msg = &#34;No signature&#34;
        if self.is_signed:
            msg = f&#34;Signed with private key {self.private_key.get_fingerprint()}&#34;

        return (&#34;Signature&#34;, msg)

    @staticmethod
    def from_object(private_key: PrivateKey):
        &#34;&#34;&#34;
        Load a private key from a PrivateKey object

        Args:
            private_key (PrivateKey): Private key to use for signing

        Raises:
            _EX.InvalidKeyException: Invalid private key

        Returns:
            SignatureField: SignatureField child class
        &#34;&#34;&#34;
        try:
            return globals()[CA_SIGNATURE_MAP[private_key.__class__]](
                private_key=private_key
            )
        except KeyError:
            raise _EX.InvalidKeyException(
                &#34;The private key provided is invalid or not supported&#34;
            ) from KeyError

    @staticmethod
    def from_decode(data: bytes) -&gt; Tuple[&#34;SignatureField&#34;, bytes]:
        &#34;&#34;&#34;
        Generates a SignatureField child class from the encoded signature

        Args:
            data (bytes): The bytestring containing the encoded signature

        Raises:
            _EX.InvalidDataException: Invalid data

        Returns:
            SignatureField: child of SignatureField
        &#34;&#34;&#34;
        signature, _ = BytestringField.decode(data)
        signature_type = BytestringField.decode(signature)[0]

        for key, value in SIGNATURE_TYPE_MAP.items():
            if key in signature_type:
                return globals()[value].from_decode(data)

        raise _EX.InvalidDataException(&#34;No matching signature type found&#34;)

    def can_sign(self):
        &#34;&#34;&#34;
        Determines if a signature can be generated from
        this private key
        &#34;&#34;&#34;
        return self.private_key is not None

    def sign(self, data: bytes) -&gt; None:
        &#34;&#34;&#34;
        Placeholder signing function
        &#34;&#34;&#34;
        raise _EX.InvalidClassCallException(&#34;The base class has no sign function&#34;)

    def __bytes__(self) -&gt; None:
        return self.encode(self.value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.DsaSignatureField" href="#sshkey_tools.fields.DsaSignatureField">DsaSignatureField</a></li>
<li><a title="sshkey_tools.fields.EcdsaSignatureField" href="#sshkey_tools.fields.EcdsaSignatureField">EcdsaSignatureField</a></li>
<li><a title="sshkey_tools.fields.Ed25519SignatureField" href="#sshkey_tools.fields.Ed25519SignatureField">Ed25519SignatureField</a></li>
<li><a title="sshkey_tools.fields.RsaSignatureField" href="#sshkey_tools.fields.RsaSignatureField">RsaSignatureField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sshkey_tools.fields.SignatureField.DATA_TYPE"><code class="name">var <span class="ident">DATA_TYPE</span></code></dt>
<dd>
<div class="desc"><p>bytes(iterable_of_ints) -&gt; bytes
bytes(string, encoding[, errors]) -&gt; bytes
bytes(bytes_or_buffer) -&gt; immutable copy of bytes_or_buffer
bytes(int) -&gt; bytes object of size given by the parameter initialized with null bytes
bytes() -&gt; empty bytes object</p>
<p>Construct an immutable array of bytes from:
- an iterable yielding integers in range(256)
- a text string encoded using the specified encoding
- any object implementing the buffer API.
- an integer</p></div>
</dd>
<dt id="sshkey_tools.fields.SignatureField.DEFAULT"><code class="name">var <span class="ident">DEFAULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.SignatureField.from_decode"><code class="name flex">
<span>def <span class="ident">from_decode</span></span>(<span>data: bytes) ‑> Tuple[<a title="sshkey_tools.fields.SignatureField" href="#sshkey_tools.fields.SignatureField">SignatureField</a>, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a SignatureField child class from the encoded signature</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The bytestring containing the encoded signature</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>_EX.InvalidDataException</code></dt>
<dd>Invalid data</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sshkey_tools.fields.SignatureField" href="#sshkey_tools.fields.SignatureField">SignatureField</a></code></dt>
<dd>child of SignatureField</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_decode(data: bytes) -&gt; Tuple[&#34;SignatureField&#34;, bytes]:
    &#34;&#34;&#34;
    Generates a SignatureField child class from the encoded signature

    Args:
        data (bytes): The bytestring containing the encoded signature

    Raises:
        _EX.InvalidDataException: Invalid data

    Returns:
        SignatureField: child of SignatureField
    &#34;&#34;&#34;
    signature, _ = BytestringField.decode(data)
    signature_type = BytestringField.decode(signature)[0]

    for key, value in SIGNATURE_TYPE_MAP.items():
        if key in signature_type:
            return globals()[value].from_decode(data)

    raise _EX.InvalidDataException(&#34;No matching signature type found&#34;)</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.SignatureField.from_object"><code class="name flex">
<span>def <span class="ident">from_object</span></span>(<span>private_key: <a title="sshkey_tools.keys.PrivateKey" href="keys.html#sshkey_tools.keys.PrivateKey">PrivateKey</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a private key from a PrivateKey object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>private_key</code></strong> :&ensp;<code>PrivateKey</code></dt>
<dd>Private key to use for signing</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>_EX.InvalidKeyException</code></dt>
<dd>Invalid private key</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sshkey_tools.fields.SignatureField" href="#sshkey_tools.fields.SignatureField">SignatureField</a></code></dt>
<dd>SignatureField child class</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_object(private_key: PrivateKey):
    &#34;&#34;&#34;
    Load a private key from a PrivateKey object

    Args:
        private_key (PrivateKey): Private key to use for signing

    Raises:
        _EX.InvalidKeyException: Invalid private key

    Returns:
        SignatureField: SignatureField child class
    &#34;&#34;&#34;
    try:
        return globals()[CA_SIGNATURE_MAP[private_key.__class__]](
            private_key=private_key
        )
    except KeyError:
        raise _EX.InvalidKeyException(
            &#34;The private key provided is invalid or not supported&#34;
        ) from KeyError</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.SignatureField.can_sign"><code class="name flex">
<span>def <span class="ident">can_sign</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines if a signature can be generated from
this private key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def can_sign(self):
    &#34;&#34;&#34;
    Determines if a signature can be generated from
    this private key
    &#34;&#34;&#34;
    return self.private_key is not None</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.SignatureField.sign"><code class="name flex">
<span>def <span class="ident">sign</span></span>(<span>self, data: bytes) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Placeholder signing function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sign(self, data: bytes) -&gt; None:
    &#34;&#34;&#34;
    Placeholder signing function
    &#34;&#34;&#34;
    raise _EX.InvalidClassCallException(&#34;The base class has no sign function&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.CertificateField.decode" href="#sshkey_tools.fields.CertificateField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.encode" href="#sshkey_tools.fields.CertificateField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.factory" href="#sshkey_tools.fields.CertificateField.factory">factory</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.get_name" href="#sshkey_tools.fields.CertificateField.get_name">get_name</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.StringField"><code class="flex name class">
<span>class <span class="ident">StringField</span></span>
<span>(</span><span>value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Field representing a string value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StringField(BytestringField):
    &#34;&#34;&#34;
    Field representing a string value
    &#34;&#34;&#34;

    DATA_TYPE = (str, bytes)
    DEFAULT = &#34;&#34;

    @classmethod
    def encode(cls, value: str, encoding: str = &#34;utf-8&#34;):
        &#34;&#34;&#34;
        Encodes a string or bytestring into a packed byte string

        Args:
            value (Union[str, bytes]): The string/bytestring to encode
            encoding (str): The encoding to user for the string

        Returns:
            bytes: Packed byte string containing the source data
        &#34;&#34;&#34;
        cls.__validate_type__(value, True)
        return BytestringField.encode(ensure_bytestring(value, encoding))

    @staticmethod
    def decode(data: bytes, encoding: str = &#34;utf-8&#34;) -&gt; Tuple[str, bytes]:
        &#34;&#34;&#34;
        Unpacks the next string from a packed byte string

        Args:
            data (bytes): The packed byte string to unpack

        Returns:
            tuple(bytes, bytes):  The next block of bytes from the packed byte
                                  string and remainder of the data
        &#34;&#34;&#34;
        value, data = BytestringField.decode(data)

        return value.decode(encoding), data</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.BytestringField" href="#sshkey_tools.fields.BytestringField">BytestringField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.KeyIdField" href="#sshkey_tools.fields.KeyIdField">KeyIdField</a></li>
<li><a title="sshkey_tools.fields.NonceField" href="#sshkey_tools.fields.NonceField">NonceField</a></li>
<li><a title="sshkey_tools.fields.PubkeyTypeField" href="#sshkey_tools.fields.PubkeyTypeField">PubkeyTypeField</a></li>
<li><a title="sshkey_tools.fields.ReservedField" href="#sshkey_tools.fields.ReservedField">ReservedField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sshkey_tools.fields.StringField.DATA_TYPE"><code class="name">var <span class="ident">DATA_TYPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sshkey_tools.fields.StringField.DEFAULT"><code class="name">var <span class="ident">DEFAULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.BytestringField" href="#sshkey_tools.fields.BytestringField">BytestringField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.BytestringField.decode" href="#sshkey_tools.fields.BytestringField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.BytestringField.encode" href="#sshkey_tools.fields.BytestringField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.BytestringField.factory" href="#sshkey_tools.fields.CertificateField.factory">factory</a></code></li>
<li><code><a title="sshkey_tools.fields.BytestringField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.BytestringField.get_name" href="#sshkey_tools.fields.CertificateField.get_name">get_name</a></code></li>
<li><code><a title="sshkey_tools.fields.BytestringField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.ValidAfterField"><code class="flex name class">
<span>class <span class="ident">ValidAfterField</span></span>
<span>(</span><span>value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains the start of the validity period for the certificate,
represented by a datetime object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ValidAfterField(DateTimeField):
    &#34;&#34;&#34;
    Contains the start of the validity period for the certificate,
    represented by a datetime object
    &#34;&#34;&#34;

    DEFAULT = datetime.now()
    DATA_TYPE = (datetime, int)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.DateTimeField" href="#sshkey_tools.fields.DateTimeField">DateTimeField</a></li>
<li><a title="sshkey_tools.fields.Integer64Field" href="#sshkey_tools.fields.Integer64Field">Integer64Field</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.DateTimeField" href="#sshkey_tools.fields.DateTimeField">DateTimeField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.DateTimeField.DEFAULT" href="#sshkey_tools.fields.DateTimeField.DEFAULT">DEFAULT</a></code></li>
</ul>
</li>
<li><code><b><a title="sshkey_tools.fields.DateTimeField" href="#sshkey_tools.fields.DateTimeField">DateTimeField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.DateTimeField.decode" href="#sshkey_tools.fields.DateTimeField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.DateTimeField.encode" href="#sshkey_tools.fields.DateTimeField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.DateTimeField.factory" href="#sshkey_tools.fields.CertificateField.factory">factory</a></code></li>
<li><code><a title="sshkey_tools.fields.DateTimeField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.DateTimeField.get_name" href="#sshkey_tools.fields.CertificateField.get_name">get_name</a></code></li>
<li><code><a title="sshkey_tools.fields.DateTimeField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
<li><code><b><a title="sshkey_tools.fields.Integer64Field" href="#sshkey_tools.fields.Integer64Field">Integer64Field</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.Integer64Field.DATA_TYPE" href="#sshkey_tools.fields.Integer64Field.DATA_TYPE">DATA_TYPE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.ValidBeforeField"><code class="flex name class">
<span>class <span class="ident">ValidBeforeField</span></span>
<span>(</span><span>value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains the end of the validity period for the certificate,
represented by a datetime object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ValidBeforeField(DateTimeField):
    &#34;&#34;&#34;
    Contains the end of the validity period for the certificate,
    represented by a datetime object
    &#34;&#34;&#34;

    DEFAULT = datetime.now() + timedelta(minutes=10)
    DATA_TYPE = (datetime, int)

    def __validate_value__(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the contents of the field
        Additional checks over standard datetime field are
        done to ensure no already expired certificates are
        created
        &#34;&#34;&#34;
        if isinstance(self.__validate_type__(self.value), Exception):
            return _EX.InvalidFieldDataException(
                f&#34;{self.get_name()} Could not validate value, invalid type&#34;
            )

        super().__validate_value__()
        check = (
            self.value
            if isinstance(self.value, datetime)
            else datetime.fromtimestamp(self.value)
        )

        if check &lt; datetime.now():
            return _EX.InvalidCertificateFieldException(
                &#34;The certificate validity period is invalid&#34;
                + &#34; (expected a future datetime object or timestamp)&#34;
            )

        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.DateTimeField" href="#sshkey_tools.fields.DateTimeField">DateTimeField</a></li>
<li><a title="sshkey_tools.fields.Integer64Field" href="#sshkey_tools.fields.Integer64Field">Integer64Field</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.DateTimeField" href="#sshkey_tools.fields.DateTimeField">DateTimeField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.DateTimeField.DEFAULT" href="#sshkey_tools.fields.DateTimeField.DEFAULT">DEFAULT</a></code></li>
</ul>
</li>
<li><code><b><a title="sshkey_tools.fields.DateTimeField" href="#sshkey_tools.fields.DateTimeField">DateTimeField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.DateTimeField.decode" href="#sshkey_tools.fields.DateTimeField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.DateTimeField.encode" href="#sshkey_tools.fields.DateTimeField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.DateTimeField.factory" href="#sshkey_tools.fields.CertificateField.factory">factory</a></code></li>
<li><code><a title="sshkey_tools.fields.DateTimeField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.DateTimeField.get_name" href="#sshkey_tools.fields.CertificateField.get_name">get_name</a></code></li>
<li><code><a title="sshkey_tools.fields.DateTimeField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
<li><code><b><a title="sshkey_tools.fields.Integer64Field" href="#sshkey_tools.fields.Integer64Field">Integer64Field</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.Integer64Field.DATA_TYPE" href="#sshkey_tools.fields.Integer64Field.DATA_TYPE">DATA_TYPE</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sshkey_tools" href="index.html">sshkey_tools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sshkey_tools.fields.decode_dss_signature" href="#sshkey_tools.fields.decode_dss_signature">decode_dss_signature</a></code></li>
<li><code><a title="sshkey_tools.fields.encode_dss_signature" href="#sshkey_tools.fields.encode_dss_signature">encode_dss_signature</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sshkey_tools.fields.BooleanField" href="#sshkey_tools.fields.BooleanField">BooleanField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.BooleanField.DATA_TYPE" href="#sshkey_tools.fields.BooleanField.DATA_TYPE">DATA_TYPE</a></code></li>
<li><code><a title="sshkey_tools.fields.BooleanField.decode" href="#sshkey_tools.fields.BooleanField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.BooleanField.encode" href="#sshkey_tools.fields.BooleanField.encode">encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.BytestringField" href="#sshkey_tools.fields.BytestringField">BytestringField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.BytestringField.DATA_TYPE" href="#sshkey_tools.fields.BytestringField.DATA_TYPE">DATA_TYPE</a></code></li>
<li><code><a title="sshkey_tools.fields.BytestringField.DEFAULT" href="#sshkey_tools.fields.BytestringField.DEFAULT">DEFAULT</a></code></li>
<li><code><a title="sshkey_tools.fields.BytestringField.decode" href="#sshkey_tools.fields.BytestringField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.BytestringField.encode" href="#sshkey_tools.fields.BytestringField.encode">encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.CAPublicKeyField" href="#sshkey_tools.fields.CAPublicKeyField">CAPublicKeyField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.CAPublicKeyField.DATA_TYPE" href="#sshkey_tools.fields.CAPublicKeyField.DATA_TYPE">DATA_TYPE</a></code></li>
<li><code><a title="sshkey_tools.fields.CAPublicKeyField.DEFAULT" href="#sshkey_tools.fields.CAPublicKeyField.DEFAULT">DEFAULT</a></code></li>
<li><code><a title="sshkey_tools.fields.CAPublicKeyField.decode" href="#sshkey_tools.fields.CAPublicKeyField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.CAPublicKeyField.from_object" href="#sshkey_tools.fields.CAPublicKeyField.from_object">from_object</a></code></li>
<li><code><a title="sshkey_tools.fields.CAPublicKeyField.validate" href="#sshkey_tools.fields.CAPublicKeyField.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.CERT_TYPE" href="#sshkey_tools.fields.CERT_TYPE">CERT_TYPE</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.CERT_TYPE.HOST" href="#sshkey_tools.fields.CERT_TYPE.HOST">HOST</a></code></li>
<li><code><a title="sshkey_tools.fields.CERT_TYPE.USER" href="#sshkey_tools.fields.CERT_TYPE.USER">USER</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></code></h4>
<ul class="two-column">
<li><code><a title="sshkey_tools.fields.CertificateField.DATA_TYPE" href="#sshkey_tools.fields.CertificateField.DATA_TYPE">DATA_TYPE</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.DEFAULT" href="#sshkey_tools.fields.CertificateField.DEFAULT">DEFAULT</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.IS_SET" href="#sshkey_tools.fields.CertificateField.IS_SET">IS_SET</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.REQUIRED" href="#sshkey_tools.fields.CertificateField.REQUIRED">REQUIRED</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.decode" href="#sshkey_tools.fields.CertificateField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.encode" href="#sshkey_tools.fields.CertificateField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.factory" href="#sshkey_tools.fields.CertificateField.factory">factory</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.get_name" href="#sshkey_tools.fields.CertificateField.get_name">get_name</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.CertificateTypeField" href="#sshkey_tools.fields.CertificateTypeField">CertificateTypeField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.CertificateTypeField.ALLOWED_VALUES" href="#sshkey_tools.fields.CertificateTypeField.ALLOWED_VALUES">ALLOWED_VALUES</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateTypeField.DEFAULT" href="#sshkey_tools.fields.CertificateTypeField.DEFAULT">DEFAULT</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateTypeField.encode" href="#sshkey_tools.fields.CertificateTypeField.encode">encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.CriticalOptionsField" href="#sshkey_tools.fields.CriticalOptionsField">CriticalOptionsField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.CriticalOptionsField.ALLOWED_VALUES" href="#sshkey_tools.fields.CriticalOptionsField.ALLOWED_VALUES">ALLOWED_VALUES</a></code></li>
<li><code><a title="sshkey_tools.fields.CriticalOptionsField.DATA_TYPE" href="#sshkey_tools.fields.CriticalOptionsField.DATA_TYPE">DATA_TYPE</a></code></li>
<li><code><a title="sshkey_tools.fields.CriticalOptionsField.DEFAULT" href="#sshkey_tools.fields.CriticalOptionsField.DEFAULT">DEFAULT</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.DateTimeField" href="#sshkey_tools.fields.DateTimeField">DateTimeField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.DateTimeField.DEFAULT" href="#sshkey_tools.fields.DateTimeField.DEFAULT">DEFAULT</a></code></li>
<li><code><a title="sshkey_tools.fields.DateTimeField.decode" href="#sshkey_tools.fields.DateTimeField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.DateTimeField.encode" href="#sshkey_tools.fields.DateTimeField.encode">encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.DsaPubkeyField" href="#sshkey_tools.fields.DsaPubkeyField">DsaPubkeyField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.DsaPubkeyField.DEFAULT" href="#sshkey_tools.fields.DsaPubkeyField.DEFAULT">DEFAULT</a></code></li>
<li><code><a title="sshkey_tools.fields.DsaPubkeyField.decode" href="#sshkey_tools.fields.DsaPubkeyField.decode">decode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.DsaSignatureField" href="#sshkey_tools.fields.DsaSignatureField">DsaSignatureField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.DsaSignatureField.DEFAULT" href="#sshkey_tools.fields.DsaSignatureField.DEFAULT">DEFAULT</a></code></li>
<li><code><a title="sshkey_tools.fields.DsaSignatureField.decode" href="#sshkey_tools.fields.DsaSignatureField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.DsaSignatureField.encode" href="#sshkey_tools.fields.DsaSignatureField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.DsaSignatureField.from_decode" href="#sshkey_tools.fields.DsaSignatureField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.DsaSignatureField.sign" href="#sshkey_tools.fields.DsaSignatureField.sign">sign</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.EcdsaPubkeyField" href="#sshkey_tools.fields.EcdsaPubkeyField">EcdsaPubkeyField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.EcdsaPubkeyField.DEFAULT" href="#sshkey_tools.fields.EcdsaPubkeyField.DEFAULT">DEFAULT</a></code></li>
<li><code><a title="sshkey_tools.fields.EcdsaPubkeyField.decode" href="#sshkey_tools.fields.EcdsaPubkeyField.decode">decode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.EcdsaSignatureField" href="#sshkey_tools.fields.EcdsaSignatureField">EcdsaSignatureField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.EcdsaSignatureField.DEFAULT" href="#sshkey_tools.fields.EcdsaSignatureField.DEFAULT">DEFAULT</a></code></li>
<li><code><a title="sshkey_tools.fields.EcdsaSignatureField.decode" href="#sshkey_tools.fields.EcdsaSignatureField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.EcdsaSignatureField.encode" href="#sshkey_tools.fields.EcdsaSignatureField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.EcdsaSignatureField.from_decode" href="#sshkey_tools.fields.EcdsaSignatureField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.EcdsaSignatureField.sign" href="#sshkey_tools.fields.EcdsaSignatureField.sign">sign</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.Ed25519PubkeyField" href="#sshkey_tools.fields.Ed25519PubkeyField">Ed25519PubkeyField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.Ed25519PubkeyField.DEFAULT" href="#sshkey_tools.fields.Ed25519PubkeyField.DEFAULT">DEFAULT</a></code></li>
<li><code><a title="sshkey_tools.fields.Ed25519PubkeyField.decode" href="#sshkey_tools.fields.Ed25519PubkeyField.decode">decode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.Ed25519SignatureField" href="#sshkey_tools.fields.Ed25519SignatureField">Ed25519SignatureField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.Ed25519SignatureField.DEFAULT" href="#sshkey_tools.fields.Ed25519SignatureField.DEFAULT">DEFAULT</a></code></li>
<li><code><a title="sshkey_tools.fields.Ed25519SignatureField.decode" href="#sshkey_tools.fields.Ed25519SignatureField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.Ed25519SignatureField.encode" href="#sshkey_tools.fields.Ed25519SignatureField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.Ed25519SignatureField.from_decode" href="#sshkey_tools.fields.Ed25519SignatureField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.Ed25519SignatureField.sign" href="#sshkey_tools.fields.Ed25519SignatureField.sign">sign</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.ExtensionsField" href="#sshkey_tools.fields.ExtensionsField">ExtensionsField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.ExtensionsField.ALLOWED_VALUES" href="#sshkey_tools.fields.ExtensionsField.ALLOWED_VALUES">ALLOWED_VALUES</a></code></li>
<li><code><a title="sshkey_tools.fields.ExtensionsField.DATA_TYPE" href="#sshkey_tools.fields.ExtensionsField.DATA_TYPE">DATA_TYPE</a></code></li>
<li><code><a title="sshkey_tools.fields.ExtensionsField.DEFAULT" href="#sshkey_tools.fields.ExtensionsField.DEFAULT">DEFAULT</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.Integer32Field" href="#sshkey_tools.fields.Integer32Field">Integer32Field</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.Integer32Field.DATA_TYPE" href="#sshkey_tools.fields.Integer32Field.DATA_TYPE">DATA_TYPE</a></code></li>
<li><code><a title="sshkey_tools.fields.Integer32Field.DEFAULT" href="#sshkey_tools.fields.Integer32Field.DEFAULT">DEFAULT</a></code></li>
<li><code><a title="sshkey_tools.fields.Integer32Field.decode" href="#sshkey_tools.fields.Integer32Field.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.Integer32Field.encode" href="#sshkey_tools.fields.Integer32Field.encode">encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.Integer64Field" href="#sshkey_tools.fields.Integer64Field">Integer64Field</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.Integer64Field.DATA_TYPE" href="#sshkey_tools.fields.Integer64Field.DATA_TYPE">DATA_TYPE</a></code></li>
<li><code><a title="sshkey_tools.fields.Integer64Field.DEFAULT" href="#sshkey_tools.fields.Integer64Field.DEFAULT">DEFAULT</a></code></li>
<li><code><a title="sshkey_tools.fields.Integer64Field.decode" href="#sshkey_tools.fields.Integer64Field.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.Integer64Field.encode" href="#sshkey_tools.fields.Integer64Field.encode">encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.KeyIdField" href="#sshkey_tools.fields.KeyIdField">KeyIdField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.KeyIdField.DATA_TYPE" href="#sshkey_tools.fields.KeyIdField.DATA_TYPE">DATA_TYPE</a></code></li>
<li><code><a title="sshkey_tools.fields.KeyIdField.DEFAULT" href="#sshkey_tools.fields.KeyIdField.DEFAULT">DEFAULT</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.KeyValueField" href="#sshkey_tools.fields.KeyValueField">KeyValueField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.KeyValueField.DATA_TYPE" href="#sshkey_tools.fields.KeyValueField.DATA_TYPE">DATA_TYPE</a></code></li>
<li><code><a title="sshkey_tools.fields.KeyValueField.DEFAULT" href="#sshkey_tools.fields.KeyValueField.DEFAULT">DEFAULT</a></code></li>
<li><code><a title="sshkey_tools.fields.KeyValueField.decode" href="#sshkey_tools.fields.KeyValueField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.KeyValueField.encode" href="#sshkey_tools.fields.KeyValueField.encode">encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.ListField" href="#sshkey_tools.fields.ListField">ListField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.ListField.DATA_TYPE" href="#sshkey_tools.fields.ListField.DATA_TYPE">DATA_TYPE</a></code></li>
<li><code><a title="sshkey_tools.fields.ListField.DEFAULT" href="#sshkey_tools.fields.ListField.DEFAULT">DEFAULT</a></code></li>
<li><code><a title="sshkey_tools.fields.ListField.decode" href="#sshkey_tools.fields.ListField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.ListField.encode" href="#sshkey_tools.fields.ListField.encode">encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.MpIntegerField" href="#sshkey_tools.fields.MpIntegerField">MpIntegerField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.MpIntegerField.DATA_TYPE" href="#sshkey_tools.fields.MpIntegerField.DATA_TYPE">DATA_TYPE</a></code></li>
<li><code><a title="sshkey_tools.fields.MpIntegerField.DEFAULT" href="#sshkey_tools.fields.MpIntegerField.DEFAULT">DEFAULT</a></code></li>
<li><code><a title="sshkey_tools.fields.MpIntegerField.decode" href="#sshkey_tools.fields.MpIntegerField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.MpIntegerField.encode" href="#sshkey_tools.fields.MpIntegerField.encode">encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.NonceField" href="#sshkey_tools.fields.NonceField">NonceField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.NonceField.DATA_TYPE" href="#sshkey_tools.fields.NonceField.DATA_TYPE">DATA_TYPE</a></code></li>
<li><code><a title="sshkey_tools.fields.NonceField.DEFAULT" href="#sshkey_tools.fields.NonceField.DEFAULT">DEFAULT</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.PrincipalsField" href="#sshkey_tools.fields.PrincipalsField">PrincipalsField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.PrincipalsField.DATA_TYPE" href="#sshkey_tools.fields.PrincipalsField.DATA_TYPE">DATA_TYPE</a></code></li>
<li><code><a title="sshkey_tools.fields.PrincipalsField.DEFAFULT" href="#sshkey_tools.fields.PrincipalsField.DEFAFULT">DEFAFULT</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.PubkeyTypeField" href="#sshkey_tools.fields.PubkeyTypeField">PubkeyTypeField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.PubkeyTypeField.ALLOWED_VALUES" href="#sshkey_tools.fields.PubkeyTypeField.ALLOWED_VALUES">ALLOWED_VALUES</a></code></li>
<li><code><a title="sshkey_tools.fields.PubkeyTypeField.DATA_TYPE" href="#sshkey_tools.fields.PubkeyTypeField.DATA_TYPE">DATA_TYPE</a></code></li>
<li><code><a title="sshkey_tools.fields.PubkeyTypeField.DEFAULT" href="#sshkey_tools.fields.PubkeyTypeField.DEFAULT">DEFAULT</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.PublicKeyField" href="#sshkey_tools.fields.PublicKeyField">PublicKeyField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.PublicKeyField.DATA_TYPE" href="#sshkey_tools.fields.PublicKeyField.DATA_TYPE">DATA_TYPE</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.DEFAULT" href="#sshkey_tools.fields.PublicKeyField.DEFAULT">DEFAULT</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.encode" href="#sshkey_tools.fields.PublicKeyField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.from_object" href="#sshkey_tools.fields.PublicKeyField.from_object">from_object</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.ReservedField" href="#sshkey_tools.fields.ReservedField">ReservedField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.ReservedField.DATA_TYPE" href="#sshkey_tools.fields.ReservedField.DATA_TYPE">DATA_TYPE</a></code></li>
<li><code><a title="sshkey_tools.fields.ReservedField.DEFAULT" href="#sshkey_tools.fields.ReservedField.DEFAULT">DEFAULT</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.RsaPubkeyField" href="#sshkey_tools.fields.RsaPubkeyField">RsaPubkeyField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.RsaPubkeyField.DEFAULT" href="#sshkey_tools.fields.RsaPubkeyField.DEFAULT">DEFAULT</a></code></li>
<li><code><a title="sshkey_tools.fields.RsaPubkeyField.decode" href="#sshkey_tools.fields.RsaPubkeyField.decode">decode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.RsaSignatureField" href="#sshkey_tools.fields.RsaSignatureField">RsaSignatureField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.RsaSignatureField.DEFAULT" href="#sshkey_tools.fields.RsaSignatureField.DEFAULT">DEFAULT</a></code></li>
<li><code><a title="sshkey_tools.fields.RsaSignatureField.decode" href="#sshkey_tools.fields.RsaSignatureField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.RsaSignatureField.encode" href="#sshkey_tools.fields.RsaSignatureField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.RsaSignatureField.from_decode" href="#sshkey_tools.fields.RsaSignatureField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.RsaSignatureField.sign" href="#sshkey_tools.fields.RsaSignatureField.sign">sign</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.SerialField" href="#sshkey_tools.fields.SerialField">SerialField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.SerialField.DEFAULT" href="#sshkey_tools.fields.SerialField.DEFAULT">DEFAULT</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.SignatureField" href="#sshkey_tools.fields.SignatureField">SignatureField</a></code></h4>
<ul class="two-column">
<li><code><a title="sshkey_tools.fields.SignatureField.DATA_TYPE" href="#sshkey_tools.fields.SignatureField.DATA_TYPE">DATA_TYPE</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.DEFAULT" href="#sshkey_tools.fields.SignatureField.DEFAULT">DEFAULT</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.can_sign" href="#sshkey_tools.fields.SignatureField.can_sign">can_sign</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.from_decode" href="#sshkey_tools.fields.SignatureField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.from_object" href="#sshkey_tools.fields.SignatureField.from_object">from_object</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.sign" href="#sshkey_tools.fields.SignatureField.sign">sign</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.StringField" href="#sshkey_tools.fields.StringField">StringField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.StringField.DATA_TYPE" href="#sshkey_tools.fields.StringField.DATA_TYPE">DATA_TYPE</a></code></li>
<li><code><a title="sshkey_tools.fields.StringField.DEFAULT" href="#sshkey_tools.fields.StringField.DEFAULT">DEFAULT</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.ValidAfterField" href="#sshkey_tools.fields.ValidAfterField">ValidAfterField</a></code></h4>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.ValidBeforeField" href="#sshkey_tools.fields.ValidBeforeField">ValidBeforeField</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>