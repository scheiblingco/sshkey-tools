<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sshkey_tools.fields API documentation</title>
<meta name="description" content="Field types for SSH Certificates" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sshkey_tools.fields</code></h1>
</header>
<section id="section-intro">
<p>Field types for SSH Certificates</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Field types for SSH Certificates
&#34;&#34;&#34;
# pylint: disable=invalid-name,too-many-lines
from enum import Enum
from typing import Union, Tuple
from datetime import datetime
from struct import pack, unpack
from base64 import b64encode
from cryptography.hazmat.primitives.asymmetric.utils import (
    decode_dss_signature,
    encode_dss_signature,
)
from . import exceptions as _EX
from .keys import (
    RsaAlgs,
    PrivateKey,
    PublicKey,
    RsaPublicKey,
    RsaPrivateKey,
    DsaPublicKey,
    DsaPrivateKey,
    EcdsaPublicKey,
    EcdsaPrivateKey,
    Ed25519PublicKey,
    Ed25519PrivateKey,
)

from .utils import long_to_bytes, bytes_to_long, generate_secure_nonce


MAX_INT32 = 2**32
MAX_INT64 = 2**64

ECDSA_CURVE_MAP = {
    &#34;secp256r1&#34;: &#34;nistp256&#34;,
    &#34;secp384r1&#34;: &#34;nistp384&#34;,
    &#34;secp521r1&#34;: &#34;nistp521&#34;,
}

SUBJECT_PUBKEY_MAP = {
    RsaPublicKey: &#34;RSAPubkeyField&#34;,
    DsaPublicKey: &#34;DSAPubkeyField&#34;,
    EcdsaPublicKey: &#34;ECDSAPubkeyField&#34;,
    Ed25519PublicKey: &#34;ED25519PubkeyField&#34;,
}

CA_SIGNATURE_MAP = {
    RsaPrivateKey: &#34;RSASignatureField&#34;,
    DsaPrivateKey: &#34;DSASignatureField&#34;,
    EcdsaPrivateKey: &#34;ECDSASignatureField&#34;,
    Ed25519PrivateKey: &#34;ED25519SignatureField&#34;,
}

SIGNATURE_TYPE_MAP = {
    b&#34;rsa&#34;: &#34;RSASignatureField&#34;,
    b&#34;dss&#34;: &#34;DSASignatureField&#34;,
    b&#34;ecdsa&#34;: &#34;ECDSASignatureField&#34;,
    b&#34;ed25519&#34;: &#34;ED25519SignatureField&#34;,
}


class CERT_TYPE(Enum):
    &#34;&#34;&#34;
    Certificate types, User certificate/Host certificate
    &#34;&#34;&#34;

    USER = 1
    HOST = 2


class CertificateField:
    &#34;&#34;&#34;
    The base class for certificate fields
    &#34;&#34;&#34;

    is_set = None

    def __init__(self, value, name=None):
        self.name = name
        self.value = value
        self.exception = None
        self.is_set = True

    def __str__(self):
        return f&#34;{self.name}: {self.value}&#34;

    @staticmethod
    def encode(value) -&gt; bytes:
        &#34;&#34;&#34;
        Returns the encoded value of the field
        &#34;&#34;&#34;

    @staticmethod
    def decode(data: bytes) -&gt; tuple:
        &#34;&#34;&#34;
        Returns the decoded value of the field
        &#34;&#34;&#34;

    def __bytes__(self) -&gt; bytes:
        return self.encode(self.value)

    # pylint: disable=no-self-use
    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the field
        &#34;&#34;&#34;
        return True

    @classmethod
    def from_decode(cls, data: bytes) -&gt; Tuple[&#34;CertificateField&#34;, bytes]:
        &#34;&#34;&#34;
        Creates a field class based on encoded bytes

        Returns:
            tuple: CertificateField, remaining bytes
        &#34;&#34;&#34;
        value, data = cls.decode(data)
        return cls(value), data


class BooleanField(CertificateField):
    &#34;&#34;&#34;
    Field representing a boolean value (True/False)
    &#34;&#34;&#34;

    @staticmethod
    def encode(value: bool) -&gt; bytes:
        &#34;&#34;&#34;
        Encodes a boolean value to a byte string

        Args:
            value (bool): Boolean to encode

        Returns:
            bytes: Packed byte representing the boolean
        &#34;&#34;&#34;
        if not isinstance(value, bool):
            raise _EX.InvalidFieldDataException(
                f&#34;Expected bool, got {value.__class__.__name__}&#34;
            )

        return pack(&#34;B&#34;, 1 if value else 0)

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[bool, bytes]:
        &#34;&#34;&#34;
        Decodes a boolean from a bytestring

        Args:
            data (bytes): The byte string starting with an encoded boolean
        &#34;&#34;&#34;
        return bool(unpack(&#34;B&#34;, data[:1])[0]), data[1:]

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validate the field data
        &#34;&#34;&#34;
        if self.value not in [True, False]:
            return _EX.InvalidFieldDataException(
                f&#34;Passed value type ({type(self.value)}) is not a boolean&#34;
            )

        return True


class BytestringField(CertificateField):
    &#34;&#34;&#34;
    Field representing a bytestring value
    &#34;&#34;&#34;

    @staticmethod
    def encode(value: bytes) -&gt; bytes:
        &#34;&#34;&#34;
        Encodes a string or bytestring into a packed byte string

        Args:
            value (Union[str, bytes]): The string/bytestring to encode
            encoding (str): The encoding to user for the string

        Returns:
            bytes: Packed byte string containing the source data
        &#34;&#34;&#34;
        if not isinstance(value, bytes):
            raise _EX.InvalidFieldDataException(
                f&#34;Expected bytes, got {value.__class__.__name__}&#34;
            )

        return pack(&#34;&gt;I&#34;, len(value)) + value

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[bytes, bytes]:
        &#34;&#34;&#34;
        Unpacks the next string from a packed byte string

        Args:
            data (bytes): The packed byte string to unpack

        Returns:
            tuple(bytes, bytes):  The next block of bytes from the packed byte
                                  string and remainder of the data
        &#34;&#34;&#34;
        length = unpack(&#34;&gt;I&#34;, data[:4])[0] + 4
        return data[4:length], data[length:]

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validate the field data
        &#34;&#34;&#34;
        if not isinstance(self.value, bytes):
            return _EX.InvalidFieldDataException(
                f&#34;Passed value type ({type(self.value)}) is not a bytestring&#34;
            )

        return True


class StringField(BytestringField):
    &#34;&#34;&#34;
    Field representing a string value
    &#34;&#34;&#34;

    @staticmethod
    def encode(value: str, encoding: str = &#34;utf-8&#34;):
        &#34;&#34;&#34;
        Encodes a string or bytestring into a packed byte string

        Args:
            value (Union[str, bytes]): The string/bytestring to encode
            encoding (str): The encoding to user for the string

        Returns:
            bytes: Packed byte string containing the source data
        &#34;&#34;&#34;
        if not isinstance(value, str):
            raise _EX.InvalidFieldDataException(
                f&#34;Expected str, got {value.__class__.__name__}&#34;
            )
        return BytestringField.encode(value.encode(encoding))

    @staticmethod
    def decode(data: bytes, encoding: str = &#34;utf-8&#34;) -&gt; Tuple[str, bytes]:
        &#34;&#34;&#34;
        Unpacks the next string from a packed byte string

        Args:
            data (bytes): The packed byte string to unpack

        Returns:
            tuple(bytes, bytes):  The next block of bytes from the packed byte
                                  string and remainder of the data
        &#34;&#34;&#34;
        value, data = BytestringField.decode(data)

        return value.decode(encoding), data

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validate the field data
        &#34;&#34;&#34;
        if not isinstance(self.value, str):
            return _EX.InvalidFieldDataException(
                f&#34;Passed value type ({type(self.value)}) is not a string&#34;
            )

        return True


class Integer32Field(CertificateField):
    &#34;&#34;&#34;
    Certificate field representing a 32-bit integer
    &#34;&#34;&#34;

    @staticmethod
    def encode(value: int) -&gt; bytes:
        &#34;&#34;&#34;Encodes a 32-bit integer value to a packed byte string

        Args:
            source_int (int): Integer to be packed

        Returns:
            bytes: Packed byte string containing integer
        &#34;&#34;&#34;
        if not isinstance(value, int):
            raise _EX.InvalidFieldDataException(
                f&#34;Expected int, got {value.__class__.__name__}&#34;
            )

        return pack(&#34;&gt;I&#34;, value)

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[int, bytes]:
        &#34;&#34;&#34;Decodes a 32-bit integer from a block of bytes

        Args:
            data (bytes): Block of bytes containing an integer

        Returns:
            tuple: Tuple with integer and remainder of data
        &#34;&#34;&#34;
        return int(unpack(&#34;&gt;I&#34;, data[:4])[0]), data[4:]

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validate the field data
        &#34;&#34;&#34;
        if not isinstance(self.value, int):
            return _EX.InvalidFieldDataException(
                f&#34;Passed value type ({type(self.value)}) is not an integer&#34;
            )

        if self.value &gt; MAX_INT32:
            return _EX.IntegerOverflowException(
                f&#34;Passed value {self.value} is too large for a 32-bit integer&#34;
            )

        return True


class Integer64Field(CertificateField):
    &#34;&#34;&#34;
    Certificate field representing a 64-bit integer
    &#34;&#34;&#34;

    @staticmethod
    def encode(value: int) -&gt; bytes:
        &#34;&#34;&#34;Encodes a 64-bit integer value to a packed byte string

        Args:
            source_int (int): Integer to be packed

        Returns:
            bytes: Packed byte string containing integer
        &#34;&#34;&#34;
        if not isinstance(value, int):
            raise _EX.InvalidFieldDataException(
                f&#34;Expected int, got {value.__class__.__name__}&#34;
            )

        return pack(&#34;&gt;Q&#34;, value)

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[int, bytes]:
        &#34;&#34;&#34;Decodes a 64-bit integer from a block of bytes

        Args:
            data (bytes): Block of bytes containing an integer

        Returns:
            tuple: Tuple with integer and remainder of data
        &#34;&#34;&#34;
        return int(unpack(&#34;&gt;Q&#34;, data[:8])[0]), data[8:]

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validate the field data
        &#34;&#34;&#34;
        if not isinstance(self.value, int):
            return _EX.InvalidFieldDataException(
                f&#34;Passed value type ({type(self.value)}) is not an integer&#34;
            )

        if self.value &gt; MAX_INT64:
            return _EX.IntegerOverflowException(
                f&#34;Passed value {self.value} is too large for a 64-bit integer&#34;
            )

        return True


class DateTimeField(Integer64Field):
    &#34;&#34;&#34;
    Certificate field representing a datetime value.
    The value is saved as a 64-bit integer (unix timestamp)
    &#34;&#34;&#34;

    @staticmethod
    def encode(value: Union[datetime, int]) -&gt; bytes:
        &#34;&#34;&#34;Encodes a datetime object to a byte string

        Args:
            value (datetime): Datetime object

        Returns:
            bytes: Packed byte string containing datetime timestamp
        &#34;&#34;&#34;
        if not isinstance(value, (datetime, int)):
            raise _EX.InvalidFieldDataException(
                f&#34;Expected datetime, got {value.__class__.__name__}&#34;
            )

        if isinstance(value, datetime):
            value = int(value.timestamp())

        return Integer64Field.encode(value)

    @staticmethod
    def decode(data: bytes) -&gt; datetime:
        &#34;&#34;&#34;Decodes a datetime object from a block of bytes

        Args:
            data (bytes): Block of bytes containing a datetime object

        Returns:
            tuple: Tuple with datetime and remainder of data
        &#34;&#34;&#34;
        timestamp, data = Integer64Field.decode(data)

        return datetime.fromtimestamp(timestamp), data

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validate the field data
        &#34;&#34;&#34;
        if not isinstance(self.value, (datetime, int)):
            return _EX.InvalidFieldDataException(
                f&#34;Passed value type ({type(self.value)}) is not a datetime object&#34;
            )

        return True


class MpIntegerField(BytestringField):
    &#34;&#34;&#34;
    Certificate field representing a multiple precision integer,
    an integer too large to fit in 64 bits.
    &#34;&#34;&#34;

    @staticmethod
    # pylint: disable=arguments-differ
    def encode(value: int) -&gt; bytes:
        &#34;&#34;&#34;
        Encodes a multiprecision integer (integer larger than 64bit)
        into a packed byte string

        Args:
            value (int): Large integer

        Returns:
            bytes: Packed byte string containing integer
        &#34;&#34;&#34;
        if not isinstance(value, int):
            raise _EX.InvalidFieldDataException(
                f&#34;Expected int, got {value.__class__.__name__}&#34;
            )

        return BytestringField.encode(long_to_bytes(value))

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[int, bytes]:
        &#34;&#34;&#34;Decodes a multiprecision integer (integer larger than 64bit)

        Args:
            data (bytes): Block of bytes containing a long (mp) integer

        Returns:
            tuple: Tuple with integer and remainder of data
        &#34;&#34;&#34;
        mpint, data = BytestringField.decode(data)
        return bytes_to_long(mpint), data

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validate the field data
        &#34;&#34;&#34;
        if not isinstance(self.value, int):
            return _EX.InvalidFieldDataException(
                f&#34;Passed value type ({type(self.value)}) is not an integer&#34;
            )

        return True


class ListField(CertificateField):
    &#34;&#34;&#34;
    Certificate field representing a list or tuple of strings
    &#34;&#34;&#34;

    @staticmethod
    def encode(value: Union[list, tuple, set]) -&gt; bytes:
        &#34;&#34;&#34;Encodes a list or tuple to a byte string

        Args:
            source_list (list): list of strings
            null_separator (bool, optional): Insert blank string string between items. Default None

        Returns:
            bytes: Packed byte string containing the source data
        &#34;&#34;&#34;
        if not isinstance(value, (list, tuple, set)):
            raise _EX.InvalidFieldDataException(
                f&#34;Expected (list, tuple, set), got {value.__class__.__name__}&#34;
            )

        try:
            if sum([not isinstance(item, (str, bytes)) for item in value]) &gt; 0:
                raise TypeError
        except TypeError:
            raise _EX.InvalidFieldDataException(
                &#34;Expected list or tuple containing strings or bytes&#34;
            ) from TypeError

        return BytestringField.encode(b&#34;&#34;.join([StringField.encode(x) for x in value]))

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[list, bytes]:
        &#34;&#34;&#34;Decodes a list of strings from a block of bytes

        Args:
            data (bytes): The block of bytes containing a list of strings
        Returns:
            tuple: _description_
        &#34;&#34;&#34;
        list_bytes, data = BytestringField.decode(data)

        decoded = []
        while len(list_bytes) &gt; 0:
            elem, list_bytes = StringField.decode(list_bytes)
            decoded.append(elem)

        return decoded, data

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validate the field data
        &#34;&#34;&#34;
        if not isinstance(self.value, (list, tuple)):
            return _EX.InvalidFieldDataException(
                f&#34;Passed value type ({type(self.value)}) is not a list/tuple&#34;
            )

        if sum([not isinstance(item, (str, bytes)) for item in self.value]) &gt; 0:
            return _EX.InvalidFieldDataException(
                &#34;Expected list or tuple containing strings or bytes&#34;
            )

        return True


class KeyValueField(CertificateField):
    &#34;&#34;&#34;
    Certificate field representing a list or integer in python,
    separated in byte-form by null-bytes.
    &#34;&#34;&#34;

    @staticmethod
    def encode(value: Union[list, tuple, dict, set]) -&gt; bytes:
        &#34;&#34;&#34;
        Encodes a dict, set, list or tuple into a key-value byte string.
        If a set, list or tuple is provided, the items are considered keys
        and added with empty values.

        Args:
            source_list (dict, set, list, tuple): list of strings

        Returns:
            bytes: Packed byte string containing the source data
        &#34;&#34;&#34;
        if not isinstance(value, (list, tuple, dict, set)):
            raise _EX.InvalidFieldDataException(
                f&#34;Expected (list, tuple), got {value.__class__.__name__}&#34;
            )

        if not isinstance(value, dict):
            value = {item: &#34;&#34; for item in value}

        list_data = b&#34;&#34;

        for key, item in value.items():
            list_data += StringField.encode(key)

            item = (
                StringField.encode(item)
                if item in [&#34;&#34;, b&#34;&#34;]
                else ListField.encode(
                    [item] if isinstance(item, (str, bytes)) else item
                )
            )

            list_data += item

        return BytestringField.encode(list_data)

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[dict, bytes]:
        &#34;&#34;&#34;Decodes a list of strings from a block of bytes

        Args:
            data (bytes): The block of bytes containing a list of strings
        Returns:
            tuple: _description_
        &#34;&#34;&#34;
        list_bytes, data = BytestringField.decode(data)

        decoded = {}
        while len(list_bytes) &gt; 0:
            key, list_bytes = StringField.decode(list_bytes)
            value, list_bytes = BytestringField.decode(list_bytes)

            if value != b&#34;&#34;:
                value = StringField.decode(value)[0]

            decoded[key] = &#34;&#34; if value == b&#34;&#34; else value

        if &#34;&#34;.join(decoded.values()) == &#34;&#34;:
            return list(decoded.keys()), data

        return decoded, data

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validate the field data
        &#34;&#34;&#34;
        if not isinstance(self.value, (list, tuple, dict, set)):
            return _EX.InvalidFieldDataException(
                f&#34;Passed value type ({type(self.value)}) is not a list/tuple/dict/set&#34;
            )

        if isinstance(self.value, (dict)):
            if (
                sum([not isinstance(item, (str, bytes)) for item in self.value.keys()])
                &gt; 0
            ):
                return _EX.InvalidFieldDataException(
                    &#34;Expected a dict with string or byte keys&#34;
                )

        if (
            isinstance(self.value, (list, tuple, set))
            and sum([not isinstance(item, (str, bytes)) for item in self.value]) &gt; 0
        ):
            return _EX.InvalidFieldDataException(
                &#34;Expected list, tuple or set containing strings or bytes&#34;
            )

        return True


class PubkeyTypeField(StringField):
    &#34;&#34;&#34;
    Contains the certificate type, which is based on the
    public key type the certificate is created for, e.g.
    &#39;ssh-ed25519-cert-v01@openssh.com&#39; for an ED25519 key
    &#34;&#34;&#34;

    def __init__(self, value: str):
        super().__init__(
            value=value,
            name=&#34;pubkey_type&#34;,
        )

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validate the field data
        &#34;&#34;&#34;
        if self.value not in (
            &#34;ssh-rsa-cert-v01@openssh.com&#34;,
            &#34;rsa-sha2-256-cert-v01@openssh.com&#34;,
            &#34;rsa-sha2-512-cert-v01@openssh.com&#34;,
            &#34;ssh-dss-cert-v01@openssh.com&#34;,
            &#34;ecdsa-sha2-nistp256-cert-v01@openssh.com&#34;,
            &#34;ecdsa-sha2-nistp384-cert-v01@openssh.com&#34;,
            &#34;ecdsa-sha2-nistp521-cert-v01@openssh.com&#34;,
            &#34;ssh-ed25519-cert-v01@openssh.com&#34;,
        ):
            return _EX.InvalidDataException(f&#34;Invalid pubkey type: {self.value}&#34;)

        return True


class NonceField(StringField):
    &#34;&#34;&#34;
    Contains the nonce for the certificate, randomly generated
    this protects the integrity of the private key, especially
    for ecdsa.
    &#34;&#34;&#34;

    def __init__(self, value: str = None):
        super().__init__(
            value=value if value is not None else generate_secure_nonce(), name=&#34;nonce&#34;
        )

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validate the field data
        &#34;&#34;&#34;
        if len(self.value) &lt; 32:
            self.exception = _EX.InsecureNonceException(
                &#34;Nonce should be at least 32 bytes long to be secure. &#34;
                + &#34;This is especially important for ECDSA&#34;
            )
            return False

        return True


class PublicKeyField(CertificateField):
    &#34;&#34;&#34;
    Contains the subject (User or Host) public key for whom/which
    the certificate is created.
    &#34;&#34;&#34;

    def __init__(self, value: PublicKey):
        super().__init__(value=value, name=&#34;public_key&#34;)

    def __str__(self) -&gt; str:
        return &#34; &#34;.join(
            [
                self.__class__.__name__.replace(&#34;PubkeyField&#34;, &#34;&#34;),
                self.value.get_fingerprint(),
            ]
        )

    @staticmethod
    def encode(value: PublicKey) -&gt; bytes:
        &#34;&#34;&#34;
        Encode the certificate field to a byte string

        Args:
            value (RsaPublicKey): The public key to encode

        Returns:
            bytes: A byte string with the encoded public key
        &#34;&#34;&#34;
        if not isinstance(value, PublicKey):
            raise _EX.InvalidFieldDataException(
                f&#34;Expected PublicKey, got {value.__class__.__name__}&#34;
            )

        return BytestringField.decode(value.raw_bytes())[1]

    @staticmethod
    def from_object(public_key: PublicKey):
        &#34;&#34;&#34;
        Loads the public key from a sshkey_tools.keys.PublicKey
        class or childclass

        Args:
            public_key (PublicKey): The public key for which to
                                    create the certificate

        Raises:
            _EX.InvalidKeyException: Invalid public key

        Returns:
            PublicKeyField: A child class of PublicKeyField specific
                            to the chosen public key
        &#34;&#34;&#34;
        try:
            return globals()[SUBJECT_PUBKEY_MAP[public_key.__class__]](value=public_key)
        except KeyError:
            raise _EX.InvalidKeyException(&#34;The public key is invalid&#34;) from KeyError


class RSAPubkeyField(PublicKeyField):
    &#34;&#34;&#34;
    Holds the RSA Public Key for RSA Certificates
    &#34;&#34;&#34;

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[RsaPublicKey, bytes]:
        &#34;&#34;&#34;
        Decode the certificate field from a byte string
        starting with the encoded public key

        Args:
            data (bytes): The byte string starting with the encoded key

        Returns:
            Tuple[RsaPublicKey, bytes]: The PublicKey field and remainder of the data
        &#34;&#34;&#34;
        e, data = MpIntegerField.decode(data)
        n, data = MpIntegerField.decode(data)

        return RsaPublicKey.from_numbers(e=e, n=n), data

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates that the field data is a valid RSA Public Key
        &#34;&#34;&#34;
        if not isinstance(self.value, RsaPublicKey):
            return _EX.InvalidFieldDataException(
                &#34;This public key class is not valid for use in a certificate&#34;
            )

        return True


class DSAPubkeyField(PublicKeyField):
    &#34;&#34;&#34;
    Holds the DSA Public Key for DSA Certificates
    &#34;&#34;&#34;

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[DsaPublicKey, bytes]:
        &#34;&#34;&#34;
        Decode the certificate field from a byte string
        starting with the encoded public key

        Args:
            data (bytes): The byte string starting with the encoded key

        Returns:
            Tuple[RsaPublicKey, bytes]: The PublicKey field and remainder of the data
        &#34;&#34;&#34;
        p, data = MpIntegerField.decode(data)
        q, data = MpIntegerField.decode(data)
        g, data = MpIntegerField.decode(data)
        y, data = MpIntegerField.decode(data)

        return DsaPublicKey.from_numbers(p=p, q=q, g=g, y=y), data

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates that the field data is a valid DSA Public Key
        &#34;&#34;&#34;
        if not isinstance(self.value, DsaPublicKey):
            return _EX.InvalidFieldDataException(
                &#34;This public key class is not valid for use in a certificate&#34;
            )

        return True


class ECDSAPubkeyField(PublicKeyField):
    &#34;&#34;&#34;
    Holds the ECDSA Public Key for ECDSA Certificates
    &#34;&#34;&#34;

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[EcdsaPublicKey, bytes]:
        &#34;&#34;&#34;
        Decode the certificate field from a byte string
        starting with the encoded public key

        Args:
            data (bytes): The byte string starting with the encoded key

        Returns:
            Tuple[ECPublicKey, bytes]: The PublicKey field and remainder of the data
        &#34;&#34;&#34;
        curve, data = StringField.decode(data)
        key, data = BytestringField.decode(data)

        key_type = &#34;ecdsa-sha2-&#34; + curve

        return (
            EcdsaPublicKey.from_string(
                key_type
                + &#34; &#34;
                + b64encode(
                    StringField.encode(key_type)
                    + StringField.encode(curve)
                    + BytestringField.encode(key)
                ).decode(&#34;utf-8&#34;)
            ),
            data,
        )

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates that the field data is a valid ECDSA Public Key
        &#34;&#34;&#34;
        if not isinstance(self.value, EcdsaPublicKey):
            return _EX.InvalidFieldDataException(
                &#34;This public key class is not valid for use in a certificate&#34;
            )

        return True


class ED25519PubkeyField(PublicKeyField):
    &#34;&#34;&#34;
    Holds the ED25519 Public Key for ED25519 Certificates
    &#34;&#34;&#34;

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[Ed25519PublicKey, bytes]:
        &#34;&#34;&#34;
        Decode the certificate field from a byte string
        starting with the encoded public key

        Args:
            data (bytes): The byte string starting with the encoded key

        Returns:
            Tuple[Ed25519PublicKey, bytes]: The PublicKey field and remainder of the data
        &#34;&#34;&#34;
        pubkey, data = BytestringField.decode(data)

        return Ed25519PublicKey.from_raw_bytes(pubkey), data

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates that the field data is a valid ED25519 Public Key
        &#34;&#34;&#34;
        if not isinstance(self.value, Ed25519PublicKey):
            return _EX.InvalidFieldDataException(
                &#34;This public key class is not valid for use in a certificate&#34;
            )

        return True


class SerialField(Integer64Field):
    &#34;&#34;&#34;
    Contains the numeric serial number of the certificate,
    maximum is (2**64)-1
    &#34;&#34;&#34;

    def __init__(self, value: int):
        super().__init__(value=value, name=&#34;serial&#34;)


class CertificateTypeField(Integer32Field):
    &#34;&#34;&#34;
    Contains the certificate type
    User certificate: CERT_TYPE.USER/1
    Host certificate: CERT_TYPE.HOST/2
    &#34;&#34;&#34;

    def __init__(self, value: Union[CERT_TYPE, int]):
        super().__init__(
            value=value.value if isinstance(value, CERT_TYPE) else value, name=&#34;type&#34;
        )

    @staticmethod
    def encode(value: Union[CERT_TYPE, int]) -&gt; bytes:
        &#34;&#34;&#34;
        Encode the certificate type field to a byte string

        Args:
            value (Union[CERT_TYPE, int]): The type of the certificate

        Returns:
            bytes: A byte string with the encoded public key
        &#34;&#34;&#34;
        if not isinstance(value, (CERT_TYPE, int)):
            raise _EX.InvalidFieldDataException(
                f&#34;Expected (CERT_TYPE, int), got {value.__class__.__name__}&#34;
            )

        if isinstance(value, CERT_TYPE):
            value = value.value

        return Integer32Field.encode(value)

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates that the field contains a valid type
        &#34;&#34;&#34;
        if not isinstance(self.value, (CERT_TYPE, int)):
            return _EX.InvalidFieldDataException(
                f&#34;Passed value type ({type(self.value)}) is not an integer&#34;
            )

        if not isinstance(self.value, CERT_TYPE) and (self.value &gt; 2 or self.value &lt; 1):
            return _EX.InvalidDataException(
                &#34;The certificate type is invalid (1: User, 2: Host)&#34;
            )

        return True


class KeyIDField(StringField):
    &#34;&#34;&#34;
    Contains the key identifier (subject) of the certificate,
    alphanumeric string
    &#34;&#34;&#34;

    def __init__(self, value: str):
        super().__init__(value=value, name=&#34;key_id&#34;)

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates that the field is set and not empty
        &#34;&#34;&#34;
        if self.value in [None, False, &#34;&#34;, &#34; &#34;]:
            return _EX.InvalidDataException(&#34;You need to provide a Key ID&#34;)

        return super().validate()


class PrincipalsField(ListField):
    &#34;&#34;&#34;
    Contains a list of principals for the certificate,
    e.g. SERVERHOSTNAME01 or all-web-servers
    &#34;&#34;&#34;

    def __init__(self, value: Union[list, tuple]):
        super().__init__(value=list(value), name=&#34;principals&#34;)


class ValidityStartField(DateTimeField):
    &#34;&#34;&#34;
    Contains the start of the validity period for the certificate,
    represented by a datetime object
    &#34;&#34;&#34;

    def __init__(self, value: datetime):
        super().__init__(value=value, name=&#34;valid_after&#34;)


class ValidityEndField(DateTimeField):
    &#34;&#34;&#34;
    Contains the end of the validity period for the certificate,
    represented by a datetime object
    &#34;&#34;&#34;

    def __init__(self, value: datetime):
        super().__init__(value=value, name=&#34;valid_before&#34;)


class CriticalOptionsField(KeyValueField):
    &#34;&#34;&#34;
    Contains the critical options part of the certificate (optional).
    This should be a list of strings with one of the following

    options:
        force-command=&lt;command&gt;
            Limits the connecting user to a specific command,
            e.g. sftp-internal
        source-address=&lt;ip_address&gt;
            Limits the user to connect only from a certain
            ip, subnet or host
        verify-required=&lt;true|false&gt;
            If set to true, the user must verify their identity
            if using a hardware token
    &#34;&#34;&#34;

    def __init__(self, value: Union[list, tuple, dict]):
        super().__init__(value=value, name=&#34;critical_options&#34;)

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validate that the field contains a valid list of options
        &#34;&#34;&#34;
        valid_opts = (&#34;force-command&#34;, &#34;source-address&#34;, &#34;verify-required&#34;)

        if not isinstance(self.value, (list, tuple, dict, set)):
            return _EX.InvalidFieldDataException(
                &#34;You need to provide a list, tuple or set of strings or a dict&#34;
            )

        if not all(
            elem in valid_opts
            for elem in (
                self.value.keys() if isinstance(self.value, dict) else self.value
            )
        ):
            return _EX.InvalidFieldDataException(
                &#34;You have provided invalid data to the critical options field&#34;
            )

        return True


class ExtensionsField(KeyValueField):
    &#34;&#34;&#34;
    Contains a list of extensions for the certificate,
    set to give the user limitations and/or additional
    privileges on the host.

    flags:
        no-touch-required
            The user doesn&#39;t need to touch the
            physical key to authenticate.

        permit-X11-forwarding
            Permits the user to use X11 Forwarding

        permit-agent-forwarding
            Permits the user to use agent forwarding

        permit-port-forwarding
            Permits the user to forward ports

        permit-pty
            Permits the user to use a pseudo-terminal

        permit-user-rc
            Permits the user to use the user rc file

    &#34;&#34;&#34;

    def __init__(self, value: Union[list, tuple]):
        super().__init__(value=value, name=&#34;extensions&#34;)

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates that the options provided are valid
        &#34;&#34;&#34;
        valid_opts = (
            &#34;no-touch-required&#34;,
            &#34;permit-X11-forwarding&#34;,
            &#34;permit-agent-forwarding&#34;,
            &#34;permit-port-forwarding&#34;,
            &#34;permit-pty&#34;,
            &#34;permit-user-rc&#34;,
        )

        for item in self.value:
            if item not in valid_opts:
                return _EX.InvalidDataException(f&#34;The extension &#39;{item}&#39; is invalid&#34;)

        return True


class ReservedField(StringField):
    &#34;&#34;&#34;
    This field is reserved for future use, and
    doesn&#39;t contain any actual data, just an empty string.
    &#34;&#34;&#34;

    def __init__(self, value: str = &#34;&#34;):
        super().__init__(value=value, name=&#34;reserved&#34;)

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validate that the field only contains an empty string
        &#34;&#34;&#34;
        if self.value == &#34;&#34;:
            return True

        return _EX.InvalidDataException(
            &#34;The reserved field needs to be an empty string&#34;
        )


class CAPublicKeyField(BytestringField):
    &#34;&#34;&#34;
    Contains the public key of the certificate authority
    that is used to sign the certificate.
    &#34;&#34;&#34;

    def __init__(self, value: PublicKey):
        super().__init__(value=value, name=&#34;ca_public_key&#34;)

    def __str__(self) -&gt; str:
        return &#34; &#34;.join(
            [
                (
                    self.value.__class__.__name__.replace(&#34;PublicKey&#34;, &#34;&#34;).replace(
                        &#34;EllipticCurve&#34;, &#34;ECDSA&#34;
                    )
                ),
                self.value.get_fingerprint(),
            ]
        )

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the contents of the field
        &#34;&#34;&#34;
        if self.value in [None, False, &#34;&#34;, &#34; &#34;]:
            return _EX.InvalidFieldDataException(&#34;You need to provide a CA public key&#34;)

        if not isinstance(self.value, PublicKey):
            return _EX.InvalidFieldDataException(
                &#34;The CA public key needs to be a sshkey_tools.keys.PublicKey object&#34;
            )

        return True

    @staticmethod
    def decode(data) -&gt; Tuple[PublicKey, bytes]:
        &#34;&#34;&#34;
        Decode the certificate field from a byte string
        starting with the encoded public key

        Args:
            data (bytes): The byte string starting with the encoded key

        Returns:
            Tuple[PublicKey, bytes]: The PublicKey field and remainder of the data
        &#34;&#34;&#34;
        pubkey, data = BytestringField.decode(data)
        pubkey_type = StringField.decode(pubkey)[0]

        return (
            PublicKey.from_string(f&#34;{pubkey_type} {b64encode(pubkey).decode(&#39;utf-8&#39;)}&#34;),
            data,
        )

    def __bytes__(self) -&gt; bytes:
        return self.encode(self.value.raw_bytes())

    @classmethod
    def from_object(cls, public_key: PublicKey) -&gt; &#34;CAPublicKeyField&#34;:
        &#34;&#34;&#34;
        Creates a new CAPublicKeyField from a PublicKey object
        &#34;&#34;&#34;
        return cls(value=public_key)


class SignatureField(CertificateField):
    &#34;&#34;&#34;
    Creates and contains the signature of the certificate
    &#34;&#34;&#34;

    # pylint: disable=super-init-not-called
    def __init__(self, private_key: PrivateKey = None, signature: bytes = None):
        self.name = &#34;signature&#34;
        self.private_key = private_key
        self.is_signed = False
        self.value = signature

    @staticmethod
    def from_object(private_key: PrivateKey):
        &#34;&#34;&#34;
        Load a private key from a PrivateKey object


        Args:
            private_key (PrivateKey): Private key to use for signing

        Raises:
            _EX.InvalidKeyException: Invalid private key

        Returns:
            SignatureField: SignatureField child class
        &#34;&#34;&#34;
        try:
            return globals()[CA_SIGNATURE_MAP[private_key.__class__]](
                private_key=private_key
            )
        except KeyError:
            raise _EX.InvalidKeyException(
                &#34;The private key provided is invalid or not supported&#34;
            ) from KeyError

    @staticmethod
    def from_decode(data: bytes) -&gt; Tuple[&#34;SignatureField&#34;, bytes]:
        &#34;&#34;&#34;
        Generates a SignatureField child class from the encoded signature

        Args:
            data (bytes): The bytestring containing the encoded signature

        Raises:
            _EX.InvalidDataException: Invalid data

        Returns:
            SignatureField: child of SignatureField
        &#34;&#34;&#34;
        signature, _ = BytestringField.decode(data)
        signature_type = BytestringField.decode(signature)[0]

        for key, value in SIGNATURE_TYPE_MAP.items():
            if key in signature_type:
                return globals()[value].from_decode(data)

        raise _EX.InvalidDataException(&#34;No matching signature type found&#34;)

    def can_sign(self):
        &#34;&#34;&#34;
        Determines if a signature can be generated from
        this private key
        &#34;&#34;&#34;
        return self.private_key is not None

    def sign(self, data: bytes) -&gt; None:
        &#34;&#34;&#34;
        Placeholder signing function
        &#34;&#34;&#34;

    def __bytes__(self) -&gt; None:
        return self.encode(self.value)


class RSASignatureField(SignatureField):
    &#34;&#34;&#34;
    Creates and contains the RSA signature from an RSA Private Key
    &#34;&#34;&#34;

    def __init__(
        self,
        private_key: RsaPrivateKey = None,
        hash_alg: RsaAlgs = RsaAlgs.SHA512,
        signature: bytes = None,
    ):
        super().__init__(private_key, signature)
        self.hash_alg = hash_alg

    @staticmethod
    # pylint: disable=arguments-renamed
    def encode(signature: bytes, hash_alg: RsaAlgs = RsaAlgs.SHA256) -&gt; bytes:
        &#34;&#34;&#34;
        Encodes the signature to a byte string

        Args:
            signature (bytes): The signature bytes to encode
            hash_alg (RsaAlgs, optional):  The hash algorithm used for the signature.
                                            Defaults to RsaAlgs.SHA256.

        Returns:
            bytes: The encoded byte string
        &#34;&#34;&#34;
        if not isinstance(signature, bytes):
            raise _EX.InvalidFieldDataException(
                f&#34;Expected bytes, got {signature.__class__.__name__}&#34;
            )

        return BytestringField.encode(
            StringField.encode(hash_alg.value[0]) + BytestringField.encode(signature)
        )

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[Tuple[bytes, bytes], bytes]:
        &#34;&#34;&#34;
        Decodes a bytestring containing a signature

        Args:
            data (bytes): The bytestring starting with the RSA Signature

        Returns:
            Tuple[ Tuple[ bytes, bytes ], bytes ]: (signature_type, signature), remainder of data
        &#34;&#34;&#34;
        signature, data = BytestringField.decode(data)

        sig_type, signature = StringField.decode(signature)
        signature, _ = BytestringField.decode(signature)

        return (sig_type, signature), data

    @classmethod
    def from_decode(cls, data: bytes) -&gt; Tuple[&#34;RSASignatureField&#34;, bytes]:
        &#34;&#34;&#34;
        Generates an RSASignatureField class from the encoded signature

        Args:
            data (bytes): The bytestring containing the encoded signature

        Raises:
            _EX.InvalidDataException: Invalid data

        Returns:
            Tuple[RSASignatureField, bytes]: RSA Signature field and remainder of data
        &#34;&#34;&#34;
        signature, data = cls.decode(data)

        return (
            cls(
                private_key=None,
                hash_alg=[alg for alg in RsaAlgs if alg.value[0] == signature[0]][0],
                signature=signature[1],
            ),
            data,
        )

    def sign(self, data: bytes, hash_alg: RsaAlgs = RsaAlgs.SHA256) -&gt; None:
        &#34;&#34;&#34;
        Signs the provided data with the provided private key

        Args:
            data (bytes): The data to be signed
            hash_alg (RsaAlgs, optional): The RSA algorithm to use for hashing.
                                           Defaults to RsaAlgs.SHA256.
        &#34;&#34;&#34;
        self.value = self.private_key.sign(data, hash_alg)

        self.hash_alg = hash_alg
        self.is_signed = True

    def __bytes__(self):
        return self.encode(self.value, self.hash_alg)


class DSASignatureField(SignatureField):
    &#34;&#34;&#34;
    Creates and contains the DSA signature from an DSA Private Key
    &#34;&#34;&#34;

    def __init__(
        self, private_key: DsaPrivateKey = None, signature: bytes = None
    ) -&gt; None:
        super().__init__(private_key, signature)

    @staticmethod
    # pylint: disable=arguments-renamed
    def encode(signature: bytes):
        &#34;&#34;&#34;
        Encodes the signature to a byte string

        Args:
            signature (bytes): The signature bytes to encode

        Returns:
            bytes: The encoded byte string
        &#34;&#34;&#34;
        if not isinstance(signature, bytes):
            raise _EX.InvalidFieldDataException(
                f&#34;Expected bytes, got {signature.__class__.__name__}&#34;
            )

        r, s = decode_dss_signature(signature)

        return BytestringField.encode(
            StringField.encode(&#34;ssh-dss&#34;)
            + BytestringField.encode(long_to_bytes(r, 20) + long_to_bytes(s, 20))
        )

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[bytes, bytes]:
        &#34;&#34;&#34;
        Decodes a bytestring containing a signature

        Args:
            data (bytes): The bytestring starting with the Signature

        Returns:
            Tuple[ bytes, bytes ]: signature, remainder of the data
        &#34;&#34;&#34;
        signature, data = BytestringField.decode(data)

        signature = BytestringField.decode(BytestringField.decode(signature)[1])[0]
        r = bytes_to_long(signature[:20])
        s = bytes_to_long(signature[20:])

        signature = encode_dss_signature(r, s)

        return signature, data

    @classmethod
    def from_decode(cls, data: bytes) -&gt; Tuple[&#34;DSASignatureField&#34;, bytes]:
        &#34;&#34;&#34;
        Creates a signature field class from the encoded signature

        Args:
            data (bytes): The bytestring starting with the Signature

        Returns:
            Tuple[ DSASignatureField, bytes ]: signature, remainder of the data
        &#34;&#34;&#34;
        signature, data = cls.decode(data)

        return cls(private_key=None, signature=signature), data

    def sign(self, data: bytes) -&gt; None:
        &#34;&#34;&#34;
        Signs the provided data with the provided private key

        Args:
            data (bytes): The data to be signed
        &#34;&#34;&#34;
        self.value = self.private_key.sign(data)
        self.is_signed = True


class ECDSASignatureField(SignatureField):
    &#34;&#34;&#34;
    Creates and contains the ECDSA signature from an ECDSA Private Key
    &#34;&#34;&#34;

    def __init__(
        self,
        private_key: EcdsaPrivateKey = None,
        signature: bytes = None,
        curve_name: str = None,
    ) -&gt; None:
        super().__init__(private_key, signature)

        if curve_name is None:
            curve_size = self.private_key.public_key.key.curve.key_size
            curve_name = f&#34;ecdsa-sha2-nistp{curve_size}&#34;

        self.curve = curve_name

    @staticmethod
    # pylint: disable=arguments-renamed
    def encode(signature: bytes, curve_name: str = None) -&gt; bytes:
        &#34;&#34;&#34;
        Encodes the signature to a byte string

        Args:
            signature (bytes): The signature bytes to encode
            curve_name (str): The name of the curve used for the signature
                              private key

        Returns:
            bytes: The encoded byte string
        &#34;&#34;&#34;
        if not isinstance(signature, bytes):
            raise _EX.InvalidFieldDataException(
                f&#34;Expected bytes, got {signature.__class__.__name__}&#34;
            )

        r, s = decode_dss_signature(signature)

        return BytestringField.encode(
            StringField.encode(curve_name)
            + BytestringField.encode(
                MpIntegerField.encode(r) + MpIntegerField.encode(s)
            )
        )

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[Tuple[bytes, bytes], bytes]:
        &#34;&#34;&#34;
        Decodes a bytestring containing a signature

        Args:
            data (bytes): The bytestring starting with the Signature

        Returns:
            Tuple[ Tuple[ bytes, bytes ], bytes]: (curve, signature), remainder of the data
        &#34;&#34;&#34;
        signature, data = BytestringField.decode(data)

        curve, signature = StringField.decode(signature)
        signature, _ = BytestringField.decode(signature)

        r, signature = MpIntegerField.decode(signature)
        s, _ = MpIntegerField.decode(signature)

        signature = encode_dss_signature(r, s)

        return (curve, signature), data

    @classmethod
    def from_decode(cls, data: bytes) -&gt; Tuple[&#34;ECDSASignatureField&#34;, bytes]:
        &#34;&#34;&#34;
        Creates a signature field class from the encoded signature

        Args:
            data (bytes): The bytestring starting with the Signature

        Returns:
            Tuple[ ECDSASignatureField , bytes ]: signature, remainder of the data
        &#34;&#34;&#34;
        signature, data = cls.decode(data)

        return (
            cls(private_key=None, signature=signature[1], curve_name=signature[0]),
            data,
        )

    def sign(self, data: bytes) -&gt; None:
        &#34;&#34;&#34;
        Signs the provided data with the provided private key

        Args:
            data (bytes): The data to be signed
        &#34;&#34;&#34;
        self.value = self.private_key.sign(data)
        self.is_signed = True

    def __bytes__(self):
        return self.encode(self.value, self.curve)


class ED25519SignatureField(SignatureField):
    &#34;&#34;&#34;
    Creates and contains the ED25519 signature from an ED25519 Private Key
    &#34;&#34;&#34;

    def __init__(
        <!-- trunk-ignore(gitleaks/generic-api-key) -->
        self, private_key: Ed25519PrivateKey = None, signature: bytes = None
    ) -&gt; None:
        super().__init__(private_key, signature)

    @staticmethod
    # pylint: disable=arguments-renamed
    def encode(signature: bytes) -&gt; None:
        &#34;&#34;&#34;
        Encodes the signature to a byte string

        Args:
            signature (bytes): The signature bytes to encode

        Returns:
            bytes: The encoded byte string
        &#34;&#34;&#34;
        if not isinstance(signature, bytes):
            raise _EX.InvalidFieldDataException(
                f&#34;Expected bytes, got {signature.__class__.__name__}&#34;
            )

        return BytestringField.encode(
            StringField.encode(&#34;ssh-ed25519&#34;) + BytestringField.encode(signature)
        )

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[bytes, bytes]:
        &#34;&#34;&#34;
        Decodes a bytestring containing a signature

        Args:
            data (bytes): The bytestring starting with the Signature

        Returns:
            Tuple[ bytes, bytes ]: signature, remainder of the data
        &#34;&#34;&#34;
        signature, data = BytestringField.decode(data)

        signature = BytestringField.decode(BytestringField.decode(signature)[1])[0]

        return signature, data

    @classmethod
    def from_decode(cls, data: bytes) -&gt; Tuple[&#34;ED25519SignatureField&#34;, bytes]:
        &#34;&#34;&#34;
        Creates a signature field class from the encoded signature

        Args:
            data (bytes): The bytestring starting with the Signature

        Returns:
            Tuple[ ED25519SignatureField , bytes ]: signature, remainder of the data
        &#34;&#34;&#34;
        signature, data = cls.decode(data)

        return cls(private_key=None, signature=signature), data

    def sign(self, data: bytes) -&gt; None:
        &#34;&#34;&#34;
        Signs the provided data with the provided private key

        Args:
            data (bytes): The data to be signed
            hash_alg (RsaAlgs, optional): The RSA algorithm to use for hashing.
                                           Defaults to RsaAlgs.SHA256.
        &#34;&#34;&#34;
        self.value = self.private_key.sign(data)
        self.is_signed = True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sshkey_tools.fields.decode_dss_signature"><code class="name flex">
<span>def <span class="ident">decode_dss_signature</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sshkey_tools.fields.encode_dss_signature"><code class="name flex">
<span>def <span class="ident">encode_dss_signature</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sshkey_tools.fields.BooleanField"><code class="flex name class">
<span>class <span class="ident">BooleanField</span></span>
<span>(</span><span>value, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Field representing a boolean value (True/False)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BooleanField(CertificateField):
    &#34;&#34;&#34;
    Field representing a boolean value (True/False)
    &#34;&#34;&#34;

    @staticmethod
    def encode(value: bool) -&gt; bytes:
        &#34;&#34;&#34;
        Encodes a boolean value to a byte string

        Args:
            value (bool): Boolean to encode

        Returns:
            bytes: Packed byte representing the boolean
        &#34;&#34;&#34;
        if not isinstance(value, bool):
            raise _EX.InvalidFieldDataException(
                f&#34;Expected bool, got {value.__class__.__name__}&#34;
            )

        return pack(&#34;B&#34;, 1 if value else 0)

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[bool, bytes]:
        &#34;&#34;&#34;
        Decodes a boolean from a bytestring

        Args:
            data (bytes): The byte string starting with an encoded boolean
        &#34;&#34;&#34;
        return bool(unpack(&#34;B&#34;, data[:1])[0]), data[1:]

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validate the field data
        &#34;&#34;&#34;
        if self.value not in [True, False]:
            return _EX.InvalidFieldDataException(
                f&#34;Passed value type ({type(self.value)}) is not a boolean&#34;
            )

        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.BooleanField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data:bytes) >Tuple[bool,bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes a boolean from a bytestring</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The byte string starting with an encoded boolean</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; Tuple[bool, bytes]:
    &#34;&#34;&#34;
    Decodes a boolean from a bytestring

    Args:
        data (bytes): The byte string starting with an encoded boolean
    &#34;&#34;&#34;
    return bool(unpack(&#34;B&#34;, data[:1])[0]), data[1:]</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.BooleanField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>value:bool) >bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes a boolean value to a byte string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>bool</code></dt>
<dd>Boolean to encode</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>Packed byte representing the boolean</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def encode(value: bool) -&gt; bytes:
    &#34;&#34;&#34;
    Encodes a boolean value to a byte string

    Args:
        value (bool): Boolean to encode

    Returns:
        bytes: Packed byte representing the boolean
    &#34;&#34;&#34;
    if not isinstance(value, bool):
        raise _EX.InvalidFieldDataException(
            f&#34;Expected bool, got {value.__class__.__name__}&#34;
        )

    return pack(&#34;B&#34;, 1 if value else 0)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.BooleanField.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) >Union[bool,Exception]</span>
</code></dt>
<dd>
<div class="desc"><p>Validate the field data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; Union[bool, Exception]:
    &#34;&#34;&#34;
    Validate the field data
    &#34;&#34;&#34;
    if self.value not in [True, False]:
        return _EX.InvalidFieldDataException(
            f&#34;Passed value type ({type(self.value)}) is not a boolean&#34;
        )

    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.CertificateField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.BytestringField"><code class="flex name class">
<span>class <span class="ident">BytestringField</span></span>
<span>(</span><span>value, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Field representing a bytestring value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BytestringField(CertificateField):
    &#34;&#34;&#34;
    Field representing a bytestring value
    &#34;&#34;&#34;

    @staticmethod
    def encode(value: bytes) -&gt; bytes:
        &#34;&#34;&#34;
        Encodes a string or bytestring into a packed byte string

        Args:
            value (Union[str, bytes]): The string/bytestring to encode
            encoding (str): The encoding to user for the string

        Returns:
            bytes: Packed byte string containing the source data
        &#34;&#34;&#34;
        if not isinstance(value, bytes):
            raise _EX.InvalidFieldDataException(
                f&#34;Expected bytes, got {value.__class__.__name__}&#34;
            )

        return pack(&#34;&gt;I&#34;, len(value)) + value

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[bytes, bytes]:
        &#34;&#34;&#34;
        Unpacks the next string from a packed byte string

        Args:
            data (bytes): The packed byte string to unpack

        Returns:
            tuple(bytes, bytes):  The next block of bytes from the packed byte
                                  string and remainder of the data
        &#34;&#34;&#34;
        length = unpack(&#34;&gt;I&#34;, data[:4])[0] + 4
        return data[4:length], data[length:]

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validate the field data
        &#34;&#34;&#34;
        if not isinstance(self.value, bytes):
            return _EX.InvalidFieldDataException(
                f&#34;Passed value type ({type(self.value)}) is not a bytestring&#34;
            )

        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.CAPublicKeyField" href="#sshkey_tools.fields.CAPublicKeyField">CAPublicKeyField</a></li>
<li><a title="sshkey_tools.fields.MpIntegerField" href="#sshkey_tools.fields.MpIntegerField">MpIntegerField</a></li>
<li><a title="sshkey_tools.fields.StringField" href="#sshkey_tools.fields.StringField">StringField</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.BytestringField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data:bytes) >Tuple[bytes,bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Unpacks the next string from a packed byte string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The packed byte string to unpack</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>tuple(bytes, bytes):
The next block of bytes from the packed byte
string and remainder of the data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; Tuple[bytes, bytes]:
    &#34;&#34;&#34;
    Unpacks the next string from a packed byte string

    Args:
        data (bytes): The packed byte string to unpack

    Returns:
        tuple(bytes, bytes):  The next block of bytes from the packed byte
                              string and remainder of the data
    &#34;&#34;&#34;
    length = unpack(&#34;&gt;I&#34;, data[:4])[0] + 4
    return data[4:length], data[length:]</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.BytestringField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>value:bytes) >bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes a string or bytestring into a packed byte string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>Union[str, bytes]</code></dt>
<dd>The string/bytestring to encode</dd>
<dt><strong><code>encoding</code></strong> :&ensp;<code>str</code></dt>
<dd>The encoding to user for the string</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>Packed byte string containing the source data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def encode(value: bytes) -&gt; bytes:
    &#34;&#34;&#34;
    Encodes a string or bytestring into a packed byte string

    Args:
        value (Union[str, bytes]): The string/bytestring to encode
        encoding (str): The encoding to user for the string

    Returns:
        bytes: Packed byte string containing the source data
    &#34;&#34;&#34;
    if not isinstance(value, bytes):
        raise _EX.InvalidFieldDataException(
            f&#34;Expected bytes, got {value.__class__.__name__}&#34;
        )

    return pack(&#34;&gt;I&#34;, len(value)) + value</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.BytestringField.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) >Union[bool,Exception]</span>
</code></dt>
<dd>
<div class="desc"><p>Validate the field data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; Union[bool, Exception]:
    &#34;&#34;&#34;
    Validate the field data
    &#34;&#34;&#34;
    if not isinstance(self.value, bytes):
        return _EX.InvalidFieldDataException(
            f&#34;Passed value type ({type(self.value)}) is not a bytestring&#34;
        )

    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.CertificateField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.CAPublicKeyField"><code class="flex name class">
<span>class <span class="ident">CAPublicKeyField</span></span>
<span>(</span><span>value:<a title="sshkey_tools.keys.PublicKey" href="keys.html#sshkey_tools.keys.PublicKey">PublicKey</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains the public key of the certificate authority
that is used to sign the certificate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CAPublicKeyField(BytestringField):
    &#34;&#34;&#34;
    Contains the public key of the certificate authority
    that is used to sign the certificate.
    &#34;&#34;&#34;

    def __init__(self, value: PublicKey):
        super().__init__(value=value, name=&#34;ca_public_key&#34;)

    def __str__(self) -&gt; str:
        return &#34; &#34;.join(
            [
                (
                    self.value.__class__.__name__.replace(&#34;PublicKey&#34;, &#34;&#34;).replace(
                        &#34;EllipticCurve&#34;, &#34;ECDSA&#34;
                    )
                ),
                self.value.get_fingerprint(),
            ]
        )

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the contents of the field
        &#34;&#34;&#34;
        if self.value in [None, False, &#34;&#34;, &#34; &#34;]:
            return _EX.InvalidFieldDataException(&#34;You need to provide a CA public key&#34;)

        if not isinstance(self.value, PublicKey):
            return _EX.InvalidFieldDataException(
                &#34;The CA public key needs to be a sshkey_tools.keys.PublicKey object&#34;
            )

        return True

    @staticmethod
    def decode(data) -&gt; Tuple[PublicKey, bytes]:
        &#34;&#34;&#34;
        Decode the certificate field from a byte string
        starting with the encoded public key

        Args:
            data (bytes): The byte string starting with the encoded key

        Returns:
            Tuple[PublicKey, bytes]: The PublicKey field and remainder of the data
        &#34;&#34;&#34;
        pubkey, data = BytestringField.decode(data)
        pubkey_type = StringField.decode(pubkey)[0]

        return (
            PublicKey.from_string(f&#34;{pubkey_type} {b64encode(pubkey).decode(&#39;utf-8&#39;)}&#34;),
            data,
        )

    def __bytes__(self) -&gt; bytes:
        return self.encode(self.value.raw_bytes())

    @classmethod
    def from_object(cls, public_key: PublicKey) -&gt; &#34;CAPublicKeyField&#34;:
        &#34;&#34;&#34;
        Creates a new CAPublicKeyField from a PublicKey object
        &#34;&#34;&#34;
        return cls(value=public_key)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.BytestringField" href="#sshkey_tools.fields.BytestringField">BytestringField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.CAPublicKeyField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data) >Tuple[<a title="sshkey_tools.keys.PublicKey" href="keys.html#sshkey_tools.keys.PublicKey">PublicKey</a>,bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Decode the certificate field from a byte string
starting with the encoded public key</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The byte string starting with the encoded key</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[PublicKey, bytes]</code></dt>
<dd>The PublicKey field and remainder of the data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data) -&gt; Tuple[PublicKey, bytes]:
    &#34;&#34;&#34;
    Decode the certificate field from a byte string
    starting with the encoded public key

    Args:
        data (bytes): The byte string starting with the encoded key

    Returns:
        Tuple[PublicKey, bytes]: The PublicKey field and remainder of the data
    &#34;&#34;&#34;
    pubkey, data = BytestringField.decode(data)
    pubkey_type = StringField.decode(pubkey)[0]

    return (
        PublicKey.from_string(f&#34;{pubkey_type} {b64encode(pubkey).decode(&#39;utf-8&#39;)}&#34;),
        data,
    )</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.CAPublicKeyField.from_object"><code class="name flex">
<span>def <span class="ident">from_object</span></span>(<span>public_key:<a title="sshkey_tools.keys.PublicKey" href="keys.html#sshkey_tools.keys.PublicKey">PublicKey</a>) ><a title="sshkey_tools.fields.CAPublicKeyField" href="#sshkey_tools.fields.CAPublicKeyField">CAPublicKeyField</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new CAPublicKeyField from a PublicKey object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_object(cls, public_key: PublicKey) -&gt; &#34;CAPublicKeyField&#34;:
    &#34;&#34;&#34;
    Creates a new CAPublicKeyField from a PublicKey object
    &#34;&#34;&#34;
    return cls(value=public_key)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.CAPublicKeyField.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) >Union[bool,Exception]</span>
</code></dt>
<dd>
<div class="desc"><p>Validates the contents of the field</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; Union[bool, Exception]:
    &#34;&#34;&#34;
    Validates the contents of the field
    &#34;&#34;&#34;
    if self.value in [None, False, &#34;&#34;, &#34; &#34;]:
        return _EX.InvalidFieldDataException(&#34;You need to provide a CA public key&#34;)

    if not isinstance(self.value, PublicKey):
        return _EX.InvalidFieldDataException(
            &#34;The CA public key needs to be a sshkey_tools.keys.PublicKey object&#34;
        )

    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.BytestringField" href="#sshkey_tools.fields.BytestringField">BytestringField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.BytestringField.encode" href="#sshkey_tools.fields.BytestringField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.BytestringField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.CERT_TYPE"><code class="flex name class">
<span>class <span class="ident">CERT_TYPE</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Certificate types, User certificate/Host certificate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CERT_TYPE(Enum):
    &#34;&#34;&#34;
    Certificate types, User certificate/Host certificate
    &#34;&#34;&#34;

    USER = 1
    HOST = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sshkey_tools.fields.CERT_TYPE.HOST"><code class="name">var <span class="ident">HOST</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sshkey_tools.fields.CERT_TYPE.USER"><code class="name">var <span class="ident">USER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="sshkey_tools.fields.CertificateField"><code class="flex name class">
<span>class <span class="ident">CertificateField</span></span>
<span>(</span><span>value, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for certificate fields</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CertificateField:
    &#34;&#34;&#34;
    The base class for certificate fields
    &#34;&#34;&#34;

    is_set = None

    def __init__(self, value, name=None):
        self.name = name
        self.value = value
        self.exception = None
        self.is_set = True

    def __str__(self):
        return f&#34;{self.name}: {self.value}&#34;

    @staticmethod
    def encode(value) -&gt; bytes:
        &#34;&#34;&#34;
        Returns the encoded value of the field
        &#34;&#34;&#34;

    @staticmethod
    def decode(data: bytes) -&gt; tuple:
        &#34;&#34;&#34;
        Returns the decoded value of the field
        &#34;&#34;&#34;

    def __bytes__(self) -&gt; bytes:
        return self.encode(self.value)

    # pylint: disable=no-self-use
    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates the field
        &#34;&#34;&#34;
        return True

    @classmethod
    def from_decode(cls, data: bytes) -&gt; Tuple[&#34;CertificateField&#34;, bytes]:
        &#34;&#34;&#34;
        Creates a field class based on encoded bytes

        Returns:
            tuple: CertificateField, remaining bytes
        &#34;&#34;&#34;
        value, data = cls.decode(data)
        return cls(value), data</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.BooleanField" href="#sshkey_tools.fields.BooleanField">BooleanField</a></li>
<li><a title="sshkey_tools.fields.BytestringField" href="#sshkey_tools.fields.BytestringField">BytestringField</a></li>
<li><a title="sshkey_tools.fields.Integer32Field" href="#sshkey_tools.fields.Integer32Field">Integer32Field</a></li>
<li><a title="sshkey_tools.fields.Integer64Field" href="#sshkey_tools.fields.Integer64Field">Integer64Field</a></li>
<li><a title="sshkey_tools.fields.KeyValueField" href="#sshkey_tools.fields.KeyValueField">KeyValueField</a></li>
<li><a title="sshkey_tools.fields.ListField" href="#sshkey_tools.fields.ListField">ListField</a></li>
<li><a title="sshkey_tools.fields.PublicKeyField" href="#sshkey_tools.fields.PublicKeyField">PublicKeyField</a></li>
<li><a title="sshkey_tools.fields.SignatureField" href="#sshkey_tools.fields.SignatureField">SignatureField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sshkey_tools.fields.CertificateField.is_set"><code class="name">var <span class="ident">is_set</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.CertificateField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data:bytes) >tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the decoded value of the field</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; tuple:
    &#34;&#34;&#34;
    Returns the decoded value of the field
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.CertificateField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>value) >bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the encoded value of the field</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def encode(value) -&gt; bytes:
    &#34;&#34;&#34;
    Returns the encoded value of the field
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.CertificateField.from_decode"><code class="name flex">
<span>def <span class="ident">from_decode</span></span>(<span>data:bytes) >Tuple[<a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a>,bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a field class based on encoded bytes</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>CertificateField, remaining bytes</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_decode(cls, data: bytes) -&gt; Tuple[&#34;CertificateField&#34;, bytes]:
    &#34;&#34;&#34;
    Creates a field class based on encoded bytes

    Returns:
        tuple: CertificateField, remaining bytes
    &#34;&#34;&#34;
    value, data = cls.decode(data)
    return cls(value), data</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.CertificateField.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) >Union[bool,Exception]</span>
</code></dt>
<dd>
<div class="desc"><p>Validates the field</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; Union[bool, Exception]:
    &#34;&#34;&#34;
    Validates the field
    &#34;&#34;&#34;
    return True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sshkey_tools.fields.CertificateTypeField"><code class="flex name class">
<span>class <span class="ident">CertificateTypeField</span></span>
<span>(</span><span>value:Union[<a title="sshkey_tools.fields.CERT_TYPE" href="#sshkey_tools.fields.CERT_TYPE">CERT_TYPE</a>,int])</span>
</code></dt>
<dd>
<div class="desc"><p>Contains the certificate type
User certificate: CERT_TYPE.USER/1
Host certificate: CERT_TYPE.HOST/2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CertificateTypeField(Integer32Field):
    &#34;&#34;&#34;
    Contains the certificate type
    User certificate: CERT_TYPE.USER/1
    Host certificate: CERT_TYPE.HOST/2
    &#34;&#34;&#34;

    def __init__(self, value: Union[CERT_TYPE, int]):
        super().__init__(
            value=value.value if isinstance(value, CERT_TYPE) else value, name=&#34;type&#34;
        )

    @staticmethod
    def encode(value: Union[CERT_TYPE, int]) -&gt; bytes:
        &#34;&#34;&#34;
        Encode the certificate type field to a byte string

        Args:
            value (Union[CERT_TYPE, int]): The type of the certificate

        Returns:
            bytes: A byte string with the encoded public key
        &#34;&#34;&#34;
        if not isinstance(value, (CERT_TYPE, int)):
            raise _EX.InvalidFieldDataException(
                f&#34;Expected (CERT_TYPE, int), got {value.__class__.__name__}&#34;
            )

        if isinstance(value, CERT_TYPE):
            value = value.value

        return Integer32Field.encode(value)

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates that the field contains a valid type
        &#34;&#34;&#34;
        if not isinstance(self.value, (CERT_TYPE, int)):
            return _EX.InvalidFieldDataException(
                f&#34;Passed value type ({type(self.value)}) is not an integer&#34;
            )

        if not isinstance(self.value, CERT_TYPE) and (self.value &gt; 2 or self.value &lt; 1):
            return _EX.InvalidDataException(
                &#34;The certificate type is invalid (1: User, 2: Host)&#34;
            )

        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.Integer32Field" href="#sshkey_tools.fields.Integer32Field">Integer32Field</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.CertificateTypeField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>value:Union[<a title="sshkey_tools.fields.CERT_TYPE" href="#sshkey_tools.fields.CERT_TYPE">CERT_TYPE</a>,int]) >bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encode the certificate type field to a byte string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>Union[<a title="sshkey_tools.fields.CERT_TYPE" href="#sshkey_tools.fields.CERT_TYPE">CERT_TYPE</a>, int]</code></dt>
<dd>The type of the certificate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>A byte string with the encoded public key</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def encode(value: Union[CERT_TYPE, int]) -&gt; bytes:
    &#34;&#34;&#34;
    Encode the certificate type field to a byte string

    Args:
        value (Union[CERT_TYPE, int]): The type of the certificate

    Returns:
        bytes: A byte string with the encoded public key
    &#34;&#34;&#34;
    if not isinstance(value, (CERT_TYPE, int)):
        raise _EX.InvalidFieldDataException(
            f&#34;Expected (CERT_TYPE, int), got {value.__class__.__name__}&#34;
        )

    if isinstance(value, CERT_TYPE):
        value = value.value

    return Integer32Field.encode(value)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.CertificateTypeField.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) >Union[bool,Exception]</span>
</code></dt>
<dd>
<div class="desc"><p>Validates that the field contains a valid type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; Union[bool, Exception]:
    &#34;&#34;&#34;
    Validates that the field contains a valid type
    &#34;&#34;&#34;
    if not isinstance(self.value, (CERT_TYPE, int)):
        return _EX.InvalidFieldDataException(
            f&#34;Passed value type ({type(self.value)}) is not an integer&#34;
        )

    if not isinstance(self.value, CERT_TYPE) and (self.value &gt; 2 or self.value &lt; 1):
        return _EX.InvalidDataException(
            &#34;The certificate type is invalid (1: User, 2: Host)&#34;
        )

    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.Integer32Field" href="#sshkey_tools.fields.Integer32Field">Integer32Field</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.Integer32Field.decode" href="#sshkey_tools.fields.Integer32Field.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.Integer32Field.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.CriticalOptionsField"><code class="flex name class">
<span>class <span class="ident">CriticalOptionsField</span></span>
<span>(</span><span>value:Union[list,tuple,dict])</span>
</code></dt>
<dd>
<div class="desc"><p>Contains the critical options part of the certificate (optional).
This should be a list of strings with one of the following</p>
<p>options:
force-command=<command>
Limits the connecting user to a specific command,
e.g. sftp-internal
source-address=<ip_address>
Limits the user to connect only from a certain
ip, subnet or host
verify-required=<true|false>
If set to true, the user must verify their identity
if using a hardware token</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CriticalOptionsField(KeyValueField):
    &#34;&#34;&#34;
    Contains the critical options part of the certificate (optional).
    This should be a list of strings with one of the following

    options:
        force-command=&lt;command&gt;
            Limits the connecting user to a specific command,
            e.g. sftp-internal
        source-address=&lt;ip_address&gt;
            Limits the user to connect only from a certain
            ip, subnet or host
        verify-required=&lt;true|false&gt;
            If set to true, the user must verify their identity
            if using a hardware token
    &#34;&#34;&#34;

    def __init__(self, value: Union[list, tuple, dict]):
        super().__init__(value=value, name=&#34;critical_options&#34;)

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validate that the field contains a valid list of options
        &#34;&#34;&#34;
        valid_opts = (&#34;force-command&#34;, &#34;source-address&#34;, &#34;verify-required&#34;)

        if not isinstance(self.value, (list, tuple, dict, set)):
            return _EX.InvalidFieldDataException(
                &#34;You need to provide a list, tuple or set of strings or a dict&#34;
            )

        if not all(
            elem in valid_opts
            for elem in (
                self.value.keys() if isinstance(self.value, dict) else self.value
            )
        ):
            return _EX.InvalidFieldDataException(
                &#34;You have provided invalid data to the critical options field&#34;
            )

        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.KeyValueField" href="#sshkey_tools.fields.KeyValueField">KeyValueField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.CriticalOptionsField.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) >Union[bool,Exception]</span>
</code></dt>
<dd>
<div class="desc"><p>Validate that the field contains a valid list of options</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; Union[bool, Exception]:
    &#34;&#34;&#34;
    Validate that the field contains a valid list of options
    &#34;&#34;&#34;
    valid_opts = (&#34;force-command&#34;, &#34;source-address&#34;, &#34;verify-required&#34;)

    if not isinstance(self.value, (list, tuple, dict, set)):
        return _EX.InvalidFieldDataException(
            &#34;You need to provide a list, tuple or set of strings or a dict&#34;
        )

    if not all(
        elem in valid_opts
        for elem in (
            self.value.keys() if isinstance(self.value, dict) else self.value
        )
    ):
        return _EX.InvalidFieldDataException(
            &#34;You have provided invalid data to the critical options field&#34;
        )

    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.KeyValueField" href="#sshkey_tools.fields.KeyValueField">KeyValueField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.KeyValueField.decode" href="#sshkey_tools.fields.KeyValueField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.KeyValueField.encode" href="#sshkey_tools.fields.KeyValueField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.KeyValueField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.DSAPubkeyField"><code class="flex name class">
<span>class <span class="ident">DSAPubkeyField</span></span>
<span>(</span><span>value:<a title="sshkey_tools.keys.PublicKey" href="keys.html#sshkey_tools.keys.PublicKey">PublicKey</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Holds the DSA Public Key for DSA Certificates</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DSAPubkeyField(PublicKeyField):
    &#34;&#34;&#34;
    Holds the DSA Public Key for DSA Certificates
    &#34;&#34;&#34;

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[DsaPublicKey, bytes]:
        &#34;&#34;&#34;
        Decode the certificate field from a byte string
        starting with the encoded public key

        Args:
            data (bytes): The byte string starting with the encoded key

        Returns:
            Tuple[RsaPublicKey, bytes]: The PublicKey field and remainder of the data
        &#34;&#34;&#34;
        p, data = MpIntegerField.decode(data)
        q, data = MpIntegerField.decode(data)
        g, data = MpIntegerField.decode(data)
        y, data = MpIntegerField.decode(data)

        return DsaPublicKey.from_numbers(p=p, q=q, g=g, y=y), data

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates that the field data is a valid DSA Public Key
        &#34;&#34;&#34;
        if not isinstance(self.value, DsaPublicKey):
            return _EX.InvalidFieldDataException(
                &#34;This public key class is not valid for use in a certificate&#34;
            )

        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.PublicKeyField" href="#sshkey_tools.fields.PublicKeyField">PublicKeyField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.DSAPubkeyField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data:bytes) >Tuple[<a title="sshkey_tools.keys.DsaPublicKey" href="keys.html#sshkey_tools.keys.DsaPublicKey">DsaPublicKey</a>,bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Decode the certificate field from a byte string
starting with the encoded public key</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The byte string starting with the encoded key</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[RsaPublicKey, bytes]</code></dt>
<dd>The PublicKey field and remainder of the data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; Tuple[DsaPublicKey, bytes]:
    &#34;&#34;&#34;
    Decode the certificate field from a byte string
    starting with the encoded public key

    Args:
        data (bytes): The byte string starting with the encoded key

    Returns:
        Tuple[RsaPublicKey, bytes]: The PublicKey field and remainder of the data
    &#34;&#34;&#34;
    p, data = MpIntegerField.decode(data)
    q, data = MpIntegerField.decode(data)
    g, data = MpIntegerField.decode(data)
    y, data = MpIntegerField.decode(data)

    return DsaPublicKey.from_numbers(p=p, q=q, g=g, y=y), data</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.DSAPubkeyField.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) >Union[bool,Exception]</span>
</code></dt>
<dd>
<div class="desc"><p>Validates that the field data is a valid DSA Public Key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; Union[bool, Exception]:
    &#34;&#34;&#34;
    Validates that the field data is a valid DSA Public Key
    &#34;&#34;&#34;
    if not isinstance(self.value, DsaPublicKey):
        return _EX.InvalidFieldDataException(
            &#34;This public key class is not valid for use in a certificate&#34;
        )

    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.PublicKeyField" href="#sshkey_tools.fields.PublicKeyField">PublicKeyField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.PublicKeyField.encode" href="#sshkey_tools.fields.PublicKeyField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.from_object" href="#sshkey_tools.fields.PublicKeyField.from_object">from_object</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.DSASignatureField"><code class="flex name class">
<span>class <span class="ident">DSASignatureField</span></span>
<span>(</span><span>private_key:<a title="sshkey_tools.keys.DsaPrivateKey" href="keys.html#sshkey_tools.keys.DsaPrivateKey">DsaPrivateKey</a>=None, signature:bytes=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and contains the DSA signature from an DSA Private Key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DSASignatureField(SignatureField):
    &#34;&#34;&#34;
    Creates and contains the DSA signature from an DSA Private Key
    &#34;&#34;&#34;

    def __init__(
        self, private_key: DsaPrivateKey = None, signature: bytes = None
    ) -&gt; None:
        super().__init__(private_key, signature)

    @staticmethod
    # pylint: disable=arguments-renamed
    def encode(signature: bytes):
        &#34;&#34;&#34;
        Encodes the signature to a byte string

        Args:
            signature (bytes): The signature bytes to encode

        Returns:
            bytes: The encoded byte string
        &#34;&#34;&#34;
        if not isinstance(signature, bytes):
            raise _EX.InvalidFieldDataException(
                f&#34;Expected bytes, got {signature.__class__.__name__}&#34;
            )

        r, s = decode_dss_signature(signature)

        return BytestringField.encode(
            StringField.encode(&#34;ssh-dss&#34;)
            + BytestringField.encode(long_to_bytes(r, 20) + long_to_bytes(s, 20))
        )

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[bytes, bytes]:
        &#34;&#34;&#34;
        Decodes a bytestring containing a signature

        Args:
            data (bytes): The bytestring starting with the Signature

        Returns:
            Tuple[ bytes, bytes ]: signature, remainder of the data
        &#34;&#34;&#34;
        signature, data = BytestringField.decode(data)

        signature = BytestringField.decode(BytestringField.decode(signature)[1])[0]
        r = bytes_to_long(signature[:20])
        s = bytes_to_long(signature[20:])

        signature = encode_dss_signature(r, s)

        return signature, data

    @classmethod
    def from_decode(cls, data: bytes) -&gt; Tuple[&#34;DSASignatureField&#34;, bytes]:
        &#34;&#34;&#34;
        Creates a signature field class from the encoded signature

        Args:
            data (bytes): The bytestring starting with the Signature

        Returns:
            Tuple[ DSASignatureField, bytes ]: signature, remainder of the data
        &#34;&#34;&#34;
        signature, data = cls.decode(data)

        return cls(private_key=None, signature=signature), data

    def sign(self, data: bytes) -&gt; None:
        &#34;&#34;&#34;
        Signs the provided data with the provided private key

        Args:
            data (bytes): The data to be signed
        &#34;&#34;&#34;
        self.value = self.private_key.sign(data)
        self.is_signed = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.SignatureField" href="#sshkey_tools.fields.SignatureField">SignatureField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.DSASignatureField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data:bytes) >Tuple[bytes,bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes a bytestring containing a signature</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The bytestring starting with the Signature</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[ bytes, bytes ]</code></dt>
<dd>signature, remainder of the data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; Tuple[bytes, bytes]:
    &#34;&#34;&#34;
    Decodes a bytestring containing a signature

    Args:
        data (bytes): The bytestring starting with the Signature

    Returns:
        Tuple[ bytes, bytes ]: signature, remainder of the data
    &#34;&#34;&#34;
    signature, data = BytestringField.decode(data)

    signature = BytestringField.decode(BytestringField.decode(signature)[1])[0]
    r = bytes_to_long(signature[:20])
    s = bytes_to_long(signature[20:])

    signature = encode_dss_signature(r, s)

    return signature, data</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.DSASignatureField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>signature:bytes)</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes the signature to a byte string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>signature</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The signature bytes to encode</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>The encoded byte string</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
# pylint: disable=arguments-renamed
def encode(signature: bytes):
    &#34;&#34;&#34;
    Encodes the signature to a byte string

    Args:
        signature (bytes): The signature bytes to encode

    Returns:
        bytes: The encoded byte string
    &#34;&#34;&#34;
    if not isinstance(signature, bytes):
        raise _EX.InvalidFieldDataException(
            f&#34;Expected bytes, got {signature.__class__.__name__}&#34;
        )

    r, s = decode_dss_signature(signature)

    return BytestringField.encode(
        StringField.encode(&#34;ssh-dss&#34;)
        + BytestringField.encode(long_to_bytes(r, 20) + long_to_bytes(s, 20))
    )</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.DSASignatureField.from_decode"><code class="name flex">
<span>def <span class="ident">from_decode</span></span>(<span>data:bytes) >Tuple[<a title="sshkey_tools.fields.DSASignatureField" href="#sshkey_tools.fields.DSASignatureField">DSASignatureField</a>,bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a signature field class from the encoded signature</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The bytestring starting with the Signature</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[ <a title="sshkey_tools.fields.DSASignatureField" href="#sshkey_tools.fields.DSASignatureField">DSASignatureField</a>, bytes ]</code></dt>
<dd>signature, remainder of the data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_decode(cls, data: bytes) -&gt; Tuple[&#34;DSASignatureField&#34;, bytes]:
    &#34;&#34;&#34;
    Creates a signature field class from the encoded signature

    Args:
        data (bytes): The bytestring starting with the Signature

    Returns:
        Tuple[ DSASignatureField, bytes ]: signature, remainder of the data
    &#34;&#34;&#34;
    signature, data = cls.decode(data)

    return cls(private_key=None, signature=signature), data</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.DSASignatureField.sign"><code class="name flex">
<span>def <span class="ident">sign</span></span>(<span>self, data:bytes) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Signs the provided data with the provided private key</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The data to be signed</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sign(self, data: bytes) -&gt; None:
    &#34;&#34;&#34;
    Signs the provided data with the provided private key

    Args:
        data (bytes): The data to be signed
    &#34;&#34;&#34;
    self.value = self.private_key.sign(data)
    self.is_signed = True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.SignatureField" href="#sshkey_tools.fields.SignatureField">SignatureField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.SignatureField.can_sign" href="#sshkey_tools.fields.SignatureField.can_sign">can_sign</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.from_object" href="#sshkey_tools.fields.SignatureField.from_object">from_object</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.DateTimeField"><code class="flex name class">
<span>class <span class="ident">DateTimeField</span></span>
<span>(</span><span>value, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Certificate field representing a datetime value.
The value is saved as a 64-bit integer (unix timestamp)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DateTimeField(Integer64Field):
    &#34;&#34;&#34;
    Certificate field representing a datetime value.
    The value is saved as a 64-bit integer (unix timestamp)
    &#34;&#34;&#34;

    @staticmethod
    def encode(value: Union[datetime, int]) -&gt; bytes:
        &#34;&#34;&#34;Encodes a datetime object to a byte string

        Args:
            value (datetime): Datetime object

        Returns:
            bytes: Packed byte string containing datetime timestamp
        &#34;&#34;&#34;
        if not isinstance(value, (datetime, int)):
            raise _EX.InvalidFieldDataException(
                f&#34;Expected datetime, got {value.__class__.__name__}&#34;
            )

        if isinstance(value, datetime):
            value = int(value.timestamp())

        return Integer64Field.encode(value)

    @staticmethod
    def decode(data: bytes) -&gt; datetime:
        &#34;&#34;&#34;Decodes a datetime object from a block of bytes

        Args:
            data (bytes): Block of bytes containing a datetime object

        Returns:
            tuple: Tuple with datetime and remainder of data
        &#34;&#34;&#34;
        timestamp, data = Integer64Field.decode(data)

        return datetime.fromtimestamp(timestamp), data

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validate the field data
        &#34;&#34;&#34;
        if not isinstance(self.value, (datetime, int)):
            return _EX.InvalidFieldDataException(
                f&#34;Passed value type ({type(self.value)}) is not a datetime object&#34;
            )

        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.Integer64Field" href="#sshkey_tools.fields.Integer64Field">Integer64Field</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.ValidityEndField" href="#sshkey_tools.fields.ValidityEndField">ValidityEndField</a></li>
<li><a title="sshkey_tools.fields.ValidityStartField" href="#sshkey_tools.fields.ValidityStartField">ValidityStartField</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.DateTimeField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data:bytes) >datetime.datetime</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes a datetime object from a block of bytes</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>Block of bytes containing a datetime object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>Tuple with datetime and remainder of data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; datetime:
    &#34;&#34;&#34;Decodes a datetime object from a block of bytes

    Args:
        data (bytes): Block of bytes containing a datetime object

    Returns:
        tuple: Tuple with datetime and remainder of data
    &#34;&#34;&#34;
    timestamp, data = Integer64Field.decode(data)

    return datetime.fromtimestamp(timestamp), data</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.DateTimeField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>value:Union[datetime.datetime,int]) >bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes a datetime object to a byte string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>datetime</code></dt>
<dd>Datetime object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>Packed byte string containing datetime timestamp</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def encode(value: Union[datetime, int]) -&gt; bytes:
    &#34;&#34;&#34;Encodes a datetime object to a byte string

    Args:
        value (datetime): Datetime object

    Returns:
        bytes: Packed byte string containing datetime timestamp
    &#34;&#34;&#34;
    if not isinstance(value, (datetime, int)):
        raise _EX.InvalidFieldDataException(
            f&#34;Expected datetime, got {value.__class__.__name__}&#34;
        )

    if isinstance(value, datetime):
        value = int(value.timestamp())

    return Integer64Field.encode(value)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.Integer64Field" href="#sshkey_tools.fields.Integer64Field">Integer64Field</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.Integer64Field.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.Integer64Field.validate" href="#sshkey_tools.fields.Integer64Field.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.ECDSAPubkeyField"><code class="flex name class">
<span>class <span class="ident">ECDSAPubkeyField</span></span>
<span>(</span><span>value:<a title="sshkey_tools.keys.PublicKey" href="keys.html#sshkey_tools.keys.PublicKey">PublicKey</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Holds the ECDSA Public Key for ECDSA Certificates</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ECDSAPubkeyField(PublicKeyField):
    &#34;&#34;&#34;
    Holds the ECDSA Public Key for ECDSA Certificates
    &#34;&#34;&#34;

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[EcdsaPublicKey, bytes]:
        &#34;&#34;&#34;
        Decode the certificate field from a byte string
        starting with the encoded public key

        Args:
            data (bytes): The byte string starting with the encoded key

        Returns:
            Tuple[ECPublicKey, bytes]: The PublicKey field and remainder of the data
        &#34;&#34;&#34;
        curve, data = StringField.decode(data)
        key, data = BytestringField.decode(data)

        key_type = &#34;ecdsa-sha2-&#34; + curve

        return (
            EcdsaPublicKey.from_string(
                key_type
                + &#34; &#34;
                + b64encode(
                    StringField.encode(key_type)
                    + StringField.encode(curve)
                    + BytestringField.encode(key)
                ).decode(&#34;utf-8&#34;)
            ),
            data,
        )

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates that the field data is a valid ECDSA Public Key
        &#34;&#34;&#34;
        if not isinstance(self.value, EcdsaPublicKey):
            return _EX.InvalidFieldDataException(
                &#34;This public key class is not valid for use in a certificate&#34;
            )

        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.PublicKeyField" href="#sshkey_tools.fields.PublicKeyField">PublicKeyField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.ECDSAPubkeyField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data:bytes) >Tuple[<a title="sshkey_tools.keys.EcdsaPublicKey" href="keys.html#sshkey_tools.keys.EcdsaPublicKey">EcdsaPublicKey</a>,bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Decode the certificate field from a byte string
starting with the encoded public key</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The byte string starting with the encoded key</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[ECPublicKey, bytes]</code></dt>
<dd>The PublicKey field and remainder of the data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; Tuple[EcdsaPublicKey, bytes]:
    &#34;&#34;&#34;
    Decode the certificate field from a byte string
    starting with the encoded public key

    Args:
        data (bytes): The byte string starting with the encoded key

    Returns:
        Tuple[ECPublicKey, bytes]: The PublicKey field and remainder of the data
    &#34;&#34;&#34;
    curve, data = StringField.decode(data)
    key, data = BytestringField.decode(data)

    key_type = &#34;ecdsa-sha2-&#34; + curve

    return (
        EcdsaPublicKey.from_string(
            key_type
            + &#34; &#34;
            + b64encode(
                StringField.encode(key_type)
                + StringField.encode(curve)
                + BytestringField.encode(key)
            ).decode(&#34;utf-8&#34;)
        ),
        data,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.ECDSAPubkeyField.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) >Union[bool,Exception]</span>
</code></dt>
<dd>
<div class="desc"><p>Validates that the field data is a valid ECDSA Public Key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; Union[bool, Exception]:
    &#34;&#34;&#34;
    Validates that the field data is a valid ECDSA Public Key
    &#34;&#34;&#34;
    if not isinstance(self.value, EcdsaPublicKey):
        return _EX.InvalidFieldDataException(
            &#34;This public key class is not valid for use in a certificate&#34;
        )

    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.PublicKeyField" href="#sshkey_tools.fields.PublicKeyField">PublicKeyField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.PublicKeyField.encode" href="#sshkey_tools.fields.PublicKeyField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.from_object" href="#sshkey_tools.fields.PublicKeyField.from_object">from_object</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.ECDSASignatureField"><code class="flex name class">
<span>class <span class="ident">ECDSASignatureField</span></span>
<span>(</span><span>private_key:<a title="sshkey_tools.keys.EcdsaPrivateKey" href="keys.html#sshkey_tools.keys.EcdsaPrivateKey">EcdsaPrivateKey</a>=None, signature:bytes=None, curve_name:str=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and contains the ECDSA signature from an ECDSA Private Key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ECDSASignatureField(SignatureField):
    &#34;&#34;&#34;
    Creates and contains the ECDSA signature from an ECDSA Private Key
    &#34;&#34;&#34;

    def __init__(
        self,
        private_key: EcdsaPrivateKey = None,
        signature: bytes = None,
        curve_name: str = None,
    ) -&gt; None:
        super().__init__(private_key, signature)

        if curve_name is None:
            curve_size = self.private_key.public_key.key.curve.key_size
            curve_name = f&#34;ecdsa-sha2-nistp{curve_size}&#34;

        self.curve = curve_name

    @staticmethod
    # pylint: disable=arguments-renamed
    def encode(signature: bytes, curve_name: str = None) -&gt; bytes:
        &#34;&#34;&#34;
        Encodes the signature to a byte string

        Args:
            signature (bytes): The signature bytes to encode
            curve_name (str): The name of the curve used for the signature
                              private key

        Returns:
            bytes: The encoded byte string
        &#34;&#34;&#34;
        if not isinstance(signature, bytes):
            raise _EX.InvalidFieldDataException(
                f&#34;Expected bytes, got {signature.__class__.__name__}&#34;
            )

        r, s = decode_dss_signature(signature)

        return BytestringField.encode(
            StringField.encode(curve_name)
            + BytestringField.encode(
                MpIntegerField.encode(r) + MpIntegerField.encode(s)
            )
        )

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[Tuple[bytes, bytes], bytes]:
        &#34;&#34;&#34;
        Decodes a bytestring containing a signature

        Args:
            data (bytes): The bytestring starting with the Signature

        Returns:
            Tuple[ Tuple[ bytes, bytes ], bytes]: (curve, signature), remainder of the data
        &#34;&#34;&#34;
        signature, data = BytestringField.decode(data)

        curve, signature = StringField.decode(signature)
        signature, _ = BytestringField.decode(signature)

        r, signature = MpIntegerField.decode(signature)
        s, _ = MpIntegerField.decode(signature)

        signature = encode_dss_signature(r, s)

        return (curve, signature), data

    @classmethod
    def from_decode(cls, data: bytes) -&gt; Tuple[&#34;ECDSASignatureField&#34;, bytes]:
        &#34;&#34;&#34;
        Creates a signature field class from the encoded signature

        Args:
            data (bytes): The bytestring starting with the Signature

        Returns:
            Tuple[ ECDSASignatureField , bytes ]: signature, remainder of the data
        &#34;&#34;&#34;
        signature, data = cls.decode(data)

        return (
            cls(private_key=None, signature=signature[1], curve_name=signature[0]),
            data,
        )

    def sign(self, data: bytes) -&gt; None:
        &#34;&#34;&#34;
        Signs the provided data with the provided private key

        Args:
            data (bytes): The data to be signed
        &#34;&#34;&#34;
        self.value = self.private_key.sign(data)
        self.is_signed = True

    def __bytes__(self):
        return self.encode(self.value, self.curve)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.SignatureField" href="#sshkey_tools.fields.SignatureField">SignatureField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.ECDSASignatureField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data:bytes) >Tuple[Tuple[bytes,bytes],bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes a bytestring containing a signature</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The bytestring starting with the Signature</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[ Tuple[ bytes, bytes ], bytes]</code></dt>
<dd>(curve, signature), remainder of the data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; Tuple[Tuple[bytes, bytes], bytes]:
    &#34;&#34;&#34;
    Decodes a bytestring containing a signature

    Args:
        data (bytes): The bytestring starting with the Signature

    Returns:
        Tuple[ Tuple[ bytes, bytes ], bytes]: (curve, signature), remainder of the data
    &#34;&#34;&#34;
    signature, data = BytestringField.decode(data)

    curve, signature = StringField.decode(signature)
    signature, _ = BytestringField.decode(signature)

    r, signature = MpIntegerField.decode(signature)
    s, _ = MpIntegerField.decode(signature)

    signature = encode_dss_signature(r, s)

    return (curve, signature), data</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.ECDSASignatureField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>signature:bytes, curve_name:str=None) >bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes the signature to a byte string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>signature</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The signature bytes to encode</dd>
<dt><strong><code>curve_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the curve used for the signature
private key</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>The encoded byte string</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
# pylint: disable=arguments-renamed
def encode(signature: bytes, curve_name: str = None) -&gt; bytes:
    &#34;&#34;&#34;
    Encodes the signature to a byte string

    Args:
        signature (bytes): The signature bytes to encode
        curve_name (str): The name of the curve used for the signature
                          private key

    Returns:
        bytes: The encoded byte string
    &#34;&#34;&#34;
    if not isinstance(signature, bytes):
        raise _EX.InvalidFieldDataException(
            f&#34;Expected bytes, got {signature.__class__.__name__}&#34;
        )

    r, s = decode_dss_signature(signature)

    return BytestringField.encode(
        StringField.encode(curve_name)
        + BytestringField.encode(
            MpIntegerField.encode(r) + MpIntegerField.encode(s)
        )
    )</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.ECDSASignatureField.from_decode"><code class="name flex">
<span>def <span class="ident">from_decode</span></span>(<span>data:bytes) >Tuple[<a title="sshkey_tools.fields.ECDSASignatureField" href="#sshkey_tools.fields.ECDSASignatureField">ECDSASignatureField</a>,bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a signature field class from the encoded signature</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The bytestring starting with the Signature</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[ <a title="sshkey_tools.fields.ECDSASignatureField" href="#sshkey_tools.fields.ECDSASignatureField">ECDSASignatureField</a> , bytes ]</code></dt>
<dd>signature, remainder of the data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_decode(cls, data: bytes) -&gt; Tuple[&#34;ECDSASignatureField&#34;, bytes]:
    &#34;&#34;&#34;
    Creates a signature field class from the encoded signature

    Args:
        data (bytes): The bytestring starting with the Signature

    Returns:
        Tuple[ ECDSASignatureField , bytes ]: signature, remainder of the data
    &#34;&#34;&#34;
    signature, data = cls.decode(data)

    return (
        cls(private_key=None, signature=signature[1], curve_name=signature[0]),
        data,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.ECDSASignatureField.sign"><code class="name flex">
<span>def <span class="ident">sign</span></span>(<span>self, data:bytes) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Signs the provided data with the provided private key</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The data to be signed</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sign(self, data: bytes) -&gt; None:
    &#34;&#34;&#34;
    Signs the provided data with the provided private key

    Args:
        data (bytes): The data to be signed
    &#34;&#34;&#34;
    self.value = self.private_key.sign(data)
    self.is_signed = True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.SignatureField" href="#sshkey_tools.fields.SignatureField">SignatureField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.SignatureField.can_sign" href="#sshkey_tools.fields.SignatureField.can_sign">can_sign</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.from_object" href="#sshkey_tools.fields.SignatureField.from_object">from_object</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.ED25519PubkeyField"><code class="flex name class">
<span>class <span class="ident">ED25519PubkeyField</span></span>
<span>(</span><span>value:<a title="sshkey_tools.keys.PublicKey" href="keys.html#sshkey_tools.keys.PublicKey">PublicKey</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Holds the ED25519 Public Key for ED25519 Certificates</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ED25519PubkeyField(PublicKeyField):
    &#34;&#34;&#34;
    Holds the ED25519 Public Key for ED25519 Certificates
    &#34;&#34;&#34;

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[Ed25519PublicKey, bytes]:
        &#34;&#34;&#34;
        Decode the certificate field from a byte string
        starting with the encoded public key

        Args:
            data (bytes): The byte string starting with the encoded key

        Returns:
            Tuple[Ed25519PublicKey, bytes]: The PublicKey field and remainder of the data
        &#34;&#34;&#34;
        pubkey, data = BytestringField.decode(data)

        return Ed25519PublicKey.from_raw_bytes(pubkey), data

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates that the field data is a valid ED25519 Public Key
        &#34;&#34;&#34;
        if not isinstance(self.value, Ed25519PublicKey):
            return _EX.InvalidFieldDataException(
                &#34;This public key class is not valid for use in a certificate&#34;
            )

        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.PublicKeyField" href="#sshkey_tools.fields.PublicKeyField">PublicKeyField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.ED25519PubkeyField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data:bytes) >Tuple[<a title="sshkey_tools.keys.Ed25519PublicKey" href="keys.html#sshkey_tools.keys.Ed25519PublicKey">Ed25519PublicKey</a>,bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Decode the certificate field from a byte string
starting with the encoded public key</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The byte string starting with the encoded key</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[Ed25519PublicKey, bytes]</code></dt>
<dd>The PublicKey field and remainder of the data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; Tuple[Ed25519PublicKey, bytes]:
    &#34;&#34;&#34;
    Decode the certificate field from a byte string
    starting with the encoded public key

    Args:
        data (bytes): The byte string starting with the encoded key

    Returns:
        Tuple[Ed25519PublicKey, bytes]: The PublicKey field and remainder of the data
    &#34;&#34;&#34;
    pubkey, data = BytestringField.decode(data)

    return Ed25519PublicKey.from_raw_bytes(pubkey), data</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.ED25519PubkeyField.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) >Union[bool,Exception]</span>
</code></dt>
<dd>
<div class="desc"><p>Validates that the field data is a valid ED25519 Public Key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; Union[bool, Exception]:
    &#34;&#34;&#34;
    Validates that the field data is a valid ED25519 Public Key
    &#34;&#34;&#34;
    if not isinstance(self.value, Ed25519PublicKey):
        return _EX.InvalidFieldDataException(
            &#34;This public key class is not valid for use in a certificate&#34;
        )

    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.PublicKeyField" href="#sshkey_tools.fields.PublicKeyField">PublicKeyField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.PublicKeyField.encode" href="#sshkey_tools.fields.PublicKeyField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.from_object" href="#sshkey_tools.fields.PublicKeyField.from_object">from_object</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.ED25519SignatureField"><code class="flex name class">
<span>class <span class="ident">ED25519SignatureField</span></span>
<span>(</span><span>private_key:<a title="sshkey_tools.keys.Ed25519PrivateKey" href="keys.html#sshkey_tools.keys.Ed25519PrivateKey">Ed25519PrivateKey</a>=None, signature:bytes=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and contains the ED25519 signature from an ED25519 Private Key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ED25519SignatureField(SignatureField):
    &#34;&#34;&#34;
    Creates and contains the ED25519 signature from an ED25519 Private Key
    &#34;&#34;&#34;

    def __init__(
        <!-- trunk-ignore(gitleaks/generic-api-key) -->
        self, private_key: Ed25519PrivateKey = None, signature: bytes = None
    ) -&gt; None:
        super().__init__(private_key, signature)

    @staticmethod
    # pylint: disable=arguments-renamed
    def encode(signature: bytes) -&gt; None:
        &#34;&#34;&#34;
        Encodes the signature to a byte string

        Args:
            signature (bytes): The signature bytes to encode

        Returns:
            bytes: The encoded byte string
        &#34;&#34;&#34;
        if not isinstance(signature, bytes):
            raise _EX.InvalidFieldDataException(
                f&#34;Expected bytes, got {signature.__class__.__name__}&#34;
            )

        return BytestringField.encode(
            StringField.encode(&#34;ssh-ed25519&#34;) + BytestringField.encode(signature)
        )

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[bytes, bytes]:
        &#34;&#34;&#34;
        Decodes a bytestring containing a signature

        Args:
            data (bytes): The bytestring starting with the Signature

        Returns:
            Tuple[ bytes, bytes ]: signature, remainder of the data
        &#34;&#34;&#34;
        signature, data = BytestringField.decode(data)

        signature = BytestringField.decode(BytestringField.decode(signature)[1])[0]

        return signature, data

    @classmethod
    def from_decode(cls, data: bytes) -&gt; Tuple[&#34;ED25519SignatureField&#34;, bytes]:
        &#34;&#34;&#34;
        Creates a signature field class from the encoded signature

        Args:
            data (bytes): The bytestring starting with the Signature

        Returns:
            Tuple[ ED25519SignatureField , bytes ]: signature, remainder of the data
        &#34;&#34;&#34;
        signature, data = cls.decode(data)

        return cls(private_key=None, signature=signature), data

    def sign(self, data: bytes) -&gt; None:
        &#34;&#34;&#34;
        Signs the provided data with the provided private key

        Args:
            data (bytes): The data to be signed
            hash_alg (RsaAlgs, optional): The RSA algorithm to use for hashing.
                                           Defaults to RsaAlgs.SHA256.
        &#34;&#34;&#34;
        self.value = self.private_key.sign(data)
        self.is_signed = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.SignatureField" href="#sshkey_tools.fields.SignatureField">SignatureField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.ED25519SignatureField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data:bytes) >Tuple[bytes,bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes a bytestring containing a signature</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The bytestring starting with the Signature</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[ bytes, bytes ]</code></dt>
<dd>signature, remainder of the data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; Tuple[bytes, bytes]:
    &#34;&#34;&#34;
    Decodes a bytestring containing a signature

    Args:
        data (bytes): The bytestring starting with the Signature

    Returns:
        Tuple[ bytes, bytes ]: signature, remainder of the data
    &#34;&#34;&#34;
    signature, data = BytestringField.decode(data)

    signature = BytestringField.decode(BytestringField.decode(signature)[1])[0]

    return signature, data</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.ED25519SignatureField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>signature:bytes) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes the signature to a byte string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>signature</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The signature bytes to encode</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>The encoded byte string</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
# pylint: disable=arguments-renamed
def encode(signature: bytes) -&gt; None:
    &#34;&#34;&#34;
    Encodes the signature to a byte string

    Args:
        signature (bytes): The signature bytes to encode

    Returns:
        bytes: The encoded byte string
    &#34;&#34;&#34;
    if not isinstance(signature, bytes):
        raise _EX.InvalidFieldDataException(
            f&#34;Expected bytes, got {signature.__class__.__name__}&#34;
        )

    return BytestringField.encode(
        StringField.encode(&#34;ssh-ed25519&#34;) + BytestringField.encode(signature)
    )</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.ED25519SignatureField.from_decode"><code class="name flex">
<span>def <span class="ident">from_decode</span></span>(<span>data:bytes) >Tuple[<a title="sshkey_tools.fields.ED25519SignatureField" href="#sshkey_tools.fields.ED25519SignatureField">ED25519SignatureField</a>,bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a signature field class from the encoded signature</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The bytestring starting with the Signature</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[ <a title="sshkey_tools.fields.ED25519SignatureField" href="#sshkey_tools.fields.ED25519SignatureField">ED25519SignatureField</a> , bytes ]</code></dt>
<dd>signature, remainder of the data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_decode(cls, data: bytes) -&gt; Tuple[&#34;ED25519SignatureField&#34;, bytes]:
    &#34;&#34;&#34;
    Creates a signature field class from the encoded signature

    Args:
        data (bytes): The bytestring starting with the Signature

    Returns:
        Tuple[ ED25519SignatureField , bytes ]: signature, remainder of the data
    &#34;&#34;&#34;
    signature, data = cls.decode(data)

    return cls(private_key=None, signature=signature), data</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.ED25519SignatureField.sign"><code class="name flex">
<span>def <span class="ident">sign</span></span>(<span>self, data:bytes) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Signs the provided data with the provided private key</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The data to be signed</dd>
<dt><strong><code>hash_alg</code></strong> :&ensp;<code>RsaAlgs</code>, optional</dt>
<dd>The RSA algorithm to use for hashing.
Defaults to RsaAlgs.SHA256.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sign(self, data: bytes) -&gt; None:
    &#34;&#34;&#34;
    Signs the provided data with the provided private key

    Args:
        data (bytes): The data to be signed
        hash_alg (RsaAlgs, optional): The RSA algorithm to use for hashing.
                                       Defaults to RsaAlgs.SHA256.
    &#34;&#34;&#34;
    self.value = self.private_key.sign(data)
    self.is_signed = True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.SignatureField" href="#sshkey_tools.fields.SignatureField">SignatureField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.SignatureField.can_sign" href="#sshkey_tools.fields.SignatureField.can_sign">can_sign</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.from_object" href="#sshkey_tools.fields.SignatureField.from_object">from_object</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.ExtensionsField"><code class="flex name class">
<span>class <span class="ident">ExtensionsField</span></span>
<span>(</span><span>value:Union[list,tuple])</span>
</code></dt>
<dd>
<div class="desc"><p>Contains a list of extensions for the certificate,
set to give the user limitations and/or additional
privileges on the host.</p>
<p>flags:
no-touch-required
The user doesn't need to touch the
physical key to authenticate.</p>
<pre><code>permit-X11-forwarding
    Permits the user to use X11 Forwarding

permit-agent-forwarding
    Permits the user to use agent forwarding

permit-port-forwarding
    Permits the user to forward ports

permit-pty
    Permits the user to use a pseudo-terminal

permit-user-rc
    Permits the user to use the user rc file
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExtensionsField(KeyValueField):
    &#34;&#34;&#34;
    Contains a list of extensions for the certificate,
    set to give the user limitations and/or additional
    privileges on the host.

    flags:
        no-touch-required
            The user doesn&#39;t need to touch the
            physical key to authenticate.

        permit-X11-forwarding
            Permits the user to use X11 Forwarding

        permit-agent-forwarding
            Permits the user to use agent forwarding

        permit-port-forwarding
            Permits the user to forward ports

        permit-pty
            Permits the user to use a pseudo-terminal

        permit-user-rc
            Permits the user to use the user rc file

    &#34;&#34;&#34;

    def __init__(self, value: Union[list, tuple]):
        super().__init__(value=value, name=&#34;extensions&#34;)

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates that the options provided are valid
        &#34;&#34;&#34;
        valid_opts = (
            &#34;no-touch-required&#34;,
            &#34;permit-X11-forwarding&#34;,
            &#34;permit-agent-forwarding&#34;,
            &#34;permit-port-forwarding&#34;,
            &#34;permit-pty&#34;,
            &#34;permit-user-rc&#34;,
        )

        for item in self.value:
            if item not in valid_opts:
                return _EX.InvalidDataException(f&#34;The extension &#39;{item}&#39; is invalid&#34;)

        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.KeyValueField" href="#sshkey_tools.fields.KeyValueField">KeyValueField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.ExtensionsField.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) >Union[bool,Exception]</span>
</code></dt>
<dd>
<div class="desc"><p>Validates that the options provided are valid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; Union[bool, Exception]:
    &#34;&#34;&#34;
    Validates that the options provided are valid
    &#34;&#34;&#34;
    valid_opts = (
        &#34;no-touch-required&#34;,
        &#34;permit-X11-forwarding&#34;,
        &#34;permit-agent-forwarding&#34;,
        &#34;permit-port-forwarding&#34;,
        &#34;permit-pty&#34;,
        &#34;permit-user-rc&#34;,
    )

    for item in self.value:
        if item not in valid_opts:
            return _EX.InvalidDataException(f&#34;The extension &#39;{item}&#39; is invalid&#34;)

    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.KeyValueField" href="#sshkey_tools.fields.KeyValueField">KeyValueField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.KeyValueField.decode" href="#sshkey_tools.fields.KeyValueField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.KeyValueField.encode" href="#sshkey_tools.fields.KeyValueField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.KeyValueField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.Integer32Field"><code class="flex name class">
<span>class <span class="ident">Integer32Field</span></span>
<span>(</span><span>value, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Certificate field representing a 32-bit integer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Integer32Field(CertificateField):
    &#34;&#34;&#34;
    Certificate field representing a 32-bit integer
    &#34;&#34;&#34;

    @staticmethod
    def encode(value: int) -&gt; bytes:
        &#34;&#34;&#34;Encodes a 32-bit integer value to a packed byte string

        Args:
            source_int (int): Integer to be packed

        Returns:
            bytes: Packed byte string containing integer
        &#34;&#34;&#34;
        if not isinstance(value, int):
            raise _EX.InvalidFieldDataException(
                f&#34;Expected int, got {value.__class__.__name__}&#34;
            )

        return pack(&#34;&gt;I&#34;, value)

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[int, bytes]:
        &#34;&#34;&#34;Decodes a 32-bit integer from a block of bytes

        Args:
            data (bytes): Block of bytes containing an integer

        Returns:
            tuple: Tuple with integer and remainder of data
        &#34;&#34;&#34;
        return int(unpack(&#34;&gt;I&#34;, data[:4])[0]), data[4:]

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validate the field data
        &#34;&#34;&#34;
        if not isinstance(self.value, int):
            return _EX.InvalidFieldDataException(
                f&#34;Passed value type ({type(self.value)}) is not an integer&#34;
            )

        if self.value &gt; MAX_INT32:
            return _EX.IntegerOverflowException(
                f&#34;Passed value {self.value} is too large for a 32-bit integer&#34;
            )

        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.CertificateTypeField" href="#sshkey_tools.fields.CertificateTypeField">CertificateTypeField</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.Integer32Field.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data:bytes) >Tuple[int,bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes a 32-bit integer from a block of bytes</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>Block of bytes containing an integer</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>Tuple with integer and remainder of data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; Tuple[int, bytes]:
    &#34;&#34;&#34;Decodes a 32-bit integer from a block of bytes

    Args:
        data (bytes): Block of bytes containing an integer

    Returns:
        tuple: Tuple with integer and remainder of data
    &#34;&#34;&#34;
    return int(unpack(&#34;&gt;I&#34;, data[:4])[0]), data[4:]</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.Integer32Field.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>value:int) >bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes a 32-bit integer value to a packed byte string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source_int</code></strong> :&ensp;<code>int</code></dt>
<dd>Integer to be packed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>Packed byte string containing integer</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def encode(value: int) -&gt; bytes:
    &#34;&#34;&#34;Encodes a 32-bit integer value to a packed byte string

    Args:
        source_int (int): Integer to be packed

    Returns:
        bytes: Packed byte string containing integer
    &#34;&#34;&#34;
    if not isinstance(value, int):
        raise _EX.InvalidFieldDataException(
            f&#34;Expected int, got {value.__class__.__name__}&#34;
        )

    return pack(&#34;&gt;I&#34;, value)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.Integer32Field.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) >Union[bool,Exception]</span>
</code></dt>
<dd>
<div class="desc"><p>Validate the field data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; Union[bool, Exception]:
    &#34;&#34;&#34;
    Validate the field data
    &#34;&#34;&#34;
    if not isinstance(self.value, int):
        return _EX.InvalidFieldDataException(
            f&#34;Passed value type ({type(self.value)}) is not an integer&#34;
        )

    if self.value &gt; MAX_INT32:
        return _EX.IntegerOverflowException(
            f&#34;Passed value {self.value} is too large for a 32-bit integer&#34;
        )

    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.CertificateField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.Integer64Field"><code class="flex name class">
<span>class <span class="ident">Integer64Field</span></span>
<span>(</span><span>value, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Certificate field representing a 64-bit integer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Integer64Field(CertificateField):
    &#34;&#34;&#34;
    Certificate field representing a 64-bit integer
    &#34;&#34;&#34;

    @staticmethod
    def encode(value: int) -&gt; bytes:
        &#34;&#34;&#34;Encodes a 64-bit integer value to a packed byte string

        Args:
            source_int (int): Integer to be packed

        Returns:
            bytes: Packed byte string containing integer
        &#34;&#34;&#34;
        if not isinstance(value, int):
            raise _EX.InvalidFieldDataException(
                f&#34;Expected int, got {value.__class__.__name__}&#34;
            )

        return pack(&#34;&gt;Q&#34;, value)

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[int, bytes]:
        &#34;&#34;&#34;Decodes a 64-bit integer from a block of bytes

        Args:
            data (bytes): Block of bytes containing an integer

        Returns:
            tuple: Tuple with integer and remainder of data
        &#34;&#34;&#34;
        return int(unpack(&#34;&gt;Q&#34;, data[:8])[0]), data[8:]

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validate the field data
        &#34;&#34;&#34;
        if not isinstance(self.value, int):
            return _EX.InvalidFieldDataException(
                f&#34;Passed value type ({type(self.value)}) is not an integer&#34;
            )

        if self.value &gt; MAX_INT64:
            return _EX.IntegerOverflowException(
                f&#34;Passed value {self.value} is too large for a 64-bit integer&#34;
            )

        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.DateTimeField" href="#sshkey_tools.fields.DateTimeField">DateTimeField</a></li>
<li><a title="sshkey_tools.fields.SerialField" href="#sshkey_tools.fields.SerialField">SerialField</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.Integer64Field.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data:bytes) >Tuple[int,bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes a 64-bit integer from a block of bytes</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>Block of bytes containing an integer</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>Tuple with integer and remainder of data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; Tuple[int, bytes]:
    &#34;&#34;&#34;Decodes a 64-bit integer from a block of bytes

    Args:
        data (bytes): Block of bytes containing an integer

    Returns:
        tuple: Tuple with integer and remainder of data
    &#34;&#34;&#34;
    return int(unpack(&#34;&gt;Q&#34;, data[:8])[0]), data[8:]</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.Integer64Field.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>value:int) >bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes a 64-bit integer value to a packed byte string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source_int</code></strong> :&ensp;<code>int</code></dt>
<dd>Integer to be packed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>Packed byte string containing integer</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def encode(value: int) -&gt; bytes:
    &#34;&#34;&#34;Encodes a 64-bit integer value to a packed byte string

    Args:
        source_int (int): Integer to be packed

    Returns:
        bytes: Packed byte string containing integer
    &#34;&#34;&#34;
    if not isinstance(value, int):
        raise _EX.InvalidFieldDataException(
            f&#34;Expected int, got {value.__class__.__name__}&#34;
        )

    return pack(&#34;&gt;Q&#34;, value)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.Integer64Field.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) >Union[bool,Exception]</span>
</code></dt>
<dd>
<div class="desc"><p>Validate the field data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; Union[bool, Exception]:
    &#34;&#34;&#34;
    Validate the field data
    &#34;&#34;&#34;
    if not isinstance(self.value, int):
        return _EX.InvalidFieldDataException(
            f&#34;Passed value type ({type(self.value)}) is not an integer&#34;
        )

    if self.value &gt; MAX_INT64:
        return _EX.IntegerOverflowException(
            f&#34;Passed value {self.value} is too large for a 64-bit integer&#34;
        )

    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.CertificateField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.KeyIDField"><code class="flex name class">
<span>class <span class="ident">KeyIDField</span></span>
<span>(</span><span>value:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains the key identifier (subject) of the certificate,
alphanumeric string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KeyIDField(StringField):
    &#34;&#34;&#34;
    Contains the key identifier (subject) of the certificate,
    alphanumeric string
    &#34;&#34;&#34;

    def __init__(self, value: str):
        super().__init__(value=value, name=&#34;key_id&#34;)

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates that the field is set and not empty
        &#34;&#34;&#34;
        if self.value in [None, False, &#34;&#34;, &#34; &#34;]:
            return _EX.InvalidDataException(&#34;You need to provide a Key ID&#34;)

        return super().validate()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.StringField" href="#sshkey_tools.fields.StringField">StringField</a></li>
<li><a title="sshkey_tools.fields.BytestringField" href="#sshkey_tools.fields.BytestringField">BytestringField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.KeyIDField.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) >Union[bool,Exception]</span>
</code></dt>
<dd>
<div class="desc"><p>Validates that the field is set and not empty</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; Union[bool, Exception]:
    &#34;&#34;&#34;
    Validates that the field is set and not empty
    &#34;&#34;&#34;
    if self.value in [None, False, &#34;&#34;, &#34; &#34;]:
        return _EX.InvalidDataException(&#34;You need to provide a Key ID&#34;)

    return super().validate()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.StringField" href="#sshkey_tools.fields.StringField">StringField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.StringField.decode" href="#sshkey_tools.fields.BytestringField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.StringField.encode" href="#sshkey_tools.fields.BytestringField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.StringField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.KeyValueField"><code class="flex name class">
<span>class <span class="ident">KeyValueField</span></span>
<span>(</span><span>value, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Certificate field representing a list or integer in python,
separated in byte-form by null-bytes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KeyValueField(CertificateField):
    &#34;&#34;&#34;
    Certificate field representing a list or integer in python,
    separated in byte-form by null-bytes.
    &#34;&#34;&#34;

    @staticmethod
    def encode(value: Union[list, tuple, dict, set]) -&gt; bytes:
        &#34;&#34;&#34;
        Encodes a dict, set, list or tuple into a key-value byte string.
        If a set, list or tuple is provided, the items are considered keys
        and added with empty values.

        Args:
            source_list (dict, set, list, tuple): list of strings

        Returns:
            bytes: Packed byte string containing the source data
        &#34;&#34;&#34;
        if not isinstance(value, (list, tuple, dict, set)):
            raise _EX.InvalidFieldDataException(
                f&#34;Expected (list, tuple), got {value.__class__.__name__}&#34;
            )

        if not isinstance(value, dict):
            value = {item: &#34;&#34; for item in value}

        list_data = b&#34;&#34;

        for key, item in value.items():
            list_data += StringField.encode(key)

            item = (
                StringField.encode(item)
                if item in [&#34;&#34;, b&#34;&#34;]
                else ListField.encode(
                    [item] if isinstance(item, (str, bytes)) else item
                )
            )

            list_data += item

        return BytestringField.encode(list_data)

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[dict, bytes]:
        &#34;&#34;&#34;Decodes a list of strings from a block of bytes

        Args:
            data (bytes): The block of bytes containing a list of strings
        Returns:
            tuple: _description_
        &#34;&#34;&#34;
        list_bytes, data = BytestringField.decode(data)

        decoded = {}
        while len(list_bytes) &gt; 0:
            key, list_bytes = StringField.decode(list_bytes)
            value, list_bytes = BytestringField.decode(list_bytes)

            if value != b&#34;&#34;:
                value = StringField.decode(value)[0]

            decoded[key] = &#34;&#34; if value == b&#34;&#34; else value

        if &#34;&#34;.join(decoded.values()) == &#34;&#34;:
            return list(decoded.keys()), data

        return decoded, data

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validate the field data
        &#34;&#34;&#34;
        if not isinstance(self.value, (list, tuple, dict, set)):
            return _EX.InvalidFieldDataException(
                f&#34;Passed value type ({type(self.value)}) is not a list/tuple/dict/set&#34;
            )

        if isinstance(self.value, (dict)):
            if (
                sum([not isinstance(item, (str, bytes)) for item in self.value.keys()])
                &gt; 0
            ):
                return _EX.InvalidFieldDataException(
                    &#34;Expected a dict with string or byte keys&#34;
                )

        if (
            isinstance(self.value, (list, tuple, set))
            and sum([not isinstance(item, (str, bytes)) for item in self.value]) &gt; 0
        ):
            return _EX.InvalidFieldDataException(
                &#34;Expected list, tuple or set containing strings or bytes&#34;
            )

        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.CriticalOptionsField" href="#sshkey_tools.fields.CriticalOptionsField">CriticalOptionsField</a></li>
<li><a title="sshkey_tools.fields.ExtensionsField" href="#sshkey_tools.fields.ExtensionsField">ExtensionsField</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.KeyValueField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data:bytes) >Tuple[dict,bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes a list of strings from a block of bytes</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The block of bytes containing a list of strings</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd><em>description</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; Tuple[dict, bytes]:
    &#34;&#34;&#34;Decodes a list of strings from a block of bytes

    Args:
        data (bytes): The block of bytes containing a list of strings
    Returns:
        tuple: _description_
    &#34;&#34;&#34;
    list_bytes, data = BytestringField.decode(data)

    decoded = {}
    while len(list_bytes) &gt; 0:
        key, list_bytes = StringField.decode(list_bytes)
        value, list_bytes = BytestringField.decode(list_bytes)

        if value != b&#34;&#34;:
            value = StringField.decode(value)[0]

        decoded[key] = &#34;&#34; if value == b&#34;&#34; else value

    if &#34;&#34;.join(decoded.values()) == &#34;&#34;:
        return list(decoded.keys()), data

    return decoded, data</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.KeyValueField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>value:Union[list,tuple,dict,set]) >bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes a dict, set, list or tuple into a key-value byte string.
If a set, list or tuple is provided, the items are considered keys
and added with empty values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source_list</code></strong> :&ensp;<code>dict, set, list, tuple</code></dt>
<dd>list of strings</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>Packed byte string containing the source data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def encode(value: Union[list, tuple, dict, set]) -&gt; bytes:
    &#34;&#34;&#34;
    Encodes a dict, set, list or tuple into a key-value byte string.
    If a set, list or tuple is provided, the items are considered keys
    and added with empty values.

    Args:
        source_list (dict, set, list, tuple): list of strings

    Returns:
        bytes: Packed byte string containing the source data
    &#34;&#34;&#34;
    if not isinstance(value, (list, tuple, dict, set)):
        raise _EX.InvalidFieldDataException(
            f&#34;Expected (list, tuple), got {value.__class__.__name__}&#34;
        )

    if not isinstance(value, dict):
        value = {item: &#34;&#34; for item in value}

    list_data = b&#34;&#34;

    for key, item in value.items():
        list_data += StringField.encode(key)

        item = (
            StringField.encode(item)
            if item in [&#34;&#34;, b&#34;&#34;]
            else ListField.encode(
                [item] if isinstance(item, (str, bytes)) else item
            )
        )

        list_data += item

    return BytestringField.encode(list_data)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.KeyValueField.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) >Union[bool,Exception]</span>
</code></dt>
<dd>
<div class="desc"><p>Validate the field data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; Union[bool, Exception]:
    &#34;&#34;&#34;
    Validate the field data
    &#34;&#34;&#34;
    if not isinstance(self.value, (list, tuple, dict, set)):
        return _EX.InvalidFieldDataException(
            f&#34;Passed value type ({type(self.value)}) is not a list/tuple/dict/set&#34;
        )

    if isinstance(self.value, (dict)):
        if (
            sum([not isinstance(item, (str, bytes)) for item in self.value.keys()])
            &gt; 0
        ):
            return _EX.InvalidFieldDataException(
                &#34;Expected a dict with string or byte keys&#34;
            )

    if (
        isinstance(self.value, (list, tuple, set))
        and sum([not isinstance(item, (str, bytes)) for item in self.value]) &gt; 0
    ):
        return _EX.InvalidFieldDataException(
            &#34;Expected list, tuple or set containing strings or bytes&#34;
        )

    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.CertificateField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.ListField"><code class="flex name class">
<span>class <span class="ident">ListField</span></span>
<span>(</span><span>value, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Certificate field representing a list or tuple of strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ListField(CertificateField):
    &#34;&#34;&#34;
    Certificate field representing a list or tuple of strings
    &#34;&#34;&#34;

    @staticmethod
    def encode(value: Union[list, tuple, set]) -&gt; bytes:
        &#34;&#34;&#34;Encodes a list or tuple to a byte string

        Args:
            source_list (list): list of strings
            null_separator (bool, optional): Insert blank string string between items. Default None

        Returns:
            bytes: Packed byte string containing the source data
        &#34;&#34;&#34;
        if not isinstance(value, (list, tuple, set)):
            raise _EX.InvalidFieldDataException(
                f&#34;Expected (list, tuple, set), got {value.__class__.__name__}&#34;
            )

        try:
            if sum([not isinstance(item, (str, bytes)) for item in value]) &gt; 0:
                raise TypeError
        except TypeError:
            raise _EX.InvalidFieldDataException(
                &#34;Expected list or tuple containing strings or bytes&#34;
            ) from TypeError

        return BytestringField.encode(b&#34;&#34;.join([StringField.encode(x) for x in value]))

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[list, bytes]:
        &#34;&#34;&#34;Decodes a list of strings from a block of bytes

        Args:
            data (bytes): The block of bytes containing a list of strings
        Returns:
            tuple: _description_
        &#34;&#34;&#34;
        list_bytes, data = BytestringField.decode(data)

        decoded = []
        while len(list_bytes) &gt; 0:
            elem, list_bytes = StringField.decode(list_bytes)
            decoded.append(elem)

        return decoded, data

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validate the field data
        &#34;&#34;&#34;
        if not isinstance(self.value, (list, tuple)):
            return _EX.InvalidFieldDataException(
                f&#34;Passed value type ({type(self.value)}) is not a list/tuple&#34;
            )

        if sum([not isinstance(item, (str, bytes)) for item in self.value]) &gt; 0:
            return _EX.InvalidFieldDataException(
                &#34;Expected list or tuple containing strings or bytes&#34;
            )

        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.PrincipalsField" href="#sshkey_tools.fields.PrincipalsField">PrincipalsField</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.ListField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data:bytes) >Tuple[list,bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes a list of strings from a block of bytes</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The block of bytes containing a list of strings</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd><em>description</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; Tuple[list, bytes]:
    &#34;&#34;&#34;Decodes a list of strings from a block of bytes

    Args:
        data (bytes): The block of bytes containing a list of strings
    Returns:
        tuple: _description_
    &#34;&#34;&#34;
    list_bytes, data = BytestringField.decode(data)

    decoded = []
    while len(list_bytes) &gt; 0:
        elem, list_bytes = StringField.decode(list_bytes)
        decoded.append(elem)

    return decoded, data</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.ListField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>value:Union[list,tuple,set]) >bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes a list or tuple to a byte string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source_list</code></strong> :&ensp;<code>list</code></dt>
<dd>list of strings</dd>
<dt><strong><code>null_separator</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Insert blank string string between items. Default None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>Packed byte string containing the source data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def encode(value: Union[list, tuple, set]) -&gt; bytes:
    &#34;&#34;&#34;Encodes a list or tuple to a byte string

    Args:
        source_list (list): list of strings
        null_separator (bool, optional): Insert blank string string between items. Default None

    Returns:
        bytes: Packed byte string containing the source data
    &#34;&#34;&#34;
    if not isinstance(value, (list, tuple, set)):
        raise _EX.InvalidFieldDataException(
            f&#34;Expected (list, tuple, set), got {value.__class__.__name__}&#34;
        )

    try:
        if sum([not isinstance(item, (str, bytes)) for item in value]) &gt; 0:
            raise TypeError
    except TypeError:
        raise _EX.InvalidFieldDataException(
            &#34;Expected list or tuple containing strings or bytes&#34;
        ) from TypeError

    return BytestringField.encode(b&#34;&#34;.join([StringField.encode(x) for x in value]))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.ListField.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) >Union[bool,Exception]</span>
</code></dt>
<dd>
<div class="desc"><p>Validate the field data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; Union[bool, Exception]:
    &#34;&#34;&#34;
    Validate the field data
    &#34;&#34;&#34;
    if not isinstance(self.value, (list, tuple)):
        return _EX.InvalidFieldDataException(
            f&#34;Passed value type ({type(self.value)}) is not a list/tuple&#34;
        )

    if sum([not isinstance(item, (str, bytes)) for item in self.value]) &gt; 0:
        return _EX.InvalidFieldDataException(
            &#34;Expected list or tuple containing strings or bytes&#34;
        )

    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.CertificateField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.MpIntegerField"><code class="flex name class">
<span>class <span class="ident">MpIntegerField</span></span>
<span>(</span><span>value, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Certificate field representing a multiple precision integer,
an integer too large to fit in 64 bits.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MpIntegerField(BytestringField):
    &#34;&#34;&#34;
    Certificate field representing a multiple precision integer,
    an integer too large to fit in 64 bits.
    &#34;&#34;&#34;

    @staticmethod
    # pylint: disable=arguments-differ
    def encode(value: int) -&gt; bytes:
        &#34;&#34;&#34;
        Encodes a multiprecision integer (integer larger than 64bit)
        into a packed byte string

        Args:
            value (int): Large integer

        Returns:
            bytes: Packed byte string containing integer
        &#34;&#34;&#34;
        if not isinstance(value, int):
            raise _EX.InvalidFieldDataException(
                f&#34;Expected int, got {value.__class__.__name__}&#34;
            )

        return BytestringField.encode(long_to_bytes(value))

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[int, bytes]:
        &#34;&#34;&#34;Decodes a multiprecision integer (integer larger than 64bit)

        Args:
            data (bytes): Block of bytes containing a long (mp) integer

        Returns:
            tuple: Tuple with integer and remainder of data
        &#34;&#34;&#34;
        mpint, data = BytestringField.decode(data)
        return bytes_to_long(mpint), data

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validate the field data
        &#34;&#34;&#34;
        if not isinstance(self.value, int):
            return _EX.InvalidFieldDataException(
                f&#34;Passed value type ({type(self.value)}) is not an integer&#34;
            )

        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.BytestringField" href="#sshkey_tools.fields.BytestringField">BytestringField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.MpIntegerField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data:bytes) >Tuple[int,bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes a multiprecision integer (integer larger than 64bit)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>Block of bytes containing a long (mp) integer</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>Tuple with integer and remainder of data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; Tuple[int, bytes]:
    &#34;&#34;&#34;Decodes a multiprecision integer (integer larger than 64bit)

    Args:
        data (bytes): Block of bytes containing a long (mp) integer

    Returns:
        tuple: Tuple with integer and remainder of data
    &#34;&#34;&#34;
    mpint, data = BytestringField.decode(data)
    return bytes_to_long(mpint), data</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.MpIntegerField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>value:int) >bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes a multiprecision integer (integer larger than 64bit)
into a packed byte string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code></dt>
<dd>Large integer</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>Packed byte string containing integer</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
# pylint: disable=arguments-differ
def encode(value: int) -&gt; bytes:
    &#34;&#34;&#34;
    Encodes a multiprecision integer (integer larger than 64bit)
    into a packed byte string

    Args:
        value (int): Large integer

    Returns:
        bytes: Packed byte string containing integer
    &#34;&#34;&#34;
    if not isinstance(value, int):
        raise _EX.InvalidFieldDataException(
            f&#34;Expected int, got {value.__class__.__name__}&#34;
        )

    return BytestringField.encode(long_to_bytes(value))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.BytestringField" href="#sshkey_tools.fields.BytestringField">BytestringField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.BytestringField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.BytestringField.validate" href="#sshkey_tools.fields.BytestringField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.NonceField"><code class="flex name class">
<span>class <span class="ident">NonceField</span></span>
<span>(</span><span>value:str=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains the nonce for the certificate, randomly generated
this protects the integrity of the private key, especially
for ecdsa.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NonceField(StringField):
    &#34;&#34;&#34;
    Contains the nonce for the certificate, randomly generated
    this protects the integrity of the private key, especially
    for ecdsa.
    &#34;&#34;&#34;

    def __init__(self, value: str = None):
        super().__init__(
            value=value if value is not None else generate_secure_nonce(), name=&#34;nonce&#34;
        )

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validate the field data
        &#34;&#34;&#34;
        if len(self.value) &lt; 32:
            self.exception = _EX.InsecureNonceException(
                &#34;Nonce should be at least 32 bytes long to be secure. &#34;
                + &#34;This is especially important for ECDSA&#34;
            )
            return False

        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.StringField" href="#sshkey_tools.fields.StringField">StringField</a></li>
<li><a title="sshkey_tools.fields.BytestringField" href="#sshkey_tools.fields.BytestringField">BytestringField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.StringField" href="#sshkey_tools.fields.StringField">StringField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.StringField.decode" href="#sshkey_tools.fields.BytestringField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.StringField.encode" href="#sshkey_tools.fields.BytestringField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.StringField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.StringField.validate" href="#sshkey_tools.fields.BytestringField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.PrincipalsField"><code class="flex name class">
<span>class <span class="ident">PrincipalsField</span></span>
<span>(</span><span>value:Union[list,tuple])</span>
</code></dt>
<dd>
<div class="desc"><p>Contains a list of principals for the certificate,
e.g. SERVERHOSTNAME01 or all-web-servers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PrincipalsField(ListField):
    &#34;&#34;&#34;
    Contains a list of principals for the certificate,
    e.g. SERVERHOSTNAME01 or all-web-servers
    &#34;&#34;&#34;

    def __init__(self, value: Union[list, tuple]):
        super().__init__(value=list(value), name=&#34;principals&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.ListField" href="#sshkey_tools.fields.ListField">ListField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.ListField" href="#sshkey_tools.fields.ListField">ListField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.ListField.decode" href="#sshkey_tools.fields.ListField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.ListField.encode" href="#sshkey_tools.fields.ListField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.ListField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.ListField.validate" href="#sshkey_tools.fields.ListField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.PubkeyTypeField"><code class="flex name class">
<span>class <span class="ident">PubkeyTypeField</span></span>
<span>(</span><span>value:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains the certificate type, which is based on the
public key type the certificate is created for, e.g.
'ssh-ed25519-cert-v01@openssh.com' for an ED25519 key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PubkeyTypeField(StringField):
    &#34;&#34;&#34;
    Contains the certificate type, which is based on the
    public key type the certificate is created for, e.g.
    &#39;ssh-ed25519-cert-v01@openssh.com&#39; for an ED25519 key
    &#34;&#34;&#34;

    def __init__(self, value: str):
        super().__init__(
            value=value,
            name=&#34;pubkey_type&#34;,
        )

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validate the field data
        &#34;&#34;&#34;
        if self.value not in (
            &#34;ssh-rsa-cert-v01@openssh.com&#34;,
            &#34;rsa-sha2-256-cert-v01@openssh.com&#34;,
            &#34;rsa-sha2-512-cert-v01@openssh.com&#34;,
            &#34;ssh-dss-cert-v01@openssh.com&#34;,
            &#34;ecdsa-sha2-nistp256-cert-v01@openssh.com&#34;,
            &#34;ecdsa-sha2-nistp384-cert-v01@openssh.com&#34;,
            &#34;ecdsa-sha2-nistp521-cert-v01@openssh.com&#34;,
            &#34;ssh-ed25519-cert-v01@openssh.com&#34;,
        ):
            return _EX.InvalidDataException(f&#34;Invalid pubkey type: {self.value}&#34;)

        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.StringField" href="#sshkey_tools.fields.StringField">StringField</a></li>
<li><a title="sshkey_tools.fields.BytestringField" href="#sshkey_tools.fields.BytestringField">BytestringField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.StringField" href="#sshkey_tools.fields.StringField">StringField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.StringField.decode" href="#sshkey_tools.fields.BytestringField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.StringField.encode" href="#sshkey_tools.fields.BytestringField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.StringField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.StringField.validate" href="#sshkey_tools.fields.BytestringField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.PublicKeyField"><code class="flex name class">
<span>class <span class="ident">PublicKeyField</span></span>
<span>(</span><span>value:<a title="sshkey_tools.keys.PublicKey" href="keys.html#sshkey_tools.keys.PublicKey">PublicKey</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains the subject (User or Host) public key for whom/which
the certificate is created.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PublicKeyField(CertificateField):
    &#34;&#34;&#34;
    Contains the subject (User or Host) public key for whom/which
    the certificate is created.
    &#34;&#34;&#34;

    def __init__(self, value: PublicKey):
        super().__init__(value=value, name=&#34;public_key&#34;)

    def __str__(self) -&gt; str:
        return &#34; &#34;.join(
            [
                self.__class__.__name__.replace(&#34;PubkeyField&#34;, &#34;&#34;),
                self.value.get_fingerprint(),
            ]
        )

    @staticmethod
    def encode(value: PublicKey) -&gt; bytes:
        &#34;&#34;&#34;
        Encode the certificate field to a byte string

        Args:
            value (RsaPublicKey): The public key to encode

        Returns:
            bytes: A byte string with the encoded public key
        &#34;&#34;&#34;
        if not isinstance(value, PublicKey):
            raise _EX.InvalidFieldDataException(
                f&#34;Expected PublicKey, got {value.__class__.__name__}&#34;
            )

        return BytestringField.decode(value.raw_bytes())[1]

    @staticmethod
    def from_object(public_key: PublicKey):
        &#34;&#34;&#34;
        Loads the public key from a sshkey_tools.keys.PublicKey
        class or childclass

        Args:
            public_key (PublicKey): The public key for which to
                                    create the certificate

        Raises:
            _EX.InvalidKeyException: Invalid public key

        Returns:
            PublicKeyField: A child class of PublicKeyField specific
                            to the chosen public key
        &#34;&#34;&#34;
        try:
            return globals()[SUBJECT_PUBKEY_MAP[public_key.__class__]](value=public_key)
        except KeyError:
            raise _EX.InvalidKeyException(&#34;The public key is invalid&#34;) from KeyError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.DSAPubkeyField" href="#sshkey_tools.fields.DSAPubkeyField">DSAPubkeyField</a></li>
<li><a title="sshkey_tools.fields.ECDSAPubkeyField" href="#sshkey_tools.fields.ECDSAPubkeyField">ECDSAPubkeyField</a></li>
<li><a title="sshkey_tools.fields.ED25519PubkeyField" href="#sshkey_tools.fields.ED25519PubkeyField">ED25519PubkeyField</a></li>
<li><a title="sshkey_tools.fields.RSAPubkeyField" href="#sshkey_tools.fields.RSAPubkeyField">RSAPubkeyField</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.PublicKeyField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>value:<a title="sshkey_tools.keys.PublicKey" href="keys.html#sshkey_tools.keys.PublicKey">PublicKey</a>) >bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encode the certificate field to a byte string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>RsaPublicKey</code></dt>
<dd>The public key to encode</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>A byte string with the encoded public key</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def encode(value: PublicKey) -&gt; bytes:
    &#34;&#34;&#34;
    Encode the certificate field to a byte string

    Args:
        value (RsaPublicKey): The public key to encode

    Returns:
        bytes: A byte string with the encoded public key
    &#34;&#34;&#34;
    if not isinstance(value, PublicKey):
        raise _EX.InvalidFieldDataException(
            f&#34;Expected PublicKey, got {value.__class__.__name__}&#34;
        )

    return BytestringField.decode(value.raw_bytes())[1]</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.PublicKeyField.from_object"><code class="name flex">
<span>def <span class="ident">from_object</span></span>(<span>public_key:<a title="sshkey_tools.keys.PublicKey" href="keys.html#sshkey_tools.keys.PublicKey">PublicKey</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads the public key from a sshkey_tools.keys.PublicKey
class or childclass</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>public_key</code></strong> :&ensp;<code>PublicKey</code></dt>
<dd>The public key for which to
create the certificate</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>_EX.InvalidKeyException</code></dt>
<dd>Invalid public key</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sshkey_tools.fields.PublicKeyField" href="#sshkey_tools.fields.PublicKeyField">PublicKeyField</a></code></dt>
<dd>A child class of PublicKeyField specific
to the chosen public key</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_object(public_key: PublicKey):
    &#34;&#34;&#34;
    Loads the public key from a sshkey_tools.keys.PublicKey
    class or childclass

    Args:
        public_key (PublicKey): The public key for which to
                                create the certificate

    Raises:
        _EX.InvalidKeyException: Invalid public key

    Returns:
        PublicKeyField: A child class of PublicKeyField specific
                        to the chosen public key
    &#34;&#34;&#34;
    try:
        return globals()[SUBJECT_PUBKEY_MAP[public_key.__class__]](value=public_key)
    except KeyError:
        raise _EX.InvalidKeyException(&#34;The public key is invalid&#34;) from KeyError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.CertificateField.decode" href="#sshkey_tools.fields.CertificateField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.RSAPubkeyField"><code class="flex name class">
<span>class <span class="ident">RSAPubkeyField</span></span>
<span>(</span><span>value:<a title="sshkey_tools.keys.PublicKey" href="keys.html#sshkey_tools.keys.PublicKey">PublicKey</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Holds the RSA Public Key for RSA Certificates</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RSAPubkeyField(PublicKeyField):
    &#34;&#34;&#34;
    Holds the RSA Public Key for RSA Certificates
    &#34;&#34;&#34;

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[RsaPublicKey, bytes]:
        &#34;&#34;&#34;
        Decode the certificate field from a byte string
        starting with the encoded public key

        Args:
            data (bytes): The byte string starting with the encoded key

        Returns:
            Tuple[RsaPublicKey, bytes]: The PublicKey field and remainder of the data
        &#34;&#34;&#34;
        e, data = MpIntegerField.decode(data)
        n, data = MpIntegerField.decode(data)

        return RsaPublicKey.from_numbers(e=e, n=n), data

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validates that the field data is a valid RSA Public Key
        &#34;&#34;&#34;
        if not isinstance(self.value, RsaPublicKey):
            return _EX.InvalidFieldDataException(
                &#34;This public key class is not valid for use in a certificate&#34;
            )

        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.PublicKeyField" href="#sshkey_tools.fields.PublicKeyField">PublicKeyField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.RSAPubkeyField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data:bytes) >Tuple[<a title="sshkey_tools.keys.RsaPublicKey" href="keys.html#sshkey_tools.keys.RsaPublicKey">RsaPublicKey</a>,bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Decode the certificate field from a byte string
starting with the encoded public key</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The byte string starting with the encoded key</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[RsaPublicKey, bytes]</code></dt>
<dd>The PublicKey field and remainder of the data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; Tuple[RsaPublicKey, bytes]:
    &#34;&#34;&#34;
    Decode the certificate field from a byte string
    starting with the encoded public key

    Args:
        data (bytes): The byte string starting with the encoded key

    Returns:
        Tuple[RsaPublicKey, bytes]: The PublicKey field and remainder of the data
    &#34;&#34;&#34;
    e, data = MpIntegerField.decode(data)
    n, data = MpIntegerField.decode(data)

    return RsaPublicKey.from_numbers(e=e, n=n), data</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.RSAPubkeyField.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) >Union[bool,Exception]</span>
</code></dt>
<dd>
<div class="desc"><p>Validates that the field data is a valid RSA Public Key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; Union[bool, Exception]:
    &#34;&#34;&#34;
    Validates that the field data is a valid RSA Public Key
    &#34;&#34;&#34;
    if not isinstance(self.value, RsaPublicKey):
        return _EX.InvalidFieldDataException(
            &#34;This public key class is not valid for use in a certificate&#34;
        )

    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.PublicKeyField" href="#sshkey_tools.fields.PublicKeyField">PublicKeyField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.PublicKeyField.encode" href="#sshkey_tools.fields.PublicKeyField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.from_object" href="#sshkey_tools.fields.PublicKeyField.from_object">from_object</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.RSASignatureField"><code class="flex name class">
<span>class <span class="ident">RSASignatureField</span></span>
<span>(</span><span>private_key:<a title="sshkey_tools.keys.RsaPrivateKey" href="keys.html#sshkey_tools.keys.RsaPrivateKey">RsaPrivateKey</a>=None, hash_alg:<a title="sshkey_tools.keys.RsaAlgs" href="keys.html#sshkey_tools.keys.RsaAlgs">RsaAlgs</a>=RsaAlgs.SHA512, signature:bytes=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and contains the RSA signature from an RSA Private Key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RSASignatureField(SignatureField):
    &#34;&#34;&#34;
    Creates and contains the RSA signature from an RSA Private Key
    &#34;&#34;&#34;

    def __init__(
        self,
        private_key: RsaPrivateKey = None,
        hash_alg: RsaAlgs = RsaAlgs.SHA512,
        signature: bytes = None,
    ):
        super().__init__(private_key, signature)
        self.hash_alg = hash_alg

    @staticmethod
    # pylint: disable=arguments-renamed
    def encode(signature: bytes, hash_alg: RsaAlgs = RsaAlgs.SHA256) -&gt; bytes:
        &#34;&#34;&#34;
        Encodes the signature to a byte string

        Args:
            signature (bytes): The signature bytes to encode
            hash_alg (RsaAlgs, optional):  The hash algorithm used for the signature.
                                            Defaults to RsaAlgs.SHA256.

        Returns:
            bytes: The encoded byte string
        &#34;&#34;&#34;
        if not isinstance(signature, bytes):
            raise _EX.InvalidFieldDataException(
                f&#34;Expected bytes, got {signature.__class__.__name__}&#34;
            )

        return BytestringField.encode(
            StringField.encode(hash_alg.value[0]) + BytestringField.encode(signature)
        )

    @staticmethod
    def decode(data: bytes) -&gt; Tuple[Tuple[bytes, bytes], bytes]:
        &#34;&#34;&#34;
        Decodes a bytestring containing a signature

        Args:
            data (bytes): The bytestring starting with the RSA Signature

        Returns:
            Tuple[ Tuple[ bytes, bytes ], bytes ]: (signature_type, signature), remainder of data
        &#34;&#34;&#34;
        signature, data = BytestringField.decode(data)

        sig_type, signature = StringField.decode(signature)
        signature, _ = BytestringField.decode(signature)

        return (sig_type, signature), data

    @classmethod
    def from_decode(cls, data: bytes) -&gt; Tuple[&#34;RSASignatureField&#34;, bytes]:
        &#34;&#34;&#34;
        Generates an RSASignatureField class from the encoded signature

        Args:
            data (bytes): The bytestring containing the encoded signature

        Raises:
            _EX.InvalidDataException: Invalid data

        Returns:
            Tuple[RSASignatureField, bytes]: RSA Signature field and remainder of data
        &#34;&#34;&#34;
        signature, data = cls.decode(data)

        return (
            cls(
                private_key=None,
                hash_alg=[alg for alg in RsaAlgs if alg.value[0] == signature[0]][0],
                signature=signature[1],
            ),
            data,
        )

    def sign(self, data: bytes, hash_alg: RsaAlgs = RsaAlgs.SHA256) -&gt; None:
        &#34;&#34;&#34;
        Signs the provided data with the provided private key

        Args:
            data (bytes): The data to be signed
            hash_alg (RsaAlgs, optional): The RSA algorithm to use for hashing.
                                           Defaults to RsaAlgs.SHA256.
        &#34;&#34;&#34;
        self.value = self.private_key.sign(data, hash_alg)

        self.hash_alg = hash_alg
        self.is_signed = True

    def __bytes__(self):
        return self.encode(self.value, self.hash_alg)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.SignatureField" href="#sshkey_tools.fields.SignatureField">SignatureField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.RSASignatureField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>data:bytes) >Tuple[Tuple[bytes,bytes],bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes a bytestring containing a signature</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The bytestring starting with the RSA Signature</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[ Tuple[ bytes, bytes ], bytes ]</code></dt>
<dd>(signature_type, signature), remainder of data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(data: bytes) -&gt; Tuple[Tuple[bytes, bytes], bytes]:
    &#34;&#34;&#34;
    Decodes a bytestring containing a signature

    Args:
        data (bytes): The bytestring starting with the RSA Signature

    Returns:
        Tuple[ Tuple[ bytes, bytes ], bytes ]: (signature_type, signature), remainder of data
    &#34;&#34;&#34;
    signature, data = BytestringField.decode(data)

    sig_type, signature = StringField.decode(signature)
    signature, _ = BytestringField.decode(signature)

    return (sig_type, signature), data</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.RSASignatureField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>signature:bytes, hash_alg:<a title="sshkey_tools.keys.RsaAlgs" href="keys.html#sshkey_tools.keys.RsaAlgs">RsaAlgs</a>=RsaAlgs.SHA256) >bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes the signature to a byte string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>signature</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The signature bytes to encode</dd>
<dt><strong><code>hash_alg</code></strong> :&ensp;<code>RsaAlgs</code>, optional</dt>
<dd>The hash algorithm used for the signature.
Defaults to RsaAlgs.SHA256.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>The encoded byte string</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
# pylint: disable=arguments-renamed
def encode(signature: bytes, hash_alg: RsaAlgs = RsaAlgs.SHA256) -&gt; bytes:
    &#34;&#34;&#34;
    Encodes the signature to a byte string

    Args:
        signature (bytes): The signature bytes to encode
        hash_alg (RsaAlgs, optional):  The hash algorithm used for the signature.
                                        Defaults to RsaAlgs.SHA256.

    Returns:
        bytes: The encoded byte string
    &#34;&#34;&#34;
    if not isinstance(signature, bytes):
        raise _EX.InvalidFieldDataException(
            f&#34;Expected bytes, got {signature.__class__.__name__}&#34;
        )

    return BytestringField.encode(
        StringField.encode(hash_alg.value[0]) + BytestringField.encode(signature)
    )</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.RSASignatureField.from_decode"><code class="name flex">
<span>def <span class="ident">from_decode</span></span>(<span>data:bytes) >Tuple[<a title="sshkey_tools.fields.RSASignatureField" href="#sshkey_tools.fields.RSASignatureField">RSASignatureField</a>,bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Generates an RSASignatureField class from the encoded signature</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The bytestring containing the encoded signature</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>_EX.InvalidDataException</code></dt>
<dd>Invalid data</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[<a title="sshkey_tools.fields.RSASignatureField" href="#sshkey_tools.fields.RSASignatureField">RSASignatureField</a>, bytes]</code></dt>
<dd>RSA Signature field and remainder of data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_decode(cls, data: bytes) -&gt; Tuple[&#34;RSASignatureField&#34;, bytes]:
    &#34;&#34;&#34;
    Generates an RSASignatureField class from the encoded signature

    Args:
        data (bytes): The bytestring containing the encoded signature

    Raises:
        _EX.InvalidDataException: Invalid data

    Returns:
        Tuple[RSASignatureField, bytes]: RSA Signature field and remainder of data
    &#34;&#34;&#34;
    signature, data = cls.decode(data)

    return (
        cls(
            private_key=None,
            hash_alg=[alg for alg in RsaAlgs if alg.value[0] == signature[0]][0],
            signature=signature[1],
        ),
        data,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.RSASignatureField.sign"><code class="name flex">
<span>def <span class="ident">sign</span></span>(<span>self, data:bytes, hash_alg:<a title="sshkey_tools.keys.RsaAlgs" href="keys.html#sshkey_tools.keys.RsaAlgs">RsaAlgs</a>=RsaAlgs.SHA256) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Signs the provided data with the provided private key</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The data to be signed</dd>
<dt><strong><code>hash_alg</code></strong> :&ensp;<code>RsaAlgs</code>, optional</dt>
<dd>The RSA algorithm to use for hashing.
Defaults to RsaAlgs.SHA256.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sign(self, data: bytes, hash_alg: RsaAlgs = RsaAlgs.SHA256) -&gt; None:
    &#34;&#34;&#34;
    Signs the provided data with the provided private key

    Args:
        data (bytes): The data to be signed
        hash_alg (RsaAlgs, optional): The RSA algorithm to use for hashing.
                                       Defaults to RsaAlgs.SHA256.
    &#34;&#34;&#34;
    self.value = self.private_key.sign(data, hash_alg)

    self.hash_alg = hash_alg
    self.is_signed = True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.SignatureField" href="#sshkey_tools.fields.SignatureField">SignatureField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.SignatureField.can_sign" href="#sshkey_tools.fields.SignatureField.can_sign">can_sign</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.from_object" href="#sshkey_tools.fields.SignatureField.from_object">from_object</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.ReservedField"><code class="flex name class">
<span>class <span class="ident">ReservedField</span></span>
<span>(</span><span>value:str='')</span>
</code></dt>
<dd>
<div class="desc"><p>This field is reserved for future use, and
doesn't contain any actual data, just an empty string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReservedField(StringField):
    &#34;&#34;&#34;
    This field is reserved for future use, and
    doesn&#39;t contain any actual data, just an empty string.
    &#34;&#34;&#34;

    def __init__(self, value: str = &#34;&#34;):
        super().__init__(value=value, name=&#34;reserved&#34;)

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validate that the field only contains an empty string
        &#34;&#34;&#34;
        if self.value == &#34;&#34;:
            return True

        return _EX.InvalidDataException(
            &#34;The reserved field needs to be an empty string&#34;
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.StringField" href="#sshkey_tools.fields.StringField">StringField</a></li>
<li><a title="sshkey_tools.fields.BytestringField" href="#sshkey_tools.fields.BytestringField">BytestringField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.ReservedField.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) >Union[bool,Exception]</span>
</code></dt>
<dd>
<div class="desc"><p>Validate that the field only contains an empty string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; Union[bool, Exception]:
    &#34;&#34;&#34;
    Validate that the field only contains an empty string
    &#34;&#34;&#34;
    if self.value == &#34;&#34;:
        return True

    return _EX.InvalidDataException(
        &#34;The reserved field needs to be an empty string&#34;
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.StringField" href="#sshkey_tools.fields.StringField">StringField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.StringField.decode" href="#sshkey_tools.fields.BytestringField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.StringField.encode" href="#sshkey_tools.fields.BytestringField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.StringField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.SerialField"><code class="flex name class">
<span>class <span class="ident">SerialField</span></span>
<span>(</span><span>value:int)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains the numeric serial number of the certificate,
maximum is (2**64)-1</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SerialField(Integer64Field):
    &#34;&#34;&#34;
    Contains the numeric serial number of the certificate,
    maximum is (2**64)-1
    &#34;&#34;&#34;

    def __init__(self, value: int):
        super().__init__(value=value, name=&#34;serial&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.Integer64Field" href="#sshkey_tools.fields.Integer64Field">Integer64Field</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.Integer64Field" href="#sshkey_tools.fields.Integer64Field">Integer64Field</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.Integer64Field.decode" href="#sshkey_tools.fields.Integer64Field.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.Integer64Field.encode" href="#sshkey_tools.fields.Integer64Field.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.Integer64Field.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.Integer64Field.validate" href="#sshkey_tools.fields.Integer64Field.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.SignatureField"><code class="flex name class">
<span>class <span class="ident">SignatureField</span></span>
<span>(</span><span>private_key:<a title="sshkey_tools.keys.PrivateKey" href="keys.html#sshkey_tools.keys.PrivateKey">PrivateKey</a>=None, signature:bytes=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and contains the signature of the certificate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SignatureField(CertificateField):
    &#34;&#34;&#34;
    Creates and contains the signature of the certificate
    &#34;&#34;&#34;

    # pylint: disable=super-init-not-called
    def __init__(self, private_key: PrivateKey = None, signature: bytes = None):
        self.name = &#34;signature&#34;
        self.private_key = private_key
        self.is_signed = False
        self.value = signature

    @staticmethod
    def from_object(private_key: PrivateKey):
        &#34;&#34;&#34;
        Load a private key from a PrivateKey object


        Args:
            private_key (PrivateKey): Private key to use for signing

        Raises:
            _EX.InvalidKeyException: Invalid private key

        Returns:
            SignatureField: SignatureField child class
        &#34;&#34;&#34;
        try:
            return globals()[CA_SIGNATURE_MAP[private_key.__class__]](
                private_key=private_key
            )
        except KeyError:
            raise _EX.InvalidKeyException(
                &#34;The private key provided is invalid or not supported&#34;
            ) from KeyError

    @staticmethod
    def from_decode(data: bytes) -&gt; Tuple[&#34;SignatureField&#34;, bytes]:
        &#34;&#34;&#34;
        Generates a SignatureField child class from the encoded signature

        Args:
            data (bytes): The bytestring containing the encoded signature

        Raises:
            _EX.InvalidDataException: Invalid data

        Returns:
            SignatureField: child of SignatureField
        &#34;&#34;&#34;
        signature, _ = BytestringField.decode(data)
        signature_type = BytestringField.decode(signature)[0]

        for key, value in SIGNATURE_TYPE_MAP.items():
            if key in signature_type:
                return globals()[value].from_decode(data)

        raise _EX.InvalidDataException(&#34;No matching signature type found&#34;)

    def can_sign(self):
        &#34;&#34;&#34;
        Determines if a signature can be generated from
        this private key
        &#34;&#34;&#34;
        return self.private_key is not None

    def sign(self, data: bytes) -&gt; None:
        &#34;&#34;&#34;
        Placeholder signing function
        &#34;&#34;&#34;

    def __bytes__(self) -&gt; None:
        return self.encode(self.value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.DSASignatureField" href="#sshkey_tools.fields.DSASignatureField">DSASignatureField</a></li>
<li><a title="sshkey_tools.fields.ECDSASignatureField" href="#sshkey_tools.fields.ECDSASignatureField">ECDSASignatureField</a></li>
<li><a title="sshkey_tools.fields.ED25519SignatureField" href="#sshkey_tools.fields.ED25519SignatureField">ED25519SignatureField</a></li>
<li><a title="sshkey_tools.fields.RSASignatureField" href="#sshkey_tools.fields.RSASignatureField">RSASignatureField</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sshkey_tools.fields.SignatureField.from_decode"><code class="name flex">
<span>def <span class="ident">from_decode</span></span>(<span>data:bytes) >Tuple[<a title="sshkey_tools.fields.SignatureField" href="#sshkey_tools.fields.SignatureField">SignatureField</a>,bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a SignatureField child class from the encoded signature</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The bytestring containing the encoded signature</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>_EX.InvalidDataException</code></dt>
<dd>Invalid data</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sshkey_tools.fields.SignatureField" href="#sshkey_tools.fields.SignatureField">SignatureField</a></code></dt>
<dd>child of SignatureField</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_decode(data: bytes) -&gt; Tuple[&#34;SignatureField&#34;, bytes]:
    &#34;&#34;&#34;
    Generates a SignatureField child class from the encoded signature

    Args:
        data (bytes): The bytestring containing the encoded signature

    Raises:
        _EX.InvalidDataException: Invalid data

    Returns:
        SignatureField: child of SignatureField
    &#34;&#34;&#34;
    signature, _ = BytestringField.decode(data)
    signature_type = BytestringField.decode(signature)[0]

    for key, value in SIGNATURE_TYPE_MAP.items():
        if key in signature_type:
            return globals()[value].from_decode(data)

    raise _EX.InvalidDataException(&#34;No matching signature type found&#34;)</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.SignatureField.from_object"><code class="name flex">
<span>def <span class="ident">from_object</span></span>(<span>private_key:<a title="sshkey_tools.keys.PrivateKey" href="keys.html#sshkey_tools.keys.PrivateKey">PrivateKey</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a private key from a PrivateKey object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>private_key</code></strong> :&ensp;<code>PrivateKey</code></dt>
<dd>Private key to use for signing</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>_EX.InvalidKeyException</code></dt>
<dd>Invalid private key</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sshkey_tools.fields.SignatureField" href="#sshkey_tools.fields.SignatureField">SignatureField</a></code></dt>
<dd>SignatureField child class</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_object(private_key: PrivateKey):
    &#34;&#34;&#34;
    Load a private key from a PrivateKey object


    Args:
        private_key (PrivateKey): Private key to use for signing

    Raises:
        _EX.InvalidKeyException: Invalid private key

    Returns:
        SignatureField: SignatureField child class
    &#34;&#34;&#34;
    try:
        return globals()[CA_SIGNATURE_MAP[private_key.__class__]](
            private_key=private_key
        )
    except KeyError:
        raise _EX.InvalidKeyException(
            &#34;The private key provided is invalid or not supported&#34;
        ) from KeyError</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sshkey_tools.fields.SignatureField.can_sign"><code class="name flex">
<span>def <span class="ident">can_sign</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines if a signature can be generated from
this private key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def can_sign(self):
    &#34;&#34;&#34;
    Determines if a signature can be generated from
    this private key
    &#34;&#34;&#34;
    return self.private_key is not None</code></pre>
</details>
</dd>
<dt id="sshkey_tools.fields.SignatureField.sign"><code class="name flex">
<span>def <span class="ident">sign</span></span>(<span>self, data:bytes) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Placeholder signing function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sign(self, data: bytes) -&gt; None:
    &#34;&#34;&#34;
    Placeholder signing function
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.CertificateField.decode" href="#sshkey_tools.fields.CertificateField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.encode" href="#sshkey_tools.fields.CertificateField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.StringField"><code class="flex name class">
<span>class <span class="ident">StringField</span></span>
<span>(</span><span>value, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Field representing a string value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StringField(BytestringField):
    &#34;&#34;&#34;
    Field representing a string value
    &#34;&#34;&#34;

    @staticmethod
    def encode(value: str, encoding: str = &#34;utf-8&#34;):
        &#34;&#34;&#34;
        Encodes a string or bytestring into a packed byte string

        Args:
            value (Union[str, bytes]): The string/bytestring to encode
            encoding (str): The encoding to user for the string

        Returns:
            bytes: Packed byte string containing the source data
        &#34;&#34;&#34;
        if not isinstance(value, str):
            raise _EX.InvalidFieldDataException(
                f&#34;Expected str, got {value.__class__.__name__}&#34;
            )
        return BytestringField.encode(value.encode(encoding))

    @staticmethod
    def decode(data: bytes, encoding: str = &#34;utf-8&#34;) -&gt; Tuple[str, bytes]:
        &#34;&#34;&#34;
        Unpacks the next string from a packed byte string

        Args:
            data (bytes): The packed byte string to unpack

        Returns:
            tuple(bytes, bytes):  The next block of bytes from the packed byte
                                  string and remainder of the data
        &#34;&#34;&#34;
        value, data = BytestringField.decode(data)

        return value.decode(encoding), data

    def validate(self) -&gt; Union[bool, Exception]:
        &#34;&#34;&#34;
        Validate the field data
        &#34;&#34;&#34;
        if not isinstance(self.value, str):
            return _EX.InvalidFieldDataException(
                f&#34;Passed value type ({type(self.value)}) is not a string&#34;
            )

        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.BytestringField" href="#sshkey_tools.fields.BytestringField">BytestringField</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.KeyIDField" href="#sshkey_tools.fields.KeyIDField">KeyIDField</a></li>
<li><a title="sshkey_tools.fields.NonceField" href="#sshkey_tools.fields.NonceField">NonceField</a></li>
<li><a title="sshkey_tools.fields.PubkeyTypeField" href="#sshkey_tools.fields.PubkeyTypeField">PubkeyTypeField</a></li>
<li><a title="sshkey_tools.fields.ReservedField" href="#sshkey_tools.fields.ReservedField">ReservedField</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.BytestringField" href="#sshkey_tools.fields.BytestringField">BytestringField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.BytestringField.decode" href="#sshkey_tools.fields.BytestringField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.BytestringField.encode" href="#sshkey_tools.fields.BytestringField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.BytestringField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.BytestringField.validate" href="#sshkey_tools.fields.BytestringField.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.ValidityEndField"><code class="flex name class">
<span>class <span class="ident">ValidityEndField</span></span>
<span>(</span><span>value:datetime.datetime)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains the end of the validity period for the certificate,
represented by a datetime object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ValidityEndField(DateTimeField):
    &#34;&#34;&#34;
    Contains the end of the validity period for the certificate,
    represented by a datetime object
    &#34;&#34;&#34;

    def __init__(self, value: datetime):
        super().__init__(value=value, name=&#34;valid_before&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.DateTimeField" href="#sshkey_tools.fields.DateTimeField">DateTimeField</a></li>
<li><a title="sshkey_tools.fields.Integer64Field" href="#sshkey_tools.fields.Integer64Field">Integer64Field</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.DateTimeField" href="#sshkey_tools.fields.DateTimeField">DateTimeField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.DateTimeField.decode" href="#sshkey_tools.fields.DateTimeField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.DateTimeField.encode" href="#sshkey_tools.fields.DateTimeField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.DateTimeField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.DateTimeField.validate" href="#sshkey_tools.fields.Integer64Field.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sshkey_tools.fields.ValidityStartField"><code class="flex name class">
<span>class <span class="ident">ValidityStartField</span></span>
<span>(</span><span>value:datetime.datetime)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains the start of the validity period for the certificate,
represented by a datetime object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ValidityStartField(DateTimeField):
    &#34;&#34;&#34;
    Contains the start of the validity period for the certificate,
    represented by a datetime object
    &#34;&#34;&#34;

    def __init__(self, value: datetime):
        super().__init__(value=value, name=&#34;valid_after&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sshkey_tools.fields.DateTimeField" href="#sshkey_tools.fields.DateTimeField">DateTimeField</a></li>
<li><a title="sshkey_tools.fields.Integer64Field" href="#sshkey_tools.fields.Integer64Field">Integer64Field</a></li>
<li><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sshkey_tools.fields.DateTimeField" href="#sshkey_tools.fields.DateTimeField">DateTimeField</a></b></code>:
<ul class="hlist">
<li><code><a title="sshkey_tools.fields.DateTimeField.decode" href="#sshkey_tools.fields.DateTimeField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.DateTimeField.encode" href="#sshkey_tools.fields.DateTimeField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.DateTimeField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.DateTimeField.validate" href="#sshkey_tools.fields.Integer64Field.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sshkey_tools" href="index.html">sshkey_tools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sshkey_tools.fields.decode_dss_signature" href="#sshkey_tools.fields.decode_dss_signature">decode_dss_signature</a></code></li>
<li><code><a title="sshkey_tools.fields.encode_dss_signature" href="#sshkey_tools.fields.encode_dss_signature">encode_dss_signature</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sshkey_tools.fields.BooleanField" href="#sshkey_tools.fields.BooleanField">BooleanField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.BooleanField.decode" href="#sshkey_tools.fields.BooleanField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.BooleanField.encode" href="#sshkey_tools.fields.BooleanField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.BooleanField.validate" href="#sshkey_tools.fields.BooleanField.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.BytestringField" href="#sshkey_tools.fields.BytestringField">BytestringField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.BytestringField.decode" href="#sshkey_tools.fields.BytestringField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.BytestringField.encode" href="#sshkey_tools.fields.BytestringField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.BytestringField.validate" href="#sshkey_tools.fields.BytestringField.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.CAPublicKeyField" href="#sshkey_tools.fields.CAPublicKeyField">CAPublicKeyField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.CAPublicKeyField.decode" href="#sshkey_tools.fields.CAPublicKeyField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.CAPublicKeyField.from_object" href="#sshkey_tools.fields.CAPublicKeyField.from_object">from_object</a></code></li>
<li><code><a title="sshkey_tools.fields.CAPublicKeyField.validate" href="#sshkey_tools.fields.CAPublicKeyField.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.CERT_TYPE" href="#sshkey_tools.fields.CERT_TYPE">CERT_TYPE</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.CERT_TYPE.HOST" href="#sshkey_tools.fields.CERT_TYPE.HOST">HOST</a></code></li>
<li><code><a title="sshkey_tools.fields.CERT_TYPE.USER" href="#sshkey_tools.fields.CERT_TYPE.USER">USER</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.CertificateField" href="#sshkey_tools.fields.CertificateField">CertificateField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.CertificateField.decode" href="#sshkey_tools.fields.CertificateField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.encode" href="#sshkey_tools.fields.CertificateField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.from_decode" href="#sshkey_tools.fields.CertificateField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.is_set" href="#sshkey_tools.fields.CertificateField.is_set">is_set</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateField.validate" href="#sshkey_tools.fields.CertificateField.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.CertificateTypeField" href="#sshkey_tools.fields.CertificateTypeField">CertificateTypeField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.CertificateTypeField.encode" href="#sshkey_tools.fields.CertificateTypeField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.CertificateTypeField.validate" href="#sshkey_tools.fields.CertificateTypeField.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.CriticalOptionsField" href="#sshkey_tools.fields.CriticalOptionsField">CriticalOptionsField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.CriticalOptionsField.validate" href="#sshkey_tools.fields.CriticalOptionsField.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.DSAPubkeyField" href="#sshkey_tools.fields.DSAPubkeyField">DSAPubkeyField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.DSAPubkeyField.decode" href="#sshkey_tools.fields.DSAPubkeyField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.DSAPubkeyField.validate" href="#sshkey_tools.fields.DSAPubkeyField.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.DSASignatureField" href="#sshkey_tools.fields.DSASignatureField">DSASignatureField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.DSASignatureField.decode" href="#sshkey_tools.fields.DSASignatureField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.DSASignatureField.encode" href="#sshkey_tools.fields.DSASignatureField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.DSASignatureField.from_decode" href="#sshkey_tools.fields.DSASignatureField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.DSASignatureField.sign" href="#sshkey_tools.fields.DSASignatureField.sign">sign</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.DateTimeField" href="#sshkey_tools.fields.DateTimeField">DateTimeField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.DateTimeField.decode" href="#sshkey_tools.fields.DateTimeField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.DateTimeField.encode" href="#sshkey_tools.fields.DateTimeField.encode">encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.ECDSAPubkeyField" href="#sshkey_tools.fields.ECDSAPubkeyField">ECDSAPubkeyField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.ECDSAPubkeyField.decode" href="#sshkey_tools.fields.ECDSAPubkeyField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.ECDSAPubkeyField.validate" href="#sshkey_tools.fields.ECDSAPubkeyField.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.ECDSASignatureField" href="#sshkey_tools.fields.ECDSASignatureField">ECDSASignatureField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.ECDSASignatureField.decode" href="#sshkey_tools.fields.ECDSASignatureField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.ECDSASignatureField.encode" href="#sshkey_tools.fields.ECDSASignatureField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.ECDSASignatureField.from_decode" href="#sshkey_tools.fields.ECDSASignatureField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.ECDSASignatureField.sign" href="#sshkey_tools.fields.ECDSASignatureField.sign">sign</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.ED25519PubkeyField" href="#sshkey_tools.fields.ED25519PubkeyField">ED25519PubkeyField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.ED25519PubkeyField.decode" href="#sshkey_tools.fields.ED25519PubkeyField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.ED25519PubkeyField.validate" href="#sshkey_tools.fields.ED25519PubkeyField.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.ED25519SignatureField" href="#sshkey_tools.fields.ED25519SignatureField">ED25519SignatureField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.ED25519SignatureField.decode" href="#sshkey_tools.fields.ED25519SignatureField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.ED25519SignatureField.encode" href="#sshkey_tools.fields.ED25519SignatureField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.ED25519SignatureField.from_decode" href="#sshkey_tools.fields.ED25519SignatureField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.ED25519SignatureField.sign" href="#sshkey_tools.fields.ED25519SignatureField.sign">sign</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.ExtensionsField" href="#sshkey_tools.fields.ExtensionsField">ExtensionsField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.ExtensionsField.validate" href="#sshkey_tools.fields.ExtensionsField.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.Integer32Field" href="#sshkey_tools.fields.Integer32Field">Integer32Field</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.Integer32Field.decode" href="#sshkey_tools.fields.Integer32Field.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.Integer32Field.encode" href="#sshkey_tools.fields.Integer32Field.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.Integer32Field.validate" href="#sshkey_tools.fields.Integer32Field.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.Integer64Field" href="#sshkey_tools.fields.Integer64Field">Integer64Field</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.Integer64Field.decode" href="#sshkey_tools.fields.Integer64Field.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.Integer64Field.encode" href="#sshkey_tools.fields.Integer64Field.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.Integer64Field.validate" href="#sshkey_tools.fields.Integer64Field.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.KeyIDField" href="#sshkey_tools.fields.KeyIDField">KeyIDField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.KeyIDField.validate" href="#sshkey_tools.fields.KeyIDField.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.KeyValueField" href="#sshkey_tools.fields.KeyValueField">KeyValueField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.KeyValueField.decode" href="#sshkey_tools.fields.KeyValueField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.KeyValueField.encode" href="#sshkey_tools.fields.KeyValueField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.KeyValueField.validate" href="#sshkey_tools.fields.KeyValueField.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.ListField" href="#sshkey_tools.fields.ListField">ListField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.ListField.decode" href="#sshkey_tools.fields.ListField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.ListField.encode" href="#sshkey_tools.fields.ListField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.ListField.validate" href="#sshkey_tools.fields.ListField.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.MpIntegerField" href="#sshkey_tools.fields.MpIntegerField">MpIntegerField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.MpIntegerField.decode" href="#sshkey_tools.fields.MpIntegerField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.MpIntegerField.encode" href="#sshkey_tools.fields.MpIntegerField.encode">encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.NonceField" href="#sshkey_tools.fields.NonceField">NonceField</a></code></h4>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.PrincipalsField" href="#sshkey_tools.fields.PrincipalsField">PrincipalsField</a></code></h4>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.PubkeyTypeField" href="#sshkey_tools.fields.PubkeyTypeField">PubkeyTypeField</a></code></h4>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.PublicKeyField" href="#sshkey_tools.fields.PublicKeyField">PublicKeyField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.PublicKeyField.encode" href="#sshkey_tools.fields.PublicKeyField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.PublicKeyField.from_object" href="#sshkey_tools.fields.PublicKeyField.from_object">from_object</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.RSAPubkeyField" href="#sshkey_tools.fields.RSAPubkeyField">RSAPubkeyField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.RSAPubkeyField.decode" href="#sshkey_tools.fields.RSAPubkeyField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.RSAPubkeyField.validate" href="#sshkey_tools.fields.RSAPubkeyField.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.RSASignatureField" href="#sshkey_tools.fields.RSASignatureField">RSASignatureField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.RSASignatureField.decode" href="#sshkey_tools.fields.RSASignatureField.decode">decode</a></code></li>
<li><code><a title="sshkey_tools.fields.RSASignatureField.encode" href="#sshkey_tools.fields.RSASignatureField.encode">encode</a></code></li>
<li><code><a title="sshkey_tools.fields.RSASignatureField.from_decode" href="#sshkey_tools.fields.RSASignatureField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.RSASignatureField.sign" href="#sshkey_tools.fields.RSASignatureField.sign">sign</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.ReservedField" href="#sshkey_tools.fields.ReservedField">ReservedField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.ReservedField.validate" href="#sshkey_tools.fields.ReservedField.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.SerialField" href="#sshkey_tools.fields.SerialField">SerialField</a></code></h4>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.SignatureField" href="#sshkey_tools.fields.SignatureField">SignatureField</a></code></h4>
<ul class="">
<li><code><a title="sshkey_tools.fields.SignatureField.can_sign" href="#sshkey_tools.fields.SignatureField.can_sign">can_sign</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.from_decode" href="#sshkey_tools.fields.SignatureField.from_decode">from_decode</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.from_object" href="#sshkey_tools.fields.SignatureField.from_object">from_object</a></code></li>
<li><code><a title="sshkey_tools.fields.SignatureField.sign" href="#sshkey_tools.fields.SignatureField.sign">sign</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.StringField" href="#sshkey_tools.fields.StringField">StringField</a></code></h4>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.ValidityEndField" href="#sshkey_tools.fields.ValidityEndField">ValidityEndField</a></code></h4>
</li>
<li>
<h4><code><a title="sshkey_tools.fields.ValidityStartField" href="#sshkey_tools.fields.ValidityStartField">ValidityStartField</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>