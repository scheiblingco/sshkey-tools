<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sshkey_tools API documentation</title>
<meta name="description" content="sshkey-tools …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>sshkey_tools</code></h1>
</header>
<section id="section-intro">
<h1 id="sshkey-tools">sshkey-tools</h1>
<p>Python package for managing OpenSSH keypairs and certificates (<a href="https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys">protocol.CERTKEYS</a>). Supported functionality includes:</p>
<h1 id="features">Features</h1>
<h3 id="ssh-keys">SSH Keys</h3>
<ul>
<li>Supports RSA, DSA, ECDSA and ED25519 keys</li>
<li>Import existing keys from file, string, byte data or <a href="https://github.com/pyca/cryptography">pyca/cryptography</a> class</li>
<li>Generate new keys</li>
<li>Get public key from private keys</li>
<li>Sign bytestrings with private keys</li>
<li>Export to file, string or bytes</li>
<li>Generate fingerprint</li>
</ul>
<h3 id="openssh-certificates">OpenSSH Certificates</h3>
<ul>
<li>Supports RSA, DSA, ECDSA and ED25519 certificates</li>
<li>Import existing certificates from file, string or bytes</li>
<li>Verify certificate signature against internal or separate public key</li>
<li>Create new certificates from CA private key and subject public key</li>
<li>Create new certificates using old certificate as template</li>
<li>Sign certificates</li>
<li>Export certificates to file, string or bytes</li>
</ul>
<h1 id="roadmap">Roadmap</h1>
<p>See issues for planned features and fixes</p>
<h1 id="installation">Installation</h1>
<h2 id="with-pip">With pip</h2>
<pre><code class="language-bash">pip3 install sshkey-tools
# or
pip3 install -e git+https://github.com/scheiblingco/sshkey-tools.git
</code></pre>
<h2 id="from-source">From source</h2>
<pre><code class="language-bash">git clone https://github.com/scheiblingco/sshkey-tools
cd sshkey-tools
pip3 install ./
</code></pre>
<h1 id="documentation">Documentation</h1>
<p>You can find the full documentation at <a href="https://scheiblingco.github.io/sshkey-tools/">scheiblingco.github.io/sshkey-tools/</a></p>
<h2 id="ssh-keypairs-generating-loading-exporting">SSH Keypairs (generating, loading, exporting)</h2>
<pre><code class="language-python"># Import the certificate classes
from sshkey_tools.keys import (
    RsaPrivateKey,
    DsaPrivateKey,
    EcdsaPrivateKey,
    Ed25519PrivateKey,
    EcdsaCurves
)
#
## Generating keys
#

# For all keys except ED25519, the key size/curve can be manually specified
# Generate RSA (default is 4096 bits)
rsa_priv = RsaPrivateKey.generate()
rsa_priv = RsaPrivateKey.generate(2048)

# Generate DSA keys (since SSH only supports 1024-bit keys, this is the default)
dsa_priv = DsaPrivateKey.generate()

# Generate ECDSA keys (The default curve is P521)
ecdsa_priv = EcdsaPrivateKey.generate()
ecdsa_priv = EcdsaPrivateKey.generate(EcdsaCurves.P256)

# Generate ED25519 keys (fixed key size)
ed25519_priv = Ed25519PrivateKey.generate()

#
## Loading keys
#

# Keys can be loaded either via the specific class:
rsa_priv = RsaPrivateKey.from_file(&quot;/path/to/key&quot;, &quot;OptionalSecurePassword&quot;)

# or via the general class, in case the type is not known in advance
rsa_priv = PrivateKey.from_file(&quot;/path/to/key&quot;, &quot;OptionalSecurePassword&quot;)

# The import functions are .from_file(), .from_string() and .from_class() and are valid for both PublicKey and PrivateKey-classes
rsa_priv = PrivateKey.from_string(&quot;-----BEGIN OPENSSH PRIVATE KEY...........END -----&quot;, &quot;OptionalSecurePassword&quot;)
rsa_priv = PrivateKey.from_class(pyca_cryptography_class)

# The different keys can also be loaded from their numbers, e.g. RSA Pubkey:
rsa_priv = PublicKey.from_numbers(65537, 123123123....1)

#
## Key functionality
#

# The public key for any loaded or generated private key is available in the .public_key attribute
ed25519_pub = ed25519_priv.public_key

# The private keys can be exported using to_bytes, to_string or to_file
rsa_priv.to_bytes(&quot;OptionalSecurePassword&quot;)
rsa_priv.to_string(&quot;OptionalSecurePassword&quot;, &quot;utf-8&quot;)
rsa_priv.to_file(&quot;/path/to/file&quot;, &quot;OptionalSecurePassword&quot;, &quot;utf-8&quot;)

# The public keys also have .to_string() and .to_file(), but .to_bytes() is divided into .serialize() and .raw_bytes()
# The comment can be set before export by changing the public_key.comment-attribute
rsa_priv.public_key.comment = &quot;Comment@Comment&quot;

# This will return the serialized public key as found in an OpenSSH keyfile
rsa_priv.public_key.serialize()
b&quot;ssh-rsa AAAA......... Comment@Comment&quot;

# This will return the raw bytes of the key (base64-decoded middle portion)
rsa_priv.public_key.raw_bytes()
b&quot;\0xc\0a\........&quot;
</code></pre>
<h2 id="ssh-key-signatures">SSH Key Signatures</h2>
<p>The loaded private key objects can be used to sign bytestrings, and the public keys can be used to verify signatures on those</p>
<pre><code class="language-python">from sshkey_tools.keys import RsaPrivateKey, RsaPublicKey

signable_data = b'This is a message that will be signed'

privkey = RsaPrivateKey.generate()
pubkey = RsaPrivateKey.public_key

# Sign the data
signature = privkey.sign(signable_data)

# Verify the signature (Throws exception if invalid)
pubkey.verify(signable_data, signature)
</code></pre>
<h2 id="openssh-certificates_1">OpenSSH Certificates</h2>
<h3 id="introduction">Introduction</h3>
<p>Certificates are a way to handle access management/PAM for OpenSSH with the ability to dynamically grant access during a specific time, to specific servers and/or with specific attributes. There are a couple of upsides to using certificates instead of public/private keys, mainly: </p>
<ul>
<li>Additional Security: Certificate authentication for OpenSSH is built as an extension of public key authentication, enabling additional features on top of key-based access control.</li>
<li>Short-term access: The user has to request a certificate for their keypair, which together with the private key grants access to the server. Without the certificate the user can't connect to the server - giving you control over how, when and from where the user can connect.</li>
<li>Hostkey Verification: Certificiates can be issued for the OpenSSH Server, adding the CA public key to the clients enables you to establish servers as trusted without the hostkey warning.</li>
<li>RBAC: Control which servers or users (principals) a keypair has access to, and specify the required principals for access to certain functionality on the server side.</li>
<li>Logging: Key ID and Serial fields for tracking of issued certificates</li>
<li>CRL: Revoke certificates prematurely if they are compromised</li>
</ul>
<h3 id="structure">Structure</h3>
<p>The original OpenSSH certificate format is a block of parameters, encoded and packed to a bytestring. In this package, the fields have been divided into three parts. For a more detailed information about the format, see <a href="https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys">PROTOCOL.certkeys</a>.</p>
<h3 id="certificate-header">Certificate Header</h3>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>Type(Length)</th>
<th>Key</th>
<th>Example Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Public Key/Certificate type</td>
<td>string(fixed)</td>
<td>pubkey_type</td>
<td>ssh-rsa-sha2-512-cert-v01@openssh.com</td>
<td>The private key (and certificate) type, derived from the public key for which the certificate is created (Automatically set upon creation)</td>
</tr>
<tr>
<td>Subject public key</td>
<td>bytestring(variable)</td>
<td>public_key</td>
<td>\x00\x00\x00..........</td>
<td>The public key for which the certificate is created (Automatically set upon creation)</td>
</tr>
<tr>
<td>Nonce</td>
<td>string</td>
<td>nonce(variable, typically 16 or 32 bytes)</td>
<td>abcdefghijklmnopqrstuvwxyz</td>
<td>A random string included to make attacks that depend on inducing collisions in the signature hash infeasible. (Default is automatically set, can be changed with Certificate.header.nonce = "abcdefg&hellip;"</td>
</tr>
</tbody>
</table>
<h3 id="certificate-fields">Certificate Fields</h3>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>Type(Length)</th>
<th>Key</th>
<th>Example Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Serial</td>
<td>Integer(64-bit)</td>
<td>serial</td>
<td>1234567890</td>
<td>An optional certificate serial number set by the CA to provide an abbreviated way to refer to certificates from that CA. If a CA does not wish to number its certificates, it must set this field to zero.</td>
</tr>
<tr>
<td>Certificate type</td>
<td>Integer(1 or 2)</td>
<td>cert_type</td>
<td>1</td>
<td>The type of the certificate, 1 for user certificates, 2 for host certificates</td>
</tr>
<tr>
<td>Key ID</td>
<td>string(variable)</td>
<td>key_id</td>
<td>someuser@somehost</td>
<td>Free-form text field that is filled in by the CA at the time of signing; the intention is that the contents of this field are used to identify the identity principal in log messages.</td>
</tr>
<tr>
<td>Valid Principals</td>
<td>List(string(variable))</td>
<td>principals</td>
<td>['some-user', 'some-group', production-webservers']</td>
<td>These principals list the names for which this certificate is valid hostnames for SSH_CERT_TYPE_HOST certificates and usernames for
SH_CERT_TYPE_USER certificates. As a special case, a zero-length "valid principals" field means the certificate is valid for any principal of the specified type.</td>
</tr>
<tr>
<td>Valid After</td>
<td>Timestamp</td>
<td>valid_after</td>
<td>datetime.now()</td>
<td>Timestamp for the start of the validity period for the certificate</td>
</tr>
<tr>
<td>Valid Before</td>
<td>Timestamp</td>
<td>valid_before</td>
<td>datetime.now()+timedelta(hours=8) or 1658322031</td>
<td>Timestamp for the end of the validity period for the certificate. Needs to be larger than valid_after, can be a string (ex. 2d, 2w, 1h4m, 99d) or forever (MAX_INT64)</td>
</tr>
<tr>
<td>Critical Options</td>
<td>Dict(string, string)</td>
<td>critical_options</td>
<td>[]</td>
<td>Zero or more of the available critical options (see below)</td>
</tr>
<tr>
<td>Extensions</td>
<td>Dict(string, string)/List/Tuple/Set</td>
<td>extensions</td>
<td>[]</td>
<td>Zero or more of the available extensions (see below)</td>
</tr>
</tbody>
</table>
<h4 id="critical-options">Critical Options</h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Format</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>force-command</td>
<td>string</td>
<td>Specifies a command that is executed (replacing any the user specified on the ssh command-line) whenever this key is used for authentication.</td>
</tr>
<tr>
<td>source-address</td>
<td>string</td>
<td>Comma-separated list of source addresses from which this certificate is accepted for authentication. Addresses are specified in CIDR format (nn.nn.nn.nn/nn or hhhh::hhhh/nn). If this option is not present, then certificates may be presented from any source address.</td>
</tr>
<tr>
<td>verify-required</td>
<td>empty</td>
<td>Flag indicating that signatures made with this certificate must assert FIDO user verification (e.g. PIN or biometric). This option only makes sense for the U2F/FIDO security key types that support this feature in their signature formats.</td>
</tr>
</tbody>
</table>
<h4 id="extensions">Extensions</h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Format</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>no-touch-required</td>
<td>empty</td>
<td>Flag indicating that signatures made with this certificate need not assert FIDO user presence. This option only makes sense for the U2F/FIDO security key types that support this feature in their signature formats.</td>
</tr>
<tr>
<td>permit-X11-forwarding</td>
<td>empty</td>
<td>Flag indicating that X11 forwarding should be permitted. X11 forwarding will be refused if this option is absent.</td>
</tr>
<tr>
<td>permit-agent-forwarding</td>
<td>empty</td>
<td>Flag indicating that agent forwarding should be allowed. Agent forwarding must not be permitted unless this option is present.</td>
</tr>
<tr>
<td>permit-port-forwarding</td>
<td>empty</td>
<td>Flag indicating that port-forwarding should be allowed. If this option is not present, then no port forwarding will be allowed.</td>
</tr>
<tr>
<td>permit-pty</td>
<td>empty</td>
<td>Flag indicating that PTY allocation should be permitted. In the absence of this option PTY allocation will be disabled.</td>
</tr>
<tr>
<td>permit-user-rc</td>
<td>empty</td>
<td>Flag indicating that execution of ~/.ssh/rc should be permitted. Execution of this script will not be permitted if this option is not present.</td>
</tr>
</tbody>
</table>
<h3 id="certificate-body">Certificate Body</h3>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>Type(Length)</th>
<th>Key</th>
<th>Example Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Reserved</td>
<td>string(0)</td>
<td>reserved</td>
<td>""</td>
<td>Reserved for future use, must be empty (automatically set upon signing)</td>
</tr>
<tr>
<td>CA Public Key</td>
<td>bytestring(variable)</td>
<td>ca_pubkey</td>
<td>\x00\x00\x00..........</td>
<td>The public key of the CA that issued this certificate (automatically set upon signing)</td>
</tr>
<tr>
<td>Signature</td>
<td>bytestring(variable)</td>
<td>signature</td>
<td>\x00\x00\x00..........</td>
<td>The signature of the certificate, created by the CA (automatically set upon signing)</td>
</tr>
</tbody>
</table>
<h2 id="creating-signing-and-verifying-certificates">Creating, signing and verifying certificates</h2>
<pre><code class="language-python"># Every certificate needs two parts, the subject (user or host) public key and the CA Private key
from sshkey_tools.cert import SSHCertificate, CertificateFields, Ed25519Certificate
from sshkey_tools.keys import Ed25519PrivateKey
from datetime import datetime, timedelta

subject_pubkey = Ed25519PrivateKey.generate().public_key
ca_privkey = Ed25519PrivateKey.generate()

# There are multiple ways to create a certificate, either by creating the certificate body field object first and then creating the certificate, or creating the certificate and setting the fields one by one

# Create certificate body fields
cert_fields = CertificateFields(
    serial=1234567890,
    cert_type=1,
    key_id=&quot;someuser@somehost&quot;,
    principals=[&quot;some-user&quot;, &quot;some-group&quot;, &quot;production-webservers&quot;],
    valid_after=datetime.now(),
    valid_before=datetime.now() + timedelta(hours=8),
    critical_options=[],
    extensions=[
        &quot;permit-pty&quot;,
        &quot;permit-X11-forwarding&quot;,
        &quot;permit-agent-forwarding&quot;,
    ],
)

# Create certificate from existing fields
certificate = SSHCertificate(
    subject_pubkey=subject_pubkey,
    ca_privkey=ca_privkey,
    fields=cert_fields,
)

# Start with a blank certificate by calling the general class
certificate = SSHCertificate.create(
    subject_pubkey=subject_pubkey,
    ca_privkey=ca_privkey
)

# You can also call the specialized classes directly, for the general class the .create-function needs to be used
certificate = Ed25519Certificate(
    subject_pubkey=subject_pubkey,
    ca_privkey=ca_privkey
)

# Manually set the fields
certificate.fields.serial = 1234567890
certificate.fields.cert_type = 1
certificate.fields.key_id = &quot;someuser@somehost&quot;
certificate.fields.principals = [&quot;some-user&quot;, &quot;some-group&quot;, &quot;production-webservers&quot;]
certificate.fields.valid_after = datetime.now()
certificate.fields.valid_before = datetime.now() + timedelta(hours=8)
certificate.fields.critical_options = []
certificate.fields.extensions = [
    &quot;allow-pty&quot;,
    &quot;permit-X11-forwarding&quot;,
    &quot;permit-agent-forwarding&quot;,
]

# Check if the certificate is ready to be signed
certificate.can_sign()

# Sign the certificate
certificate.sign()

# Verify the certificate against the included public key (insecure, but useful for testing)
certificate.verify()

# Verify the certificate against a public key that is not included in the certificate
certificate.verify(ca_privkey.public_key)

# Raise an exception if the certificate is invalid
certificate.verify(ca_privkey.public_key, True)

# Export the certificate to file/string
certificate.to_file('filename-cert.pub')
cert_str = certificate.to_string()

</code></pre>
<h2 id="loading-re-creating-and-verifying-existing-certificates">Loading, re-creating and verifying existing certificates</h2>
<pre><code class="language-python">from sshkey_tools.cert import SSHCertificate, CertificateFields, Ed25519Certificate
from sshkey_tools.keys import PublicKey, PrivateKey
from datetime import datetime, timedelta

# Load a certificate from file or string
# This will return the correct certificate type based on the contents of the certificate
certificate = SSHCertificate.from_file('filename-cert.pub')
certificate = SSHCertificate.from_string(cert_str)

type(certificate) # sshkey_tools.cert.Ed25519Certificate

# Verify the certificate signature against the included public key (insecure, but useful for testing)
certificate.verify()

# Verify the certificate signature against a public key
pubkey = PublicKey.from_file('filename-pubkey.pub')
certificate.verify(pubkey)

# Raise an exception if the certificate is invalid
certificate.verify(pubkey, True)

# Use the loaded certificate as a template to create a new one
new_ca = PrivateKey.from_file('filename-ca')
certificate.replace_ca(new_ca)
certificate.sign()

</code></pre>
<h2 id="changelog">Changelog</h2>
<h3 id="091">0.9.1</h3>
<ul>
<li>Updated documentation</li>
<li>Fix for bug where exception would occur when trying to export a key without a comment set</li>
</ul>
<h3 id="09">0.9</h3>
<ul>
<li>Adjustments to certificate field handling for easier usage/syntax autocompletion</li>
<li>Updated testing</li>
<li>Removed method for changing RSA hash method (now default SHA512)</li>
</ul>
<h3 id="082">0.8.2</h3>
<ul>
<li>Fixed bug where an RSA certificate would send the RSA alg to the sign() function of another key type</li>
</ul>
<h3 id="081">0.8.1</h3>
<ul>
<li>Changed versioning for out-of-github installation/packaging</li>
<li>Moved documentation to HTML (PDOC3)</li>
<li>Added verification of certificate signature</li>
<li>Added option to choose RSA hashing algorithm for signing</li>
<li>Removed test files</li>
<li>Added documentation deployment CD for GH pages</li>
</ul>
<h3 id="08">0.8</h3>
<ul>
<li>Initial public release</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
.. include:: ../../README.md
&#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="sshkey_tools.cert" href="cert.html">sshkey_tools.cert</a></code></dt>
<dd>
<div class="desc"><p>Contains classes for OpenSSH Certificates, generation, parsing and signing</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>_EX.SSHCertificateException</code></dt>
<dd>General error in certificate</dd>
</dl>
<p>…</p></div>
</dd>
<dt><code class="name"><a title="sshkey_tools.exceptions" href="exceptions.html">sshkey_tools.exceptions</a></code></dt>
<dd>
<div class="desc"><p>Exceptions thrown by sshkey_tools</p></div>
</dd>
<dt><code class="name"><a title="sshkey_tools.fields" href="fields.html">sshkey_tools.fields</a></code></dt>
<dd>
<div class="desc"><p>Field types for SSH Certificates</p></div>
</dd>
<dt><code class="name"><a title="sshkey_tools.keys" href="keys.html">sshkey_tools.keys</a></code></dt>
<dd>
<div class="desc"><p>Classes for handling SSH public/private keys</p></div>
</dd>
<dt><code class="name"><a title="sshkey_tools.utils" href="utils.html">sshkey_tools.utils</a></code></dt>
<dd>
<div class="desc"><p>Utilities for handling keys and certificates</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#sshkey-tools">sshkey-tools</a></li>
<li><a href="#features">Features</a><ul>
<li><a href="#ssh-keys">SSH Keys</a></li>
<li><a href="#openssh-certificates">OpenSSH Certificates</a></li>
</ul>
</li>
<li><a href="#roadmap">Roadmap</a></li>
<li><a href="#installation">Installation</a><ul>
<li><a href="#with-pip">With pip</a></li>
<li><a href="#from-source">From source</a></li>
</ul>
</li>
<li><a href="#documentation">Documentation</a><ul>
<li><a href="#ssh-keypairs-generating-loading-exporting">SSH Keypairs (generating, loading, exporting)</a></li>
<li><a href="#ssh-key-signatures">SSH Key Signatures</a></li>
<li><a href="#openssh-certificates_1">OpenSSH Certificates</a><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#structure">Structure</a></li>
<li><a href="#certificate-header">Certificate Header</a></li>
<li><a href="#certificate-fields">Certificate Fields</a><ul>
<li><a href="#critical-options">Critical Options</a></li>
<li><a href="#extensions">Extensions</a></li>
</ul>
</li>
<li><a href="#certificate-body">Certificate Body</a></li>
</ul>
</li>
<li><a href="#creating-signing-and-verifying-certificates">Creating, signing and verifying certificates</a></li>
<li><a href="#loading-re-creating-and-verifying-existing-certificates">Loading, re-creating and verifying existing certificates</a></li>
<li><a href="#changelog">Changelog</a><ul>
<li><a href="#091">0.9.1</a></li>
<li><a href="#09">0.9</a></li>
<li><a href="#082">0.8.2</a></li>
<li><a href="#081">0.8.1</a></li>
<li><a href="#08">0.8</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="sshkey_tools.cert" href="cert.html">sshkey_tools.cert</a></code></li>
<li><code><a title="sshkey_tools.exceptions" href="exceptions.html">sshkey_tools.exceptions</a></code></li>
<li><code><a title="sshkey_tools.fields" href="fields.html">sshkey_tools.fields</a></code></li>
<li><code><a title="sshkey_tools.keys" href="keys.html">sshkey_tools.keys</a></code></li>
<li><code><a title="sshkey_tools.utils" href="utils.html">sshkey_tools.utils</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>