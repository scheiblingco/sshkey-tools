<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sshkey_tools.utils API documentation</title>
<meta name="description" content="Utilities for handling keys and certificates" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sshkey_tools.utils</code></h1>
</header>
<section id="section-intro">
<p>Utilities for handling keys and certificates</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Utilities for handling keys and certificates
&#34;&#34;&#34;
import hashlib as hl
import sys
import datetime

from base64 import b64encode
from random import randint
from secrets import randbits
from typing import Dict, List, Union
from uuid import uuid4

from pytimeparse2 import parse as time_parse


NoneType = type(None)


def ensure_string(
    obj: Union[str, bytes, list, tuple, set, dict, NoneType],
    encoding: str = &#34;utf-8&#34;,
    required: bool = False,
) -&gt; Union[str, List[str], Dict[str, str], NoneType]:
    &#34;&#34;&#34;Ensure the provided value is or contains a string/strings

    Args:
        obj (_type_): The object to process
        encoding (str, optional): The encoding of the provided strings. Defaults to &#39;utf-8&#39;.

    Returns:
        Union[str, List[str], Dict[str, str]]: Returns a string, list of strings or
                                               dictionary with strings
    &#34;&#34;&#34;
    if (obj is None and not required) or isinstance(obj, str):
        return obj
    if isinstance(obj, bytes):
        return obj.decode(encoding)
    if isinstance(obj, (list, tuple, set)):
        return [ensure_string(o, encoding) for o in obj]
    if isinstance(obj, dict):
        return {
            ensure_string(k, encoding): ensure_string(v, encoding)
            for k, v in obj.items()
        }

    raise TypeError(
        f&#34;Expected one of (str, bytes, list, tuple, dict, set), got {type(obj).__name__}.&#34;
    )


def ensure_bytestring(
    obj: Union[str, bytes, list, tuple, set, dict, NoneType],
    encoding: str = &#34;utf-8&#34;,
    required: bool = None,
) -&gt; Union[str, List[str], Dict[str, str], NoneType]:
    &#34;&#34;&#34;Ensure the provided value is or contains a bytestring/bytestrings

    Args:
        obj (_type_): The object to process
        encoding (str, optional): The encoding of the provided bytestrings. Defaults to &#39;utf-8&#39;.

    Returns:
        Union[str, List[str], Dict[str, str]]: Returns a bytestring, list of bytestrings or
                                               dictionary with bytestrings
    &#34;&#34;&#34;
    if (obj is None and not required) or isinstance(obj, bytes):
        return obj
    if isinstance(obj, str):
        return obj.encode(encoding)
    if isinstance(obj, (list, tuple, set)):
        return [ensure_bytestring(o, encoding) for o in obj]
    if isinstance(obj, dict):
        return {
            ensure_bytestring(k, encoding): ensure_bytestring(v, encoding)
            for k, v in obj.items()
        }
    raise TypeError(
        f&#34;Expected one of (str, bytes, list, tuple, dict, set), got {type(obj).__name__}.&#34;
    )


def concat_to_string(*strs, encoding: str = &#34;utf-8&#34;) -&gt; str:
    &#34;&#34;&#34;Concatenates a list of strings or bytestrings to a single string.

    Args:
        encoding (str, optional): The encoding of the string/s. Defaults to &#39;utf-8&#39;.
        *strs (List[str, bytes]): The strings to concatenate

    Returns:
        str: Concatenated string
    &#34;&#34;&#34;
    return &#34;&#34;.join(st if st is not None else &#34;&#34; for st in ensure_string(strs, encoding))


def concat_to_bytestring(*strs, encoding: str = &#34;utf-8&#34;) -&gt; bytes:
    &#34;&#34;&#34;Concatenates a list of strings or bytestrings to a single bytestring.

    Args:
        encoding (str, optional): The encoding of the string/s. Defaults to &#39;utf-8&#39;.
        *strs (List[str, bytes]): The strings to concatenate

    Returns:
        bytes: Concatenated bytestring
    &#34;&#34;&#34;
    return b&#34;&#34;.join(
        st if st is not None else b&#34;&#34;
        for st in ensure_bytestring(strs, encoding=encoding)
    )


def random_keyid() -&gt; str:
    &#34;&#34;&#34;Generates a random Key ID

    Returns:
        str: Random keyid
    &#34;&#34;&#34;
    return str(uuid4())


def random_serial() -&gt; str:
    &#34;&#34;&#34;Generates a random serial number

    Returns:
        int: Random serial
    &#34;&#34;&#34;
    return randint(0, 2**64 - 1)


def long_to_bytes(
    source_int: int, force_length: int = None, byteorder: str = &#34;big&#34;
) -&gt; bytes:
    &#34;&#34;&#34;Converts a positive integer to a byte string conforming with the certificate format.
        Equivalent to paramiko.util.deflate_long()
    Args:
        source_int (int): Integer to convert
        force_length (int, optional): Pads the resulting bytestring if shorter. Defaults to None.
        byteorder (str, optional): Byte order. Defaults to &#39;big&#39;.

    Returns:
        str: Byte string representing the chosen long integer
    &#34;&#34;&#34;
    if source_int &lt; 0:
        raise ValueError(
            &#34;You can only convert positive long integers to bytes with this method&#34;
        )

    if not isinstance(source_int, int):
        raise TypeError(f&#34;Expected integer, got {type(source_int).__name__}.&#34;)

    length = (source_int.bit_length() // 8 + 1) if not force_length else force_length
    return source_int.to_bytes(length, byteorder)


def bytes_to_long(source_bytes: bytes, byteorder: str = &#34;big&#34;) -&gt; int:
    &#34;&#34;&#34;The opposite of long_to_bytes, converts a byte string to a long integer
       Equivalent to paramiko.util.inflate_long()
    Args:
        source_bytes (bytes): The byte string to convert
        byteorder (str, optional): Byte order. Defaults to &#39;big&#39;.

    Returns:
        int: Long integer resulting from decoding the byte string
    &#34;&#34;&#34;
    if not isinstance(source_bytes, bytes):
        raise TypeError(f&#34;Expected bytes, got {type(source_bytes).__name__}.&#34;)

    return int.from_bytes(source_bytes, byteorder)


def generate_secure_nonce(length: int = 128):
    &#34;&#34;&#34;Generates a secure random nonce of the specified length.
        Mainly important for ECDSA keys, but is used with all key/certificate types
        https://blog.trailofbits.com/2020/06/11/ecdsa-handle-with-care/
        https://datatracker.ietf.org/doc/html/rfc6979
    Args:
        length (int, optional): Length of the nonce. Defaults to 64.

    Returns:
        str: Nonce of the specified length
    &#34;&#34;&#34;
    return str(randbits(length))


def md5_fingerprint(data: bytes, prefix: bool = True) -&gt; str:
    &#34;&#34;&#34;
    Returns an MD5 fingerprint of the given data.

    Args:
        data (bytes): The data to fingerprint
        prefix (bool, optional): Whether to prefix the fingerprint with MD5:

    Returns:
        str: The fingerprint (OpenSSH style MD5:xx:xx:xx...)
    &#34;&#34;&#34;
    digest = hl.md5(data).hexdigest()
    return (&#34;MD5:&#34; if prefix else &#34;&#34;) + &#34;:&#34;.join(
        a + b for a, b in zip(digest[::2], digest[1::2])
    )


def sha256_fingerprint(data: bytes, prefix: bool = True) -&gt; str:
    &#34;&#34;&#34;
    Returns a SHA256 fingerprint of the given data.

    Args:
        data (bytes): The data to fingerprint
        prefix (bool, optional): Whether to prefix the fingerprint with SHA256:

    Returns:
        str: The fingerprint (OpenSSH style SHA256:xx:xx:xx...)
    &#34;&#34;&#34;
    digest = hl.sha256(data).digest()
    return (&#34;SHA256:&#34; if prefix else &#34;&#34;) + b64encode(digest).replace(b&#34;=&#34;, b&#34;&#34;).decode(
        &#34;utf-8&#34;
    )


def sha512_fingerprint(data: bytes, prefix: bool = True) -&gt; str:
    &#34;&#34;&#34;
    Returns a SHA512 fingerprint of the given data.

    Args:
        data (bytes): The data to fingerprint
        prefix (bool, optional): Whether to prefix the fingerprint with SHA512:

    Returns:
        str: The fingerprint (OpenSSH style SHA256:xx:xx:xx...)
    &#34;&#34;&#34;
    digest = hl.sha512(data).digest()
    return (&#34;SHA512:&#34; if prefix else &#34;&#34;) + b64encode(digest).replace(b&#34;=&#34;, b&#34;&#34;).decode(
        &#34;utf-8&#34;
    )


def nullsafe_getattr(obj, attr: str, default):
    &#34;&#34;&#34;
    Null-safe getattr, ensuring the result is not None.
    If the result is None, the default value is returned instead.

    Args:
        obj: The object
        attr: The attribute to get
        default: The default value
    &#34;&#34;&#34;
    att = getattr(obj, attr, default)
    if att is None:
        att = default
    
    return att

def join_dicts(*dicts) -&gt; dict:
    &#34;&#34;&#34;
    Joins two or more dictionaries together.
    In case of duplicate keys, the latest one wins.

    Returns:
        dict: Joined dictionary
    &#34;&#34;&#34;
    py_version = sys.version_info[0:2]
    return_dict = {}

    if py_version[0] == 3 and py_version[1] &gt; 9:
        for add_dict in dicts:
            return_dict = return_dict | add_dict

        return return_dict

    for add_dict in dicts:
        return_dict = {**return_dict, **add_dict}

    return return_dict


def str_to_time_delta(str_delta: str) -&gt; datetime.timedelta:
    &#34;&#34;&#34;Uses the package pytimeparse2 by wroberts/onegreyonewhite
        to convert a string into a timedelta object.
        Examples:
            - 32m
            - 2h32m
            - 3d2h32m
            - 1w3d2h32m
            - 1w 3d 2h 32m
            - 1 w 3 d 2 h 32 m
            - 4:13
            - 4:13:02
            - 4:13:02.266
            - 2:04:13:02.266
            - 2 days, 4:13:02 (uptime format)
            - 2 days, 4:13:02.266
            - 5hr34m56s
            - 5 hours, 34 minutes, 56 seconds
            - 5 hrs, 34 mins, 56 secs
            - 2 days, 5 hours, 34 minutes, 56 seconds
            - 1.2 m
            - 1.2 min
            - 1.2 mins
            - 1.2 minute
            - 1.2 minutes
            - 172 hours
            - 172 hr
            - 172 h
            - 172 hrs
            - 172 hour
            - 1.24 days
            - 5 d
            - 5 day
            - 5 days
            - 5.6 wk
            - 5.6 week
            - 5.6 weeks

    Args:
        str_delta (str): The time delta string to convert

    Returns:
        datetime.timedelta: The time delta object
    &#34;&#34;&#34;
    try:
        parsed = time_parse(str_delta, as_timedelta=True, raise_exception=True)
        return parsed
    except Exception as ex:
        raise ValueError(
            f&#34;Could not parse time delta string {str_delta} : {ex}&#34;
        ) from ex</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sshkey_tools.utils.bytes_to_long"><code class="name flex">
<span>def <span class="ident">bytes_to_long</span></span>(<span>source_bytes: bytes, byteorder: str = 'big') ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>The opposite of long_to_bytes, converts a byte string to a long integer
Equivalent to paramiko.util.inflate_long()</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source_bytes</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The byte string to convert</dd>
<dt><strong><code>byteorder</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Byte order. Defaults to 'big'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Long integer resulting from decoding the byte string</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bytes_to_long(source_bytes: bytes, byteorder: str = &#34;big&#34;) -&gt; int:
    &#34;&#34;&#34;The opposite of long_to_bytes, converts a byte string to a long integer
       Equivalent to paramiko.util.inflate_long()
    Args:
        source_bytes (bytes): The byte string to convert
        byteorder (str, optional): Byte order. Defaults to &#39;big&#39;.

    Returns:
        int: Long integer resulting from decoding the byte string
    &#34;&#34;&#34;
    if not isinstance(source_bytes, bytes):
        raise TypeError(f&#34;Expected bytes, got {type(source_bytes).__name__}.&#34;)

    return int.from_bytes(source_bytes, byteorder)</code></pre>
</details>
</dd>
<dt id="sshkey_tools.utils.concat_to_bytestring"><code class="name flex">
<span>def <span class="ident">concat_to_bytestring</span></span>(<span>*strs, encoding: str = 'utf-8') ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Concatenates a list of strings or bytestrings to a single bytestring.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>encoding</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The encoding of the string/s. Defaults to 'utf-8'.</dd>
<dt><strong><code>*strs</code></strong> :&ensp;<code>List[str, bytes]</code></dt>
<dd>The strings to concatenate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>Concatenated bytestring</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def concat_to_bytestring(*strs, encoding: str = &#34;utf-8&#34;) -&gt; bytes:
    &#34;&#34;&#34;Concatenates a list of strings or bytestrings to a single bytestring.

    Args:
        encoding (str, optional): The encoding of the string/s. Defaults to &#39;utf-8&#39;.
        *strs (List[str, bytes]): The strings to concatenate

    Returns:
        bytes: Concatenated bytestring
    &#34;&#34;&#34;
    return b&#34;&#34;.join(
        st if st is not None else b&#34;&#34;
        for st in ensure_bytestring(strs, encoding=encoding)
    )</code></pre>
</details>
</dd>
<dt id="sshkey_tools.utils.concat_to_string"><code class="name flex">
<span>def <span class="ident">concat_to_string</span></span>(<span>*strs, encoding: str = 'utf-8') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Concatenates a list of strings or bytestrings to a single string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>encoding</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The encoding of the string/s. Defaults to 'utf-8'.</dd>
<dt><strong><code>*strs</code></strong> :&ensp;<code>List[str, bytes]</code></dt>
<dd>The strings to concatenate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Concatenated string</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def concat_to_string(*strs, encoding: str = &#34;utf-8&#34;) -&gt; str:
    &#34;&#34;&#34;Concatenates a list of strings or bytestrings to a single string.

    Args:
        encoding (str, optional): The encoding of the string/s. Defaults to &#39;utf-8&#39;.
        *strs (List[str, bytes]): The strings to concatenate

    Returns:
        str: Concatenated string
    &#34;&#34;&#34;
    return &#34;&#34;.join(st if st is not None else &#34;&#34; for st in ensure_string(strs, encoding))</code></pre>
</details>
</dd>
<dt id="sshkey_tools.utils.ensure_bytestring"><code class="name flex">
<span>def <span class="ident">ensure_bytestring</span></span>(<span>obj: Union[str, bytes, list, tuple, set, dict, ForwardRef(None)], encoding: str = 'utf-8', required: bool = None) ‑> Union[str, List[str], Dict[str, str], ForwardRef(None)]</span>
</code></dt>
<dd>
<div class="desc"><p>Ensure the provided value is or contains a bytestring/bytestrings</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong> :&ensp;<code>_type_</code></dt>
<dd>The object to process</dd>
<dt><strong><code>encoding</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The encoding of the provided bytestrings. Defaults to 'utf-8'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[str, List[str], Dict[str, str]]</code></dt>
<dd>Returns a bytestring, list of bytestrings or
dictionary with bytestrings</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ensure_bytestring(
    obj: Union[str, bytes, list, tuple, set, dict, NoneType],
    encoding: str = &#34;utf-8&#34;,
    required: bool = None,
) -&gt; Union[str, List[str], Dict[str, str], NoneType]:
    &#34;&#34;&#34;Ensure the provided value is or contains a bytestring/bytestrings

    Args:
        obj (_type_): The object to process
        encoding (str, optional): The encoding of the provided bytestrings. Defaults to &#39;utf-8&#39;.

    Returns:
        Union[str, List[str], Dict[str, str]]: Returns a bytestring, list of bytestrings or
                                               dictionary with bytestrings
    &#34;&#34;&#34;
    if (obj is None and not required) or isinstance(obj, bytes):
        return obj
    if isinstance(obj, str):
        return obj.encode(encoding)
    if isinstance(obj, (list, tuple, set)):
        return [ensure_bytestring(o, encoding) for o in obj]
    if isinstance(obj, dict):
        return {
            ensure_bytestring(k, encoding): ensure_bytestring(v, encoding)
            for k, v in obj.items()
        }
    raise TypeError(
        f&#34;Expected one of (str, bytes, list, tuple, dict, set), got {type(obj).__name__}.&#34;
    )</code></pre>
</details>
</dd>
<dt id="sshkey_tools.utils.ensure_string"><code class="name flex">
<span>def <span class="ident">ensure_string</span></span>(<span>obj: Union[str, bytes, list, tuple, set, dict, ForwardRef(None)], encoding: str = 'utf-8', required: bool = False) ‑> Union[str, List[str], Dict[str, str], ForwardRef(None)]</span>
</code></dt>
<dd>
<div class="desc"><p>Ensure the provided value is or contains a string/strings</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong> :&ensp;<code>_type_</code></dt>
<dd>The object to process</dd>
<dt><strong><code>encoding</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The encoding of the provided strings. Defaults to 'utf-8'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[str, List[str], Dict[str, str]]</code></dt>
<dd>Returns a string, list of strings or
dictionary with strings</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ensure_string(
    obj: Union[str, bytes, list, tuple, set, dict, NoneType],
    encoding: str = &#34;utf-8&#34;,
    required: bool = False,
) -&gt; Union[str, List[str], Dict[str, str], NoneType]:
    &#34;&#34;&#34;Ensure the provided value is or contains a string/strings

    Args:
        obj (_type_): The object to process
        encoding (str, optional): The encoding of the provided strings. Defaults to &#39;utf-8&#39;.

    Returns:
        Union[str, List[str], Dict[str, str]]: Returns a string, list of strings or
                                               dictionary with strings
    &#34;&#34;&#34;
    if (obj is None and not required) or isinstance(obj, str):
        return obj
    if isinstance(obj, bytes):
        return obj.decode(encoding)
    if isinstance(obj, (list, tuple, set)):
        return [ensure_string(o, encoding) for o in obj]
    if isinstance(obj, dict):
        return {
            ensure_string(k, encoding): ensure_string(v, encoding)
            for k, v in obj.items()
        }

    raise TypeError(
        f&#34;Expected one of (str, bytes, list, tuple, dict, set), got {type(obj).__name__}.&#34;
    )</code></pre>
</details>
</dd>
<dt id="sshkey_tools.utils.generate_secure_nonce"><code class="name flex">
<span>def <span class="ident">generate_secure_nonce</span></span>(<span>length: int = 128)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a secure random nonce of the specified length.
Mainly important for ECDSA keys, but is used with all key/certificate types
<a href="https://blog.trailofbits.com/2020/06/11/ecdsa-handle-with-care/">https://blog.trailofbits.com/2020/06/11/ecdsa-handle-with-care/</a>
<a href="https://datatracker.ietf.org/doc/html/rfc6979">https://datatracker.ietf.org/doc/html/rfc6979</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>length</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Length of the nonce. Defaults to 64.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Nonce of the specified length</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_secure_nonce(length: int = 128):
    &#34;&#34;&#34;Generates a secure random nonce of the specified length.
        Mainly important for ECDSA keys, but is used with all key/certificate types
        https://blog.trailofbits.com/2020/06/11/ecdsa-handle-with-care/
        https://datatracker.ietf.org/doc/html/rfc6979
    Args:
        length (int, optional): Length of the nonce. Defaults to 64.

    Returns:
        str: Nonce of the specified length
    &#34;&#34;&#34;
    return str(randbits(length))</code></pre>
</details>
</dd>
<dt id="sshkey_tools.utils.join_dicts"><code class="name flex">
<span>def <span class="ident">join_dicts</span></span>(<span>*dicts) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Joins two or more dictionaries together.
In case of duplicate keys, the latest one wins.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Joined dictionary</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join_dicts(*dicts) -&gt; dict:
    &#34;&#34;&#34;
    Joins two or more dictionaries together.
    In case of duplicate keys, the latest one wins.

    Returns:
        dict: Joined dictionary
    &#34;&#34;&#34;
    py_version = sys.version_info[0:2]
    return_dict = {}

    if py_version[0] == 3 and py_version[1] &gt; 9:
        for add_dict in dicts:
            return_dict = return_dict | add_dict

        return return_dict

    for add_dict in dicts:
        return_dict = {**return_dict, **add_dict}

    return return_dict</code></pre>
</details>
</dd>
<dt id="sshkey_tools.utils.long_to_bytes"><code class="name flex">
<span>def <span class="ident">long_to_bytes</span></span>(<span>source_int: int, force_length: int = None, byteorder: str = 'big') ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a positive integer to a byte string conforming with the certificate format.
Equivalent to paramiko.util.deflate_long()</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source_int</code></strong> :&ensp;<code>int</code></dt>
<dd>Integer to convert</dd>
<dt><strong><code>force_length</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Pads the resulting bytestring if shorter. Defaults to None.</dd>
<dt><strong><code>byteorder</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Byte order. Defaults to 'big'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Byte string representing the chosen long integer</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def long_to_bytes(
    source_int: int, force_length: int = None, byteorder: str = &#34;big&#34;
) -&gt; bytes:
    &#34;&#34;&#34;Converts a positive integer to a byte string conforming with the certificate format.
        Equivalent to paramiko.util.deflate_long()
    Args:
        source_int (int): Integer to convert
        force_length (int, optional): Pads the resulting bytestring if shorter. Defaults to None.
        byteorder (str, optional): Byte order. Defaults to &#39;big&#39;.

    Returns:
        str: Byte string representing the chosen long integer
    &#34;&#34;&#34;
    if source_int &lt; 0:
        raise ValueError(
            &#34;You can only convert positive long integers to bytes with this method&#34;
        )

    if not isinstance(source_int, int):
        raise TypeError(f&#34;Expected integer, got {type(source_int).__name__}.&#34;)

    length = (source_int.bit_length() // 8 + 1) if not force_length else force_length
    return source_int.to_bytes(length, byteorder)</code></pre>
</details>
</dd>
<dt id="sshkey_tools.utils.md5_fingerprint"><code class="name flex">
<span>def <span class="ident">md5_fingerprint</span></span>(<span>data: bytes, prefix: bool = True) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an MD5 fingerprint of the given data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The data to fingerprint</dd>
<dt><strong><code>prefix</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to prefix the fingerprint with MD5:</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The fingerprint (OpenSSH style MD5:xx:xx:xx&hellip;)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def md5_fingerprint(data: bytes, prefix: bool = True) -&gt; str:
    &#34;&#34;&#34;
    Returns an MD5 fingerprint of the given data.

    Args:
        data (bytes): The data to fingerprint
        prefix (bool, optional): Whether to prefix the fingerprint with MD5:

    Returns:
        str: The fingerprint (OpenSSH style MD5:xx:xx:xx...)
    &#34;&#34;&#34;
    digest = hl.md5(data).hexdigest()
    return (&#34;MD5:&#34; if prefix else &#34;&#34;) + &#34;:&#34;.join(
        a + b for a, b in zip(digest[::2], digest[1::2])
    )</code></pre>
</details>
</dd>
<dt id="sshkey_tools.utils.nullsafe_getattr"><code class="name flex">
<span>def <span class="ident">nullsafe_getattr</span></span>(<span>obj, attr: str, default)</span>
</code></dt>
<dd>
<div class="desc"><p>Null-safe getattr, ensuring the result is not None.
If the result is None, the default value is returned instead.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong></dt>
<dd>The object</dd>
<dt><strong><code>attr</code></strong></dt>
<dd>The attribute to get</dd>
<dt><strong><code>default</code></strong></dt>
<dd>The default value</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nullsafe_getattr(obj, attr: str, default):
    &#34;&#34;&#34;
    Null-safe getattr, ensuring the result is not None.
    If the result is None, the default value is returned instead.

    Args:
        obj: The object
        attr: The attribute to get
        default: The default value
    &#34;&#34;&#34;
    att = getattr(obj, attr, default)
    if att is None:
        att = default
    
    return att</code></pre>
</details>
</dd>
<dt id="sshkey_tools.utils.random_keyid"><code class="name flex">
<span>def <span class="ident">random_keyid</span></span>(<span>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a random Key ID</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Random keyid</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def random_keyid() -&gt; str:
    &#34;&#34;&#34;Generates a random Key ID

    Returns:
        str: Random keyid
    &#34;&#34;&#34;
    return str(uuid4())</code></pre>
</details>
</dd>
<dt id="sshkey_tools.utils.random_serial"><code class="name flex">
<span>def <span class="ident">random_serial</span></span>(<span>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a random serial number</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Random serial</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def random_serial() -&gt; str:
    &#34;&#34;&#34;Generates a random serial number

    Returns:
        int: Random serial
    &#34;&#34;&#34;
    return randint(0, 2**64 - 1)</code></pre>
</details>
</dd>
<dt id="sshkey_tools.utils.sha256_fingerprint"><code class="name flex">
<span>def <span class="ident">sha256_fingerprint</span></span>(<span>data: bytes, prefix: bool = True) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a SHA256 fingerprint of the given data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The data to fingerprint</dd>
<dt><strong><code>prefix</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to prefix the fingerprint with SHA256:</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The fingerprint (OpenSSH style SHA256:xx:xx:xx&hellip;)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sha256_fingerprint(data: bytes, prefix: bool = True) -&gt; str:
    &#34;&#34;&#34;
    Returns a SHA256 fingerprint of the given data.

    Args:
        data (bytes): The data to fingerprint
        prefix (bool, optional): Whether to prefix the fingerprint with SHA256:

    Returns:
        str: The fingerprint (OpenSSH style SHA256:xx:xx:xx...)
    &#34;&#34;&#34;
    digest = hl.sha256(data).digest()
    return (&#34;SHA256:&#34; if prefix else &#34;&#34;) + b64encode(digest).replace(b&#34;=&#34;, b&#34;&#34;).decode(
        &#34;utf-8&#34;
    )</code></pre>
</details>
</dd>
<dt id="sshkey_tools.utils.sha512_fingerprint"><code class="name flex">
<span>def <span class="ident">sha512_fingerprint</span></span>(<span>data: bytes, prefix: bool = True) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a SHA512 fingerprint of the given data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The data to fingerprint</dd>
<dt><strong><code>prefix</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to prefix the fingerprint with SHA512:</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The fingerprint (OpenSSH style SHA256:xx:xx:xx&hellip;)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sha512_fingerprint(data: bytes, prefix: bool = True) -&gt; str:
    &#34;&#34;&#34;
    Returns a SHA512 fingerprint of the given data.

    Args:
        data (bytes): The data to fingerprint
        prefix (bool, optional): Whether to prefix the fingerprint with SHA512:

    Returns:
        str: The fingerprint (OpenSSH style SHA256:xx:xx:xx...)
    &#34;&#34;&#34;
    digest = hl.sha512(data).digest()
    return (&#34;SHA512:&#34; if prefix else &#34;&#34;) + b64encode(digest).replace(b&#34;=&#34;, b&#34;&#34;).decode(
        &#34;utf-8&#34;
    )</code></pre>
</details>
</dd>
<dt id="sshkey_tools.utils.str_to_time_delta"><code class="name flex">
<span>def <span class="ident">str_to_time_delta</span></span>(<span>str_delta: str) ‑> datetime.timedelta</span>
</code></dt>
<dd>
<div class="desc"><p>Uses the package pytimeparse2 by wroberts/onegreyonewhite
to convert a string into a timedelta object.
Examples:
- 32m
- 2h32m
- 3d2h32m
- 1w3d2h32m
- 1w 3d 2h 32m
- 1 w 3 d 2 h 32 m
- 4:13
- 4:13:02
- 4:13:02.266
- 2:04:13:02.266
- 2 days, 4:13:02 (uptime format)
- 2 days, 4:13:02.266
- 5hr34m56s
- 5 hours, 34 minutes, 56 seconds
- 5 hrs, 34 mins, 56 secs
- 2 days, 5 hours, 34 minutes, 56 seconds
- 1.2 m
- 1.2 min
- 1.2 mins
- 1.2 minute
- 1.2 minutes
- 172 hours
- 172 hr
- 172 h
- 172 hrs
- 172 hour
- 1.24 days
- 5 d
- 5 day
- 5 days
- 5.6 wk
- 5.6 week
- 5.6 weeks</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>str_delta</code></strong> :&ensp;<code>str</code></dt>
<dd>The time delta string to convert</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>datetime.timedelta</code></dt>
<dd>The time delta object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def str_to_time_delta(str_delta: str) -&gt; datetime.timedelta:
    &#34;&#34;&#34;Uses the package pytimeparse2 by wroberts/onegreyonewhite
        to convert a string into a timedelta object.
        Examples:
            - 32m
            - 2h32m
            - 3d2h32m
            - 1w3d2h32m
            - 1w 3d 2h 32m
            - 1 w 3 d 2 h 32 m
            - 4:13
            - 4:13:02
            - 4:13:02.266
            - 2:04:13:02.266
            - 2 days, 4:13:02 (uptime format)
            - 2 days, 4:13:02.266
            - 5hr34m56s
            - 5 hours, 34 minutes, 56 seconds
            - 5 hrs, 34 mins, 56 secs
            - 2 days, 5 hours, 34 minutes, 56 seconds
            - 1.2 m
            - 1.2 min
            - 1.2 mins
            - 1.2 minute
            - 1.2 minutes
            - 172 hours
            - 172 hr
            - 172 h
            - 172 hrs
            - 172 hour
            - 1.24 days
            - 5 d
            - 5 day
            - 5 days
            - 5.6 wk
            - 5.6 week
            - 5.6 weeks

    Args:
        str_delta (str): The time delta string to convert

    Returns:
        datetime.timedelta: The time delta object
    &#34;&#34;&#34;
    try:
        parsed = time_parse(str_delta, as_timedelta=True, raise_exception=True)
        return parsed
    except Exception as ex:
        raise ValueError(
            f&#34;Could not parse time delta string {str_delta} : {ex}&#34;
        ) from ex</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sshkey_tools" href="index.html">sshkey_tools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sshkey_tools.utils.bytes_to_long" href="#sshkey_tools.utils.bytes_to_long">bytes_to_long</a></code></li>
<li><code><a title="sshkey_tools.utils.concat_to_bytestring" href="#sshkey_tools.utils.concat_to_bytestring">concat_to_bytestring</a></code></li>
<li><code><a title="sshkey_tools.utils.concat_to_string" href="#sshkey_tools.utils.concat_to_string">concat_to_string</a></code></li>
<li><code><a title="sshkey_tools.utils.ensure_bytestring" href="#sshkey_tools.utils.ensure_bytestring">ensure_bytestring</a></code></li>
<li><code><a title="sshkey_tools.utils.ensure_string" href="#sshkey_tools.utils.ensure_string">ensure_string</a></code></li>
<li><code><a title="sshkey_tools.utils.generate_secure_nonce" href="#sshkey_tools.utils.generate_secure_nonce">generate_secure_nonce</a></code></li>
<li><code><a title="sshkey_tools.utils.join_dicts" href="#sshkey_tools.utils.join_dicts">join_dicts</a></code></li>
<li><code><a title="sshkey_tools.utils.long_to_bytes" href="#sshkey_tools.utils.long_to_bytes">long_to_bytes</a></code></li>
<li><code><a title="sshkey_tools.utils.md5_fingerprint" href="#sshkey_tools.utils.md5_fingerprint">md5_fingerprint</a></code></li>
<li><code><a title="sshkey_tools.utils.nullsafe_getattr" href="#sshkey_tools.utils.nullsafe_getattr">nullsafe_getattr</a></code></li>
<li><code><a title="sshkey_tools.utils.random_keyid" href="#sshkey_tools.utils.random_keyid">random_keyid</a></code></li>
<li><code><a title="sshkey_tools.utils.random_serial" href="#sshkey_tools.utils.random_serial">random_serial</a></code></li>
<li><code><a title="sshkey_tools.utils.sha256_fingerprint" href="#sshkey_tools.utils.sha256_fingerprint">sha256_fingerprint</a></code></li>
<li><code><a title="sshkey_tools.utils.sha512_fingerprint" href="#sshkey_tools.utils.sha512_fingerprint">sha512_fingerprint</a></code></li>
<li><code><a title="sshkey_tools.utils.str_to_time_delta" href="#sshkey_tools.utils.str_to_time_delta">str_to_time_delta</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>